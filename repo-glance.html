<!DOCTYPE html>
<html lang="ja" data-theme="light">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="GitHubリポジトリのコードを一つのテキストに変換するオフラインツール">
    <title>Repo Glance - Offline Edition</title>
    <script src="env.js"></script>
    <script>
        /*!
        
        JSZip v3.10.1 - A JavaScript class for generating and reading zip files
        <http://stuartk.com/jszip>
        
        (c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
        Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/main/LICENSE.markdown.
        
        JSZip uses the library pako released under the MIT license :
        https://github.com/nodeca/pako/blob/main/LICENSE
        */

        !function (e) { if ("object" == typeof exports && "undefined" != typeof module) module.exports = e(); else if ("function" == typeof define && define.amd) define([], e); else { ("undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this).JSZip = e() } }(function () { return function s(a, o, h) { function u(r, e) { if (!o[r]) { if (!a[r]) { var t = "function" == typeof require && require; if (!e && t) return t(r, !0); if (l) return l(r, !0); var n = new Error("Cannot find module '" + r + "'"); throw n.code = "MODULE_NOT_FOUND", n } var i = o[r] = { exports: {} }; a[r][0].call(i.exports, function (e) { var t = a[r][1][e]; return u(t || e) }, i, i.exports, s, a, o, h) } return o[r].exports } for (var l = "function" == typeof require && require, e = 0; e < h.length; e++)u(h[e]); return u }({ 1: [function (e, t, r) { "use strict"; var d = e("./utils"), c = e("./support"), p = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="; r.encode = function (e) { for (var t, r, n, i, s, a, o, h = [], u = 0, l = e.length, f = l, c = "string" !== d.getTypeOf(e); u < e.length;)f = l - u, n = c ? (t = e[u++], r = u < l ? e[u++] : 0, u < l ? e[u++] : 0) : (t = e.charCodeAt(u++), r = u < l ? e.charCodeAt(u++) : 0, u < l ? e.charCodeAt(u++) : 0), i = t >> 2, s = (3 & t) << 4 | r >> 4, a = 1 < f ? (15 & r) << 2 | n >> 6 : 64, o = 2 < f ? 63 & n : 64, h.push(p.charAt(i) + p.charAt(s) + p.charAt(a) + p.charAt(o)); return h.join("") }, r.decode = function (e) { var t, r, n, i, s, a, o = 0, h = 0, u = "data:"; if (e.substr(0, u.length) === u) throw new Error("Invalid base64 input, it looks like a data url."); var l, f = 3 * (e = e.replace(/[^A-Za-z0-9+/=]/g, "")).length / 4; if (e.charAt(e.length - 1) === p.charAt(64) && f--, e.charAt(e.length - 2) === p.charAt(64) && f--, f % 1 != 0) throw new Error("Invalid base64 input, bad content length."); for (l = c.uint8array ? new Uint8Array(0 | f) : new Array(0 | f); o < e.length;)t = p.indexOf(e.charAt(o++)) << 2 | (i = p.indexOf(e.charAt(o++))) >> 4, r = (15 & i) << 4 | (s = p.indexOf(e.charAt(o++))) >> 2, n = (3 & s) << 6 | (a = p.indexOf(e.charAt(o++))), l[h++] = t, 64 !== s && (l[h++] = r), 64 !== a && (l[h++] = n); return l } }, { "./support": 30, "./utils": 32 }], 2: [function (e, t, r) { "use strict"; var n = e("./external"), i = e("./stream/DataWorker"), s = e("./stream/Crc32Probe"), a = e("./stream/DataLengthProbe"); function o(e, t, r, n, i) { this.compressedSize = e, this.uncompressedSize = t, this.crc32 = r, this.compression = n, this.compressedContent = i } o.prototype = { getContentWorker: function () { var e = new i(n.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new a("data_length")), t = this; return e.on("end", function () { if (this.streamInfo.data_length !== t.uncompressedSize) throw new Error("Bug : uncompressed data size mismatch") }), e }, getCompressedWorker: function () { return new i(n.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression) } }, o.createWorkerFrom = function (e, t, r) { return e.pipe(new s).pipe(new a("uncompressedSize")).pipe(t.compressWorker(r)).pipe(new a("compressedSize")).withStreamInfo("compression", t) }, t.exports = o }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function (e, t, r) { "use strict"; var n = e("./stream/GenericWorker"); r.STORE = { magic: "\0\0", compressWorker: function () { return new n("STORE compression") }, uncompressWorker: function () { return new n("STORE decompression") } }, r.DEFLATE = e("./flate") }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function (e, t, r) { "use strict"; var n = e("./utils"); var o = function () { for (var e, t = [], r = 0; r < 256; r++) { e = r; for (var n = 0; n < 8; n++)e = 1 & e ? 3988292384 ^ e >>> 1 : e >>> 1; t[r] = e } return t }(); t.exports = function (e, t) { return void 0 !== e && e.length ? "string" !== n.getTypeOf(e) ? function (e, t, r, n) { var i = o, s = n + r; e ^= -1; for (var a = n; a < s; a++)e = e >>> 8 ^ i[255 & (e ^ t[a])]; return -1 ^ e }(0 | t, e, e.length, 0) : function (e, t, r, n) { var i = o, s = n + r; e ^= -1; for (var a = n; a < s; a++)e = e >>> 8 ^ i[255 & (e ^ t.charCodeAt(a))]; return -1 ^ e }(0 | t, e, e.length, 0) : 0 } }, { "./utils": 32 }], 5: [function (e, t, r) { "use strict"; r.base64 = !1, r.binary = !1, r.dir = !1, r.createFolders = !0, r.date = null, r.compression = null, r.compressionOptions = null, r.comment = null, r.unixPermissions = null, r.dosPermissions = null }, {}], 6: [function (e, t, r) { "use strict"; var n = null; n = "undefined" != typeof Promise ? Promise : e("lie"), t.exports = { Promise: n } }, { lie: 37 }], 7: [function (e, t, r) { "use strict"; var n = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Uint32Array, i = e("pako"), s = e("./utils"), a = e("./stream/GenericWorker"), o = n ? "uint8array" : "array"; function h(e, t) { a.call(this, "FlateWorker/" + e), this._pako = null, this._pakoAction = e, this._pakoOptions = t, this.meta = {} } r.magic = "\b\0", s.inherits(h, a), h.prototype.processChunk = function (e) { this.meta = e.meta, null === this._pako && this._createPako(), this._pako.push(s.transformTo(o, e.data), !1) }, h.prototype.flush = function () { a.prototype.flush.call(this), null === this._pako && this._createPako(), this._pako.push([], !0) }, h.prototype.cleanUp = function () { a.prototype.cleanUp.call(this), this._pako = null }, h.prototype._createPako = function () { this._pako = new i[this._pakoAction]({ raw: !0, level: this._pakoOptions.level || -1 }); var t = this; this._pako.onData = function (e) { t.push({ data: e, meta: t.meta }) } }, r.compressWorker = function (e) { return new h("Deflate", e) }, r.uncompressWorker = function () { return new h("Inflate", {}) } }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function (e, t, r) { "use strict"; function A(e, t) { var r, n = ""; for (r = 0; r < t; r++)n += String.fromCharCode(255 & e), e >>>= 8; return n } function n(e, t, r, n, i, s) { var a, o, h = e.file, u = e.compression, l = s !== O.utf8encode, f = I.transformTo("string", s(h.name)), c = I.transformTo("string", O.utf8encode(h.name)), d = h.comment, p = I.transformTo("string", s(d)), m = I.transformTo("string", O.utf8encode(d)), _ = c.length !== h.name.length, g = m.length !== d.length, b = "", v = "", y = "", w = h.dir, k = h.date, x = { crc32: 0, compressedSize: 0, uncompressedSize: 0 }; t && !r || (x.crc32 = e.crc32, x.compressedSize = e.compressedSize, x.uncompressedSize = e.uncompressedSize); var S = 0; t && (S |= 8), l || !_ && !g || (S |= 2048); var z = 0, C = 0; w && (z |= 16), "UNIX" === i ? (C = 798, z |= function (e, t) { var r = e; return e || (r = t ? 16893 : 33204), (65535 & r) << 16 }(h.unixPermissions, w)) : (C = 20, z |= function (e) { return 63 & (e || 0) }(h.dosPermissions)), a = k.getUTCHours(), a <<= 6, a |= k.getUTCMinutes(), a <<= 5, a |= k.getUTCSeconds() / 2, o = k.getUTCFullYear() - 1980, o <<= 4, o |= k.getUTCMonth() + 1, o <<= 5, o |= k.getUTCDate(), _ && (v = A(1, 1) + A(B(f), 4) + c, b += "up" + A(v.length, 2) + v), g && (y = A(1, 1) + A(B(p), 4) + m, b += "uc" + A(y.length, 2) + y); var E = ""; return E += "\n\0", E += A(S, 2), E += u.magic, E += A(a, 2), E += A(o, 2), E += A(x.crc32, 4), E += A(x.compressedSize, 4), E += A(x.uncompressedSize, 4), E += A(f.length, 2), E += A(b.length, 2), { fileRecord: R.LOCAL_FILE_HEADER + E + f + b, dirRecord: R.CENTRAL_FILE_HEADER + A(C, 2) + E + A(p.length, 2) + "\0\0\0\0" + A(z, 4) + A(n, 4) + f + b + p } } var I = e("../utils"), i = e("../stream/GenericWorker"), O = e("../utf8"), B = e("../crc32"), R = e("../signature"); function s(e, t, r, n) { i.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = t, this.zipPlatform = r, this.encodeFileName = n, this.streamFiles = e, this.accumulate = !1, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [] } I.inherits(s, i), s.prototype.push = function (e) { var t = e.meta.percent || 0, r = this.entriesCount, n = this._sources.length; this.accumulate ? this.contentBuffer.push(e) : (this.bytesWritten += e.data.length, i.prototype.push.call(this, { data: e.data, meta: { currentFile: this.currentFile, percent: r ? (t + 100 * (r - n - 1)) / r : 100 } })) }, s.prototype.openedSource = function (e) { this.currentSourceOffset = this.bytesWritten, this.currentFile = e.file.name; var t = this.streamFiles && !e.file.dir; if (t) { var r = n(e, t, !1, this.currentSourceOffset, this.zipPlatform, this.encodeFileName); this.push({ data: r.fileRecord, meta: { percent: 0 } }) } else this.accumulate = !0 }, s.prototype.closedSource = function (e) { this.accumulate = !1; var t = this.streamFiles && !e.file.dir, r = n(e, t, !0, this.currentSourceOffset, this.zipPlatform, this.encodeFileName); if (this.dirRecords.push(r.dirRecord), t) this.push({ data: function (e) { return R.DATA_DESCRIPTOR + A(e.crc32, 4) + A(e.compressedSize, 4) + A(e.uncompressedSize, 4) }(e), meta: { percent: 100 } }); else for (this.push({ data: r.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length;)this.push(this.contentBuffer.shift()); this.currentFile = null }, s.prototype.flush = function () { for (var e = this.bytesWritten, t = 0; t < this.dirRecords.length; t++)this.push({ data: this.dirRecords[t], meta: { percent: 100 } }); var r = this.bytesWritten - e, n = function (e, t, r, n, i) { var s = I.transformTo("string", i(n)); return R.CENTRAL_DIRECTORY_END + "\0\0\0\0" + A(e, 2) + A(e, 2) + A(t, 4) + A(r, 4) + A(s.length, 2) + s }(this.dirRecords.length, r, e, this.zipComment, this.encodeFileName); this.push({ data: n, meta: { percent: 100 } }) }, s.prototype.prepareNextSource = function () { this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume() }, s.prototype.registerPrevious = function (e) { this._sources.push(e); var t = this; return e.on("data", function (e) { t.processChunk(e) }), e.on("end", function () { t.closedSource(t.previous.streamInfo), t._sources.length ? t.prepareNextSource() : t.end() }), e.on("error", function (e) { t.error(e) }), this }, s.prototype.resume = function () { return !!i.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), !0) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), !0)) }, s.prototype.error = function (e) { var t = this._sources; if (!i.prototype.error.call(this, e)) return !1; for (var r = 0; r < t.length; r++)try { t[r].error(e) } catch (e) { } return !0 }, s.prototype.lock = function () { i.prototype.lock.call(this); for (var e = this._sources, t = 0; t < e.length; t++)e[t].lock() }, t.exports = s }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function (e, t, r) { "use strict"; var u = e("../compressions"), n = e("./ZipFileWorker"); r.generateWorker = function (e, a, t) { var o = new n(a.streamFiles, t, a.platform, a.encodeFileName), h = 0; try { e.forEach(function (e, t) { h++; var r = function (e, t) { var r = e || t, n = u[r]; if (!n) throw new Error(r + " is not a valid compression method !"); return n }(t.options.compression, a.compression), n = t.options.compressionOptions || a.compressionOptions || {}, i = t.dir, s = t.date; t._compressWorker(r, n).withStreamInfo("file", { name: e, dir: i, date: s, comment: t.comment || "", unixPermissions: t.unixPermissions, dosPermissions: t.dosPermissions }).pipe(o) }), o.entriesCount = h } catch (e) { o.error(e) } return o } }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function (e, t, r) { "use strict"; function n() { if (!(this instanceof n)) return new n; if (arguments.length) throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide."); this.files = Object.create(null), this.comment = null, this.root = "", this.clone = function () { var e = new n; for (var t in this) "function" != typeof this[t] && (e[t] = this[t]); return e } } (n.prototype = e("./object")).loadAsync = e("./load"), n.support = e("./support"), n.defaults = e("./defaults"), n.version = "3.10.1", n.loadAsync = function (e, t) { return (new n).loadAsync(e, t) }, n.external = e("./external"), t.exports = n }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function (e, t, r) { "use strict"; var u = e("./utils"), i = e("./external"), n = e("./utf8"), s = e("./zipEntries"), a = e("./stream/Crc32Probe"), l = e("./nodejsUtils"); function f(n) { return new i.Promise(function (e, t) { var r = n.decompressed.getContentWorker().pipe(new a); r.on("error", function (e) { t(e) }).on("end", function () { r.streamInfo.crc32 !== n.decompressed.crc32 ? t(new Error("Corrupted zip : CRC32 mismatch")) : e() }).resume() }) } t.exports = function (e, o) { var h = this; return o = u.extend(o || {}, { base64: !1, checkCRC32: !1, optimizedBinaryString: !1, createFolders: !1, decodeFileName: n.utf8decode }), l.isNode && l.isStream(e) ? i.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : u.prepareContent("the loaded zip file", e, !0, o.optimizedBinaryString, o.base64).then(function (e) { var t = new s(o); return t.load(e), t }).then(function (e) { var t = [i.Promise.resolve(e)], r = e.files; if (o.checkCRC32) for (var n = 0; n < r.length; n++)t.push(f(r[n])); return i.Promise.all(t) }).then(function (e) { for (var t = e.shift(), r = t.files, n = 0; n < r.length; n++) { var i = r[n], s = i.fileNameStr, a = u.resolve(i.fileNameStr); h.file(a, i.decompressed, { binary: !0, optimizedBinaryString: !0, date: i.date, dir: i.dir, comment: i.fileCommentStr.length ? i.fileCommentStr : null, unixPermissions: i.unixPermissions, dosPermissions: i.dosPermissions, createFolders: o.createFolders }), i.dir || (h.file(a).unsafeOriginalName = s) } return t.zipComment.length && (h.comment = t.zipComment), h }) } }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function (e, t, r) { "use strict"; var n = e("../utils"), i = e("../stream/GenericWorker"); function s(e, t) { i.call(this, "Nodejs stream input adapter for " + e), this._upstreamEnded = !1, this._bindStream(t) } n.inherits(s, i), s.prototype._bindStream = function (e) { var t = this; (this._stream = e).pause(), e.on("data", function (e) { t.push({ data: e, meta: { percent: 0 } }) }).on("error", function (e) { t.isPaused ? this.generatedError = e : t.error(e) }).on("end", function () { t.isPaused ? t._upstreamEnded = !0 : t.end() }) }, s.prototype.pause = function () { return !!i.prototype.pause.call(this) && (this._stream.pause(), !0) }, s.prototype.resume = function () { return !!i.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), !0) }, t.exports = s }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function (e, t, r) { "use strict"; var i = e("readable-stream").Readable; function n(e, t, r) { i.call(this, t), this._helper = e; var n = this; e.on("data", function (e, t) { n.push(e) || n._helper.pause(), r && r(t) }).on("error", function (e) { n.emit("error", e) }).on("end", function () { n.push(null) }) } e("../utils").inherits(n, i), n.prototype._read = function () { this._helper.resume() }, t.exports = n }, { "../utils": 32, "readable-stream": 16 }], 14: [function (e, t, r) { "use strict"; t.exports = { isNode: "undefined" != typeof Buffer, newBufferFrom: function (e, t) { if (Buffer.from && Buffer.from !== Uint8Array.from) return Buffer.from(e, t); if ("number" == typeof e) throw new Error('The "data" argument must not be a number'); return new Buffer(e, t) }, allocBuffer: function (e) { if (Buffer.alloc) return Buffer.alloc(e); var t = new Buffer(e); return t.fill(0), t }, isBuffer: function (e) { return Buffer.isBuffer(e) }, isStream: function (e) { return e && "function" == typeof e.on && "function" == typeof e.pause && "function" == typeof e.resume } } }, {}], 15: [function (e, t, r) { "use strict"; function s(e, t, r) { var n, i = u.getTypeOf(t), s = u.extend(r || {}, f); s.date = s.date || new Date, null !== s.compression && (s.compression = s.compression.toUpperCase()), "string" == typeof s.unixPermissions && (s.unixPermissions = parseInt(s.unixPermissions, 8)), s.unixPermissions && 16384 & s.unixPermissions && (s.dir = !0), s.dosPermissions && 16 & s.dosPermissions && (s.dir = !0), s.dir && (e = g(e)), s.createFolders && (n = _(e)) && b.call(this, n, !0); var a = "string" === i && !1 === s.binary && !1 === s.base64; r && void 0 !== r.binary || (s.binary = !a), (t instanceof c && 0 === t.uncompressedSize || s.dir || !t || 0 === t.length) && (s.base64 = !1, s.binary = !0, t = "", s.compression = "STORE", i = "string"); var o = null; o = t instanceof c || t instanceof l ? t : p.isNode && p.isStream(t) ? new m(e, t) : u.prepareContent(e, t, s.binary, s.optimizedBinaryString, s.base64); var h = new d(e, o, s); this.files[e] = h } var i = e("./utf8"), u = e("./utils"), l = e("./stream/GenericWorker"), a = e("./stream/StreamHelper"), f = e("./defaults"), c = e("./compressedObject"), d = e("./zipObject"), o = e("./generate"), p = e("./nodejsUtils"), m = e("./nodejs/NodejsStreamInputAdapter"), _ = function (e) { "/" === e.slice(-1) && (e = e.substring(0, e.length - 1)); var t = e.lastIndexOf("/"); return 0 < t ? e.substring(0, t) : "" }, g = function (e) { return "/" !== e.slice(-1) && (e += "/"), e }, b = function (e, t) { return t = void 0 !== t ? t : f.createFolders, e = g(e), this.files[e] || s.call(this, e, null, { dir: !0, createFolders: t }), this.files[e] }; function h(e) { return "[object RegExp]" === Object.prototype.toString.call(e) } var n = { load: function () { throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.") }, forEach: function (e) { var t, r, n; for (t in this.files) n = this.files[t], (r = t.slice(this.root.length, t.length)) && t.slice(0, this.root.length) === this.root && e(r, n) }, filter: function (r) { var n = []; return this.forEach(function (e, t) { r(e, t) && n.push(t) }), n }, file: function (e, t, r) { if (1 !== arguments.length) return e = this.root + e, s.call(this, e, t, r), this; if (h(e)) { var n = e; return this.filter(function (e, t) { return !t.dir && n.test(e) }) } var i = this.files[this.root + e]; return i && !i.dir ? i : null }, folder: function (r) { if (!r) return this; if (h(r)) return this.filter(function (e, t) { return t.dir && r.test(e) }); var e = this.root + r, t = b.call(this, e), n = this.clone(); return n.root = t.name, n }, remove: function (r) { r = this.root + r; var e = this.files[r]; if (e || ("/" !== r.slice(-1) && (r += "/"), e = this.files[r]), e && !e.dir) delete this.files[r]; else for (var t = this.filter(function (e, t) { return t.name.slice(0, r.length) === r }), n = 0; n < t.length; n++)delete this.files[t[n].name]; return this }, generate: function () { throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.") }, generateInternalStream: function (e) { var t, r = {}; try { if ((r = u.extend(e || {}, { streamFiles: !1, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: i.utf8encode })).type = r.type.toLowerCase(), r.compression = r.compression.toUpperCase(), "binarystring" === r.type && (r.type = "string"), !r.type) throw new Error("No output type specified."); u.checkSupport(r.type), "darwin" !== r.platform && "freebsd" !== r.platform && "linux" !== r.platform && "sunos" !== r.platform || (r.platform = "UNIX"), "win32" === r.platform && (r.platform = "DOS"); var n = r.comment || this.comment || ""; t = o.generateWorker(this, r, n) } catch (e) { (t = new l("error")).error(e) } return new a(t, r.type || "string", r.mimeType) }, generateAsync: function (e, t) { return this.generateInternalStream(e).accumulate(t) }, generateNodeStream: function (e, t) { return (e = e || {}).type || (e.type = "nodebuffer"), this.generateInternalStream(e).toNodejsStream(t) } }; t.exports = n }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function (e, t, r) { "use strict"; t.exports = e("stream") }, { stream: void 0 }], 17: [function (e, t, r) { "use strict"; var n = e("./DataReader"); function i(e) { n.call(this, e); for (var t = 0; t < this.data.length; t++)e[t] = 255 & e[t] } e("../utils").inherits(i, n), i.prototype.byteAt = function (e) { return this.data[this.zero + e] }, i.prototype.lastIndexOfSignature = function (e) { for (var t = e.charCodeAt(0), r = e.charCodeAt(1), n = e.charCodeAt(2), i = e.charCodeAt(3), s = this.length - 4; 0 <= s; --s)if (this.data[s] === t && this.data[s + 1] === r && this.data[s + 2] === n && this.data[s + 3] === i) return s - this.zero; return -1 }, i.prototype.readAndCheckSignature = function (e) { var t = e.charCodeAt(0), r = e.charCodeAt(1), n = e.charCodeAt(2), i = e.charCodeAt(3), s = this.readData(4); return t === s[0] && r === s[1] && n === s[2] && i === s[3] }, i.prototype.readData = function (e) { if (this.checkOffset(e), 0 === e) return []; var t = this.data.slice(this.zero + this.index, this.zero + this.index + e); return this.index += e, t }, t.exports = i }, { "../utils": 32, "./DataReader": 18 }], 18: [function (e, t, r) { "use strict"; var n = e("../utils"); function i(e) { this.data = e, this.length = e.length, this.index = 0, this.zero = 0 } i.prototype = { checkOffset: function (e) { this.checkIndex(this.index + e) }, checkIndex: function (e) { if (this.length < this.zero + e || e < 0) throw new Error("End of data reached (data length = " + this.length + ", asked index = " + e + "). Corrupted zip ?") }, setIndex: function (e) { this.checkIndex(e), this.index = e }, skip: function (e) { this.setIndex(this.index + e) }, byteAt: function () { }, readInt: function (e) { var t, r = 0; for (this.checkOffset(e), t = this.index + e - 1; t >= this.index; t--)r = (r << 8) + this.byteAt(t); return this.index += e, r }, readString: function (e) { return n.transformTo("string", this.readData(e)) }, readData: function () { }, lastIndexOfSignature: function () { }, readAndCheckSignature: function () { }, readDate: function () { var e = this.readInt(4); return new Date(Date.UTC(1980 + (e >> 25 & 127), (e >> 21 & 15) - 1, e >> 16 & 31, e >> 11 & 31, e >> 5 & 63, (31 & e) << 1)) } }, t.exports = i }, { "../utils": 32 }], 19: [function (e, t, r) { "use strict"; var n = e("./Uint8ArrayReader"); function i(e) { n.call(this, e) } e("../utils").inherits(i, n), i.prototype.readData = function (e) { this.checkOffset(e); var t = this.data.slice(this.zero + this.index, this.zero + this.index + e); return this.index += e, t }, t.exports = i }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function (e, t, r) { "use strict"; var n = e("./DataReader"); function i(e) { n.call(this, e) } e("../utils").inherits(i, n), i.prototype.byteAt = function (e) { return this.data.charCodeAt(this.zero + e) }, i.prototype.lastIndexOfSignature = function (e) { return this.data.lastIndexOf(e) - this.zero }, i.prototype.readAndCheckSignature = function (e) { return e === this.readData(4) }, i.prototype.readData = function (e) { this.checkOffset(e); var t = this.data.slice(this.zero + this.index, this.zero + this.index + e); return this.index += e, t }, t.exports = i }, { "../utils": 32, "./DataReader": 18 }], 21: [function (e, t, r) { "use strict"; var n = e("./ArrayReader"); function i(e) { n.call(this, e) } e("../utils").inherits(i, n), i.prototype.readData = function (e) { if (this.checkOffset(e), 0 === e) return new Uint8Array(0); var t = this.data.subarray(this.zero + this.index, this.zero + this.index + e); return this.index += e, t }, t.exports = i }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function (e, t, r) { "use strict"; var n = e("../utils"), i = e("../support"), s = e("./ArrayReader"), a = e("./StringReader"), o = e("./NodeBufferReader"), h = e("./Uint8ArrayReader"); t.exports = function (e) { var t = n.getTypeOf(e); return n.checkSupport(t), "string" !== t || i.uint8array ? "nodebuffer" === t ? new o(e) : i.uint8array ? new h(n.transformTo("uint8array", e)) : new s(n.transformTo("array", e)) : new a(e) } }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function (e, t, r) { "use strict"; r.LOCAL_FILE_HEADER = "PK", r.CENTRAL_FILE_HEADER = "PK", r.CENTRAL_DIRECTORY_END = "PK", r.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK", r.ZIP64_CENTRAL_DIRECTORY_END = "PK", r.DATA_DESCRIPTOR = "PK\b" }, {}], 24: [function (e, t, r) { "use strict"; var n = e("./GenericWorker"), i = e("../utils"); function s(e) { n.call(this, "ConvertWorker to " + e), this.destType = e } i.inherits(s, n), s.prototype.processChunk = function (e) { this.push({ data: i.transformTo(this.destType, e.data), meta: e.meta }) }, t.exports = s }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function (e, t, r) { "use strict"; var n = e("./GenericWorker"), i = e("../crc32"); function s() { n.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0) } e("../utils").inherits(s, n), s.prototype.processChunk = function (e) { this.streamInfo.crc32 = i(e.data, this.streamInfo.crc32 || 0), this.push(e) }, t.exports = s }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function (e, t, r) { "use strict"; var n = e("../utils"), i = e("./GenericWorker"); function s(e) { i.call(this, "DataLengthProbe for " + e), this.propName = e, this.withStreamInfo(e, 0) } n.inherits(s, i), s.prototype.processChunk = function (e) { if (e) { var t = this.streamInfo[this.propName] || 0; this.streamInfo[this.propName] = t + e.data.length } i.prototype.processChunk.call(this, e) }, t.exports = s }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function (e, t, r) { "use strict"; var n = e("../utils"), i = e("./GenericWorker"); function s(e) { i.call(this, "DataWorker"); var t = this; this.dataIsReady = !1, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = !1, e.then(function (e) { t.dataIsReady = !0, t.data = e, t.max = e && e.length || 0, t.type = n.getTypeOf(e), t.isPaused || t._tickAndRepeat() }, function (e) { t.error(e) }) } n.inherits(s, i), s.prototype.cleanUp = function () { i.prototype.cleanUp.call(this), this.data = null }, s.prototype.resume = function () { return !!i.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = !0, n.delay(this._tickAndRepeat, [], this)), !0) }, s.prototype._tickAndRepeat = function () { this._tickScheduled = !1, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (n.delay(this._tickAndRepeat, [], this), this._tickScheduled = !0)) }, s.prototype._tick = function () { if (this.isPaused || this.isFinished) return !1; var e = null, t = Math.min(this.max, this.index + 16384); if (this.index >= this.max) return this.end(); switch (this.type) { case "string": e = this.data.substring(this.index, t); break; case "uint8array": e = this.data.subarray(this.index, t); break; case "array": case "nodebuffer": e = this.data.slice(this.index, t) }return this.index = t, this.push({ data: e, meta: { percent: this.max ? this.index / this.max * 100 : 0 } }) }, t.exports = s }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function (e, t, r) { "use strict"; function n(e) { this.name = e || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = !0, this.isFinished = !1, this.isLocked = !1, this._listeners = { data: [], end: [], error: [] }, this.previous = null } n.prototype = { push: function (e) { this.emit("data", e) }, end: function () { if (this.isFinished) return !1; this.flush(); try { this.emit("end"), this.cleanUp(), this.isFinished = !0 } catch (e) { this.emit("error", e) } return !0 }, error: function (e) { return !this.isFinished && (this.isPaused ? this.generatedError = e : (this.isFinished = !0, this.emit("error", e), this.previous && this.previous.error(e), this.cleanUp()), !0) }, on: function (e, t) { return this._listeners[e].push(t), this }, cleanUp: function () { this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [] }, emit: function (e, t) { if (this._listeners[e]) for (var r = 0; r < this._listeners[e].length; r++)this._listeners[e][r].call(this, t) }, pipe: function (e) { return e.registerPrevious(this) }, registerPrevious: function (e) { if (this.isLocked) throw new Error("The stream '" + this + "' has already been used."); this.streamInfo = e.streamInfo, this.mergeStreamInfo(), this.previous = e; var t = this; return e.on("data", function (e) { t.processChunk(e) }), e.on("end", function () { t.end() }), e.on("error", function (e) { t.error(e) }), this }, pause: function () { return !this.isPaused && !this.isFinished && (this.isPaused = !0, this.previous && this.previous.pause(), !0) }, resume: function () { if (!this.isPaused || this.isFinished) return !1; var e = this.isPaused = !1; return this.generatedError && (this.error(this.generatedError), e = !0), this.previous && this.previous.resume(), !e }, flush: function () { }, processChunk: function (e) { this.push(e) }, withStreamInfo: function (e, t) { return this.extraStreamInfo[e] = t, this.mergeStreamInfo(), this }, mergeStreamInfo: function () { for (var e in this.extraStreamInfo) Object.prototype.hasOwnProperty.call(this.extraStreamInfo, e) && (this.streamInfo[e] = this.extraStreamInfo[e]) }, lock: function () { if (this.isLocked) throw new Error("The stream '" + this + "' has already been used."); this.isLocked = !0, this.previous && this.previous.lock() }, toString: function () { var e = "Worker " + this.name; return this.previous ? this.previous + " -> " + e : e } }, t.exports = n }, {}], 29: [function (e, t, r) { "use strict"; var h = e("../utils"), i = e("./ConvertWorker"), s = e("./GenericWorker"), u = e("../base64"), n = e("../support"), a = e("../external"), o = null; if (n.nodestream) try { o = e("../nodejs/NodejsStreamOutputAdapter") } catch (e) { } function l(e, o) { return new a.Promise(function (t, r) { var n = [], i = e._internalType, s = e._outputType, a = e._mimeType; e.on("data", function (e, t) { n.push(e), o && o(t) }).on("error", function (e) { n = [], r(e) }).on("end", function () { try { var e = function (e, t, r) { switch (e) { case "blob": return h.newBlob(h.transformTo("arraybuffer", t), r); case "base64": return u.encode(t); default: return h.transformTo(e, t) } }(s, function (e, t) { var r, n = 0, i = null, s = 0; for (r = 0; r < t.length; r++)s += t[r].length; switch (e) { case "string": return t.join(""); case "array": return Array.prototype.concat.apply([], t); case "uint8array": for (i = new Uint8Array(s), r = 0; r < t.length; r++)i.set(t[r], n), n += t[r].length; return i; case "nodebuffer": return Buffer.concat(t); default: throw new Error("concat : unsupported type '" + e + "'") } }(i, n), a); t(e) } catch (e) { r(e) } n = [] }).resume() }) } function f(e, t, r) { var n = t; switch (t) { case "blob": case "arraybuffer": n = "uint8array"; break; case "base64": n = "string" }try { this._internalType = n, this._outputType = t, this._mimeType = r, h.checkSupport(n), this._worker = e.pipe(new i(n)), e.lock() } catch (e) { this._worker = new s("error"), this._worker.error(e) } } f.prototype = { accumulate: function (e) { return l(this, e) }, on: function (e, t) { var r = this; return "data" === e ? this._worker.on(e, function (e) { t.call(r, e.data, e.meta) }) : this._worker.on(e, function () { h.delay(t, arguments, r) }), this }, resume: function () { return h.delay(this._worker.resume, [], this._worker), this }, pause: function () { return this._worker.pause(), this }, toNodejsStream: function (e) { if (h.checkSupport("nodestream"), "nodebuffer" !== this._outputType) throw new Error(this._outputType + " is not supported by this method"); return new o(this, { objectMode: "nodebuffer" !== this._outputType }, e) } }, t.exports = f }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function (e, t, r) { "use strict"; if (r.base64 = !0, r.array = !0, r.string = !0, r.arraybuffer = "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8Array, r.nodebuffer = "undefined" != typeof Buffer, r.uint8array = "undefined" != typeof Uint8Array, "undefined" == typeof ArrayBuffer) r.blob = !1; else { var n = new ArrayBuffer(0); try { r.blob = 0 === new Blob([n], { type: "application/zip" }).size } catch (e) { try { var i = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder); i.append(n), r.blob = 0 === i.getBlob("application/zip").size } catch (e) { r.blob = !1 } } } try { r.nodestream = !!e("readable-stream").Readable } catch (e) { r.nodestream = !1 } }, { "readable-stream": 16 }], 31: [function (e, t, s) { "use strict"; for (var o = e("./utils"), h = e("./support"), r = e("./nodejsUtils"), n = e("./stream/GenericWorker"), u = new Array(256), i = 0; i < 256; i++)u[i] = 252 <= i ? 6 : 248 <= i ? 5 : 240 <= i ? 4 : 224 <= i ? 3 : 192 <= i ? 2 : 1; u[254] = u[254] = 1; function a() { n.call(this, "utf-8 decode"), this.leftOver = null } function l() { n.call(this, "utf-8 encode") } s.utf8encode = function (e) { return h.nodebuffer ? r.newBufferFrom(e, "utf-8") : function (e) { var t, r, n, i, s, a = e.length, o = 0; for (i = 0; i < a; i++)55296 == (64512 & (r = e.charCodeAt(i))) && i + 1 < a && 56320 == (64512 & (n = e.charCodeAt(i + 1))) && (r = 65536 + (r - 55296 << 10) + (n - 56320), i++), o += r < 128 ? 1 : r < 2048 ? 2 : r < 65536 ? 3 : 4; for (t = h.uint8array ? new Uint8Array(o) : new Array(o), i = s = 0; s < o; i++)55296 == (64512 & (r = e.charCodeAt(i))) && i + 1 < a && 56320 == (64512 & (n = e.charCodeAt(i + 1))) && (r = 65536 + (r - 55296 << 10) + (n - 56320), i++), r < 128 ? t[s++] = r : (r < 2048 ? t[s++] = 192 | r >>> 6 : (r < 65536 ? t[s++] = 224 | r >>> 12 : (t[s++] = 240 | r >>> 18, t[s++] = 128 | r >>> 12 & 63), t[s++] = 128 | r >>> 6 & 63), t[s++] = 128 | 63 & r); return t }(e) }, s.utf8decode = function (e) { return h.nodebuffer ? o.transformTo("nodebuffer", e).toString("utf-8") : function (e) { var t, r, n, i, s = e.length, a = new Array(2 * s); for (t = r = 0; t < s;)if ((n = e[t++]) < 128) a[r++] = n; else if (4 < (i = u[n])) a[r++] = 65533, t += i - 1; else { for (n &= 2 === i ? 31 : 3 === i ? 15 : 7; 1 < i && t < s;)n = n << 6 | 63 & e[t++], i--; 1 < i ? a[r++] = 65533 : n < 65536 ? a[r++] = n : (n -= 65536, a[r++] = 55296 | n >> 10 & 1023, a[r++] = 56320 | 1023 & n) } return a.length !== r && (a.subarray ? a = a.subarray(0, r) : a.length = r), o.applyFromCharCode(a) }(e = o.transformTo(h.uint8array ? "uint8array" : "array", e)) }, o.inherits(a, n), a.prototype.processChunk = function (e) { var t = o.transformTo(h.uint8array ? "uint8array" : "array", e.data); if (this.leftOver && this.leftOver.length) { if (h.uint8array) { var r = t; (t = new Uint8Array(r.length + this.leftOver.length)).set(this.leftOver, 0), t.set(r, this.leftOver.length) } else t = this.leftOver.concat(t); this.leftOver = null } var n = function (e, t) { var r; for ((t = t || e.length) > e.length && (t = e.length), r = t - 1; 0 <= r && 128 == (192 & e[r]);)r--; return r < 0 ? t : 0 === r ? t : r + u[e[r]] > t ? r : t }(t), i = t; n !== t.length && (h.uint8array ? (i = t.subarray(0, n), this.leftOver = t.subarray(n, t.length)) : (i = t.slice(0, n), this.leftOver = t.slice(n, t.length))), this.push({ data: s.utf8decode(i), meta: e.meta }) }, a.prototype.flush = function () { this.leftOver && this.leftOver.length && (this.push({ data: s.utf8decode(this.leftOver), meta: {} }), this.leftOver = null) }, s.Utf8DecodeWorker = a, o.inherits(l, n), l.prototype.processChunk = function (e) { this.push({ data: s.utf8encode(e.data), meta: e.meta }) }, s.Utf8EncodeWorker = l }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function (e, t, a) { "use strict"; var o = e("./support"), h = e("./base64"), r = e("./nodejsUtils"), u = e("./external"); function n(e) { return e } function l(e, t) { for (var r = 0; r < e.length; ++r)t[r] = 255 & e.charCodeAt(r); return t } e("setimmediate"), a.newBlob = function (t, r) { a.checkSupport("blob"); try { return new Blob([t], { type: r }) } catch (e) { try { var n = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder); return n.append(t), n.getBlob(r) } catch (e) { throw new Error("Bug : can't construct the Blob.") } } }; var i = { stringifyByChunk: function (e, t, r) { var n = [], i = 0, s = e.length; if (s <= r) return String.fromCharCode.apply(null, e); for (; i < s;)"array" === t || "nodebuffer" === t ? n.push(String.fromCharCode.apply(null, e.slice(i, Math.min(i + r, s)))) : n.push(String.fromCharCode.apply(null, e.subarray(i, Math.min(i + r, s)))), i += r; return n.join("") }, stringifyByChar: function (e) { for (var t = "", r = 0; r < e.length; r++)t += String.fromCharCode(e[r]); return t }, applyCanBeUsed: { uint8array: function () { try { return o.uint8array && 1 === String.fromCharCode.apply(null, new Uint8Array(1)).length } catch (e) { return !1 } }(), nodebuffer: function () { try { return o.nodebuffer && 1 === String.fromCharCode.apply(null, r.allocBuffer(1)).length } catch (e) { return !1 } }() } }; function s(e) { var t = 65536, r = a.getTypeOf(e), n = !0; if ("uint8array" === r ? n = i.applyCanBeUsed.uint8array : "nodebuffer" === r && (n = i.applyCanBeUsed.nodebuffer), n) for (; 1 < t;)try { return i.stringifyByChunk(e, r, t) } catch (e) { t = Math.floor(t / 2) } return i.stringifyByChar(e) } function f(e, t) { for (var r = 0; r < e.length; r++)t[r] = e[r]; return t } a.applyFromCharCode = s; var c = {}; c.string = { string: n, array: function (e) { return l(e, new Array(e.length)) }, arraybuffer: function (e) { return c.string.uint8array(e).buffer }, uint8array: function (e) { return l(e, new Uint8Array(e.length)) }, nodebuffer: function (e) { return l(e, r.allocBuffer(e.length)) } }, c.array = { string: s, array: n, arraybuffer: function (e) { return new Uint8Array(e).buffer }, uint8array: function (e) { return new Uint8Array(e) }, nodebuffer: function (e) { return r.newBufferFrom(e) } }, c.arraybuffer = { string: function (e) { return s(new Uint8Array(e)) }, array: function (e) { return f(new Uint8Array(e), new Array(e.byteLength)) }, arraybuffer: n, uint8array: function (e) { return new Uint8Array(e) }, nodebuffer: function (e) { return r.newBufferFrom(new Uint8Array(e)) } }, c.uint8array = { string: s, array: function (e) { return f(e, new Array(e.length)) }, arraybuffer: function (e) { return e.buffer }, uint8array: n, nodebuffer: function (e) { return r.newBufferFrom(e) } }, c.nodebuffer = { string: s, array: function (e) { return f(e, new Array(e.length)) }, arraybuffer: function (e) { return c.nodebuffer.uint8array(e).buffer }, uint8array: function (e) { return f(e, new Uint8Array(e.length)) }, nodebuffer: n }, a.transformTo = function (e, t) { if (t = t || "", !e) return t; a.checkSupport(e); var r = a.getTypeOf(t); return c[r][e](t) }, a.resolve = function (e) { for (var t = e.split("/"), r = [], n = 0; n < t.length; n++) { var i = t[n]; "." === i || "" === i && 0 !== n && n !== t.length - 1 || (".." === i ? r.pop() : r.push(i)) } return r.join("/") }, a.getTypeOf = function (e) { return "string" == typeof e ? "string" : "[object Array]" === Object.prototype.toString.call(e) ? "array" : o.nodebuffer && r.isBuffer(e) ? "nodebuffer" : o.uint8array && e instanceof Uint8Array ? "uint8array" : o.arraybuffer && e instanceof ArrayBuffer ? "arraybuffer" : void 0 }, a.checkSupport = function (e) { if (!o[e.toLowerCase()]) throw new Error(e + " is not supported by this platform") }, a.MAX_VALUE_16BITS = 65535, a.MAX_VALUE_32BITS = -1, a.pretty = function (e) { var t, r, n = ""; for (r = 0; r < (e || "").length; r++)n += "\\x" + ((t = e.charCodeAt(r)) < 16 ? "0" : "") + t.toString(16).toUpperCase(); return n }, a.delay = function (e, t, r) { setImmediate(function () { e.apply(r || null, t || []) }) }, a.inherits = function (e, t) { function r() { } r.prototype = t.prototype, e.prototype = new r }, a.extend = function () { var e, t, r = {}; for (e = 0; e < arguments.length; e++)for (t in arguments[e]) Object.prototype.hasOwnProperty.call(arguments[e], t) && void 0 === r[t] && (r[t] = arguments[e][t]); return r }, a.prepareContent = function (r, e, n, i, s) { return u.Promise.resolve(e).then(function (n) { return o.blob && (n instanceof Blob || -1 !== ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(n))) && "undefined" != typeof FileReader ? new u.Promise(function (t, r) { var e = new FileReader; e.onload = function (e) { t(e.target.result) }, e.onerror = function (e) { r(e.target.error) }, e.readAsArrayBuffer(n) }) : n }).then(function (e) { var t = a.getTypeOf(e); return t ? ("arraybuffer" === t ? e = a.transformTo("uint8array", e) : "string" === t && (s ? e = h.decode(e) : n && !0 !== i && (e = function (e) { return l(e, o.uint8array ? new Uint8Array(e.length) : new Array(e.length)) }(e))), e) : u.Promise.reject(new Error("Can't read the data of '" + r + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?")) }) } }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, setimmediate: 54 }], 33: [function (e, t, r) { "use strict"; var n = e("./reader/readerFor"), i = e("./utils"), s = e("./signature"), a = e("./zipEntry"), o = e("./support"); function h(e) { this.files = [], this.loadOptions = e } h.prototype = { checkSignature: function (e) { if (!this.reader.readAndCheckSignature(e)) { this.reader.index -= 4; var t = this.reader.readString(4); throw new Error("Corrupted zip or bug: unexpected signature (" + i.pretty(t) + ", expected " + i.pretty(e) + ")") } }, isSignature: function (e, t) { var r = this.reader.index; this.reader.setIndex(e); var n = this.reader.readString(4) === t; return this.reader.setIndex(r), n }, readBlockEndOfCentral: function () { this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2); var e = this.reader.readData(this.zipCommentLength), t = o.uint8array ? "uint8array" : "array", r = i.transformTo(t, e); this.zipComment = this.loadOptions.decodeFileName(r) }, readBlockZip64EndOfCentral: function () { this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {}; for (var e, t, r, n = this.zip64EndOfCentralSize - 44; 0 < n;)e = this.reader.readInt(2), t = this.reader.readInt(4), r = this.reader.readData(t), this.zip64ExtensibleData[e] = { id: e, length: t, value: r } }, readBlockZip64EndOfCentralLocator: function () { if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount) throw new Error("Multi-volumes zip are not supported") }, readLocalFiles: function () { var e, t; for (e = 0; e < this.files.length; e++)t = this.files[e], this.reader.setIndex(t.localHeaderOffset), this.checkSignature(s.LOCAL_FILE_HEADER), t.readLocalPart(this.reader), t.handleUTF8(), t.processAttributes() }, readCentralDir: function () { var e; for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(s.CENTRAL_FILE_HEADER);)(e = new a({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(e); if (this.centralDirRecords !== this.files.length && 0 !== this.centralDirRecords && 0 === this.files.length) throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length) }, readEndOfCentral: function () { var e = this.reader.lastIndexOfSignature(s.CENTRAL_DIRECTORY_END); if (e < 0) throw !this.isSignature(0, s.LOCAL_FILE_HEADER) ? new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html") : new Error("Corrupted zip: can't find end of central directory"); this.reader.setIndex(e); var t = e; if (this.checkSignature(s.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === i.MAX_VALUE_16BITS || this.diskWithCentralDirStart === i.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === i.MAX_VALUE_16BITS || this.centralDirRecords === i.MAX_VALUE_16BITS || this.centralDirSize === i.MAX_VALUE_32BITS || this.centralDirOffset === i.MAX_VALUE_32BITS) { if (this.zip64 = !0, (e = this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator"); if (this.reader.setIndex(e), this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, s.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0)) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory"); this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral() } var r = this.centralDirOffset + this.centralDirSize; this.zip64 && (r += 20, r += 12 + this.zip64EndOfCentralSize); var n = t - r; if (0 < n) this.isSignature(t, s.CENTRAL_FILE_HEADER) || (this.reader.zero = n); else if (n < 0) throw new Error("Corrupted zip: missing " + Math.abs(n) + " bytes.") }, prepareReader: function (e) { this.reader = n(e) }, load: function (e) { this.prepareReader(e), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles() } }, t.exports = h }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utils": 32, "./zipEntry": 34 }], 34: [function (e, t, r) { "use strict"; var n = e("./reader/readerFor"), s = e("./utils"), i = e("./compressedObject"), a = e("./crc32"), o = e("./utf8"), h = e("./compressions"), u = e("./support"); function l(e, t) { this.options = e, this.loadOptions = t } l.prototype = { isEncrypted: function () { return 1 == (1 & this.bitFlag) }, useUTF8: function () { return 2048 == (2048 & this.bitFlag) }, readLocalPart: function (e) { var t, r; if (e.skip(22), this.fileNameLength = e.readInt(2), r = e.readInt(2), this.fileName = e.readData(this.fileNameLength), e.skip(r), -1 === this.compressedSize || -1 === this.uncompressedSize) throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)"); if (null === (t = function (e) { for (var t in h) if (Object.prototype.hasOwnProperty.call(h, t) && h[t].magic === e) return h[t]; return null }(this.compressionMethod))) throw new Error("Corrupted zip : compression " + s.pretty(this.compressionMethod) + " unknown (inner file : " + s.transformTo("string", this.fileName) + ")"); this.decompressed = new i(this.compressedSize, this.uncompressedSize, this.crc32, t, e.readData(this.compressedSize)) }, readCentralPart: function (e) { this.versionMadeBy = e.readInt(2), e.skip(2), this.bitFlag = e.readInt(2), this.compressionMethod = e.readString(2), this.date = e.readDate(), this.crc32 = e.readInt(4), this.compressedSize = e.readInt(4), this.uncompressedSize = e.readInt(4); var t = e.readInt(2); if (this.extraFieldsLength = e.readInt(2), this.fileCommentLength = e.readInt(2), this.diskNumberStart = e.readInt(2), this.internalFileAttributes = e.readInt(2), this.externalFileAttributes = e.readInt(4), this.localHeaderOffset = e.readInt(4), this.isEncrypted()) throw new Error("Encrypted zip are not supported"); e.skip(t), this.readExtraFields(e), this.parseZIP64ExtraField(e), this.fileComment = e.readData(this.fileCommentLength) }, processAttributes: function () { this.unixPermissions = null, this.dosPermissions = null; var e = this.versionMadeBy >> 8; this.dir = !!(16 & this.externalFileAttributes), 0 == e && (this.dosPermissions = 63 & this.externalFileAttributes), 3 == e && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || "/" !== this.fileNameStr.slice(-1) || (this.dir = !0) }, parseZIP64ExtraField: function () { if (this.extraFields[1]) { var e = n(this.extraFields[1].value); this.uncompressedSize === s.MAX_VALUE_32BITS && (this.uncompressedSize = e.readInt(8)), this.compressedSize === s.MAX_VALUE_32BITS && (this.compressedSize = e.readInt(8)), this.localHeaderOffset === s.MAX_VALUE_32BITS && (this.localHeaderOffset = e.readInt(8)), this.diskNumberStart === s.MAX_VALUE_32BITS && (this.diskNumberStart = e.readInt(4)) } }, readExtraFields: function (e) { var t, r, n, i = e.index + this.extraFieldsLength; for (this.extraFields || (this.extraFields = {}); e.index + 4 < i;)t = e.readInt(2), r = e.readInt(2), n = e.readData(r), this.extraFields[t] = { id: t, length: r, value: n }; e.setIndex(i) }, handleUTF8: function () { var e = u.uint8array ? "uint8array" : "array"; if (this.useUTF8()) this.fileNameStr = o.utf8decode(this.fileName), this.fileCommentStr = o.utf8decode(this.fileComment); else { var t = this.findExtraFieldUnicodePath(); if (null !== t) this.fileNameStr = t; else { var r = s.transformTo(e, this.fileName); this.fileNameStr = this.loadOptions.decodeFileName(r) } var n = this.findExtraFieldUnicodeComment(); if (null !== n) this.fileCommentStr = n; else { var i = s.transformTo(e, this.fileComment); this.fileCommentStr = this.loadOptions.decodeFileName(i) } } }, findExtraFieldUnicodePath: function () { var e = this.extraFields[28789]; if (e) { var t = n(e.value); return 1 !== t.readInt(1) ? null : a(this.fileName) !== t.readInt(4) ? null : o.utf8decode(t.readData(e.length - 5)) } return null }, findExtraFieldUnicodeComment: function () { var e = this.extraFields[25461]; if (e) { var t = n(e.value); return 1 !== t.readInt(1) ? null : a(this.fileComment) !== t.readInt(4) ? null : o.utf8decode(t.readData(e.length - 5)) } return null } }, t.exports = l }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function (e, t, r) { "use strict"; function n(e, t, r) { this.name = e, this.dir = r.dir, this.date = r.date, this.comment = r.comment, this.unixPermissions = r.unixPermissions, this.dosPermissions = r.dosPermissions, this._data = t, this._dataBinary = r.binary, this.options = { compression: r.compression, compressionOptions: r.compressionOptions } } var s = e("./stream/StreamHelper"), i = e("./stream/DataWorker"), a = e("./utf8"), o = e("./compressedObject"), h = e("./stream/GenericWorker"); n.prototype = { internalStream: function (e) { var t = null, r = "string"; try { if (!e) throw new Error("No output type specified."); var n = "string" === (r = e.toLowerCase()) || "text" === r; "binarystring" !== r && "text" !== r || (r = "string"), t = this._decompressWorker(); var i = !this._dataBinary; i && !n && (t = t.pipe(new a.Utf8EncodeWorker)), !i && n && (t = t.pipe(new a.Utf8DecodeWorker)) } catch (e) { (t = new h("error")).error(e) } return new s(t, r, "") }, async: function (e, t) { return this.internalStream(e).accumulate(t) }, nodeStream: function (e, t) { return this.internalStream(e || "nodebuffer").toNodejsStream(t) }, _compressWorker: function (e, t) { if (this._data instanceof o && this._data.compression.magic === e.magic) return this._data.getCompressedWorker(); var r = this._decompressWorker(); return this._dataBinary || (r = r.pipe(new a.Utf8EncodeWorker)), o.createWorkerFrom(r, e, t) }, _decompressWorker: function () { return this._data instanceof o ? this._data.getContentWorker() : this._data instanceof h ? this._data : new i(this._data) } }; for (var u = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], l = function () { throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.") }, f = 0; f < u.length; f++)n.prototype[u[f]] = l; t.exports = n }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function (e, l, t) { (function (t) { "use strict"; var r, n, e = t.MutationObserver || t.WebKitMutationObserver; if (e) { var i = 0, s = new e(u), a = t.document.createTextNode(""); s.observe(a, { characterData: !0 }), r = function () { a.data = i = ++i % 2 } } else if (t.setImmediate || void 0 === t.MessageChannel) r = "document" in t && "onreadystatechange" in t.document.createElement("script") ? function () { var e = t.document.createElement("script"); e.onreadystatechange = function () { u(), e.onreadystatechange = null, e.parentNode.removeChild(e), e = null }, t.document.documentElement.appendChild(e) } : function () { setTimeout(u, 0) }; else { var o = new t.MessageChannel; o.port1.onmessage = u, r = function () { o.port2.postMessage(0) } } var h = []; function u() { var e, t; n = !0; for (var r = h.length; r;) { for (t = h, h = [], e = -1; ++e < r;)t[e](); r = h.length } n = !1 } l.exports = function (e) { 1 !== h.push(e) || n || r() } }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}) }, {}], 37: [function (e, t, r) { "use strict"; var i = e("immediate"); function u() { } var l = {}, s = ["REJECTED"], a = ["FULFILLED"], n = ["PENDING"]; function o(e) { if ("function" != typeof e) throw new TypeError("resolver must be a function"); this.state = n, this.queue = [], this.outcome = void 0, e !== u && d(this, e) } function h(e, t, r) { this.promise = e, "function" == typeof t && (this.onFulfilled = t, this.callFulfilled = this.otherCallFulfilled), "function" == typeof r && (this.onRejected = r, this.callRejected = this.otherCallRejected) } function f(t, r, n) { i(function () { var e; try { e = r(n) } catch (e) { return l.reject(t, e) } e === t ? l.reject(t, new TypeError("Cannot resolve promise with itself")) : l.resolve(t, e) }) } function c(e) { var t = e && e.then; if (e && ("object" == typeof e || "function" == typeof e) && "function" == typeof t) return function () { t.apply(e, arguments) } } function d(t, e) { var r = !1; function n(e) { r || (r = !0, l.reject(t, e)) } function i(e) { r || (r = !0, l.resolve(t, e)) } var s = p(function () { e(i, n) }); "error" === s.status && n(s.value) } function p(e, t) { var r = {}; try { r.value = e(t), r.status = "success" } catch (e) { r.status = "error", r.value = e } return r } (t.exports = o).prototype.finally = function (t) { if ("function" != typeof t) return this; var r = this.constructor; return this.then(function (e) { return r.resolve(t()).then(function () { return e }) }, function (e) { return r.resolve(t()).then(function () { throw e }) }) }, o.prototype.catch = function (e) { return this.then(null, e) }, o.prototype.then = function (e, t) { if ("function" != typeof e && this.state === a || "function" != typeof t && this.state === s) return this; var r = new this.constructor(u); this.state !== n ? f(r, this.state === a ? e : t, this.outcome) : this.queue.push(new h(r, e, t)); return r }, h.prototype.callFulfilled = function (e) { l.resolve(this.promise, e) }, h.prototype.otherCallFulfilled = function (e) { f(this.promise, this.onFulfilled, e) }, h.prototype.callRejected = function (e) { l.reject(this.promise, e) }, h.prototype.otherCallRejected = function (e) { f(this.promise, this.onRejected, e) }, l.resolve = function (e, t) { var r = p(c, t); if ("error" === r.status) return l.reject(e, r.value); var n = r.value; if (n) d(e, n); else { e.state = a, e.outcome = t; for (var i = -1, s = e.queue.length; ++i < s;)e.queue[i].callFulfilled(t) } return e }, l.reject = function (e, t) { e.state = s, e.outcome = t; for (var r = -1, n = e.queue.length; ++r < n;)e.queue[r].callRejected(t); return e }, o.resolve = function (e) { if (e instanceof this) return e; return l.resolve(new this(u), e) }, o.reject = function (e) { var t = new this(u); return l.reject(t, e) }, o.all = function (e) { var r = this; if ("[object Array]" !== Object.prototype.toString.call(e)) return this.reject(new TypeError("must be an array")); var n = e.length, i = !1; if (!n) return this.resolve([]); var s = new Array(n), a = 0, t = -1, o = new this(u); for (; ++t < n;)h(e[t], t); return o; function h(e, t) { r.resolve(e).then(function (e) { s[t] = e, ++a !== n || i || (i = !0, l.resolve(o, s)) }, function (e) { i || (i = !0, l.reject(o, e)) }) } }, o.race = function (e) { var t = this; if ("[object Array]" !== Object.prototype.toString.call(e)) return this.reject(new TypeError("must be an array")); var r = e.length, n = !1; if (!r) return this.resolve([]); var i = -1, s = new this(u); for (; ++i < r;)a = e[i], t.resolve(a).then(function (e) { n || (n = !0, l.resolve(s, e)) }, function (e) { n || (n = !0, l.reject(s, e)) }); var a; return s } }, { immediate: 36 }], 38: [function (e, t, r) { "use strict"; var n = {}; (0, e("./lib/utils/common").assign)(n, e("./lib/deflate"), e("./lib/inflate"), e("./lib/zlib/constants")), t.exports = n }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function (e, t, r) { "use strict"; var a = e("./zlib/deflate"), o = e("./utils/common"), h = e("./utils/strings"), i = e("./zlib/messages"), s = e("./zlib/zstream"), u = Object.prototype.toString, l = 0, f = -1, c = 0, d = 8; function p(e) { if (!(this instanceof p)) return new p(e); this.options = o.assign({ level: f, method: d, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: c, to: "" }, e || {}); var t = this.options; t.raw && 0 < t.windowBits ? t.windowBits = -t.windowBits : t.gzip && 0 < t.windowBits && t.windowBits < 16 && (t.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new s, this.strm.avail_out = 0; var r = a.deflateInit2(this.strm, t.level, t.method, t.windowBits, t.memLevel, t.strategy); if (r !== l) throw new Error(i[r]); if (t.header && a.deflateSetHeader(this.strm, t.header), t.dictionary) { var n; if (n = "string" == typeof t.dictionary ? h.string2buf(t.dictionary) : "[object ArrayBuffer]" === u.call(t.dictionary) ? new Uint8Array(t.dictionary) : t.dictionary, (r = a.deflateSetDictionary(this.strm, n)) !== l) throw new Error(i[r]); this._dict_set = !0 } } function n(e, t) { var r = new p(t); if (r.push(e, !0), r.err) throw r.msg || i[r.err]; return r.result } p.prototype.push = function (e, t) { var r, n, i = this.strm, s = this.options.chunkSize; if (this.ended) return !1; n = t === ~~t ? t : !0 === t ? 4 : 0, "string" == typeof e ? i.input = h.string2buf(e) : "[object ArrayBuffer]" === u.call(e) ? i.input = new Uint8Array(e) : i.input = e, i.next_in = 0, i.avail_in = i.input.length; do { if (0 === i.avail_out && (i.output = new o.Buf8(s), i.next_out = 0, i.avail_out = s), 1 !== (r = a.deflate(i, n)) && r !== l) return this.onEnd(r), !(this.ended = !0); 0 !== i.avail_out && (0 !== i.avail_in || 4 !== n && 2 !== n) || ("string" === this.options.to ? this.onData(h.buf2binstring(o.shrinkBuf(i.output, i.next_out))) : this.onData(o.shrinkBuf(i.output, i.next_out))) } while ((0 < i.avail_in || 0 === i.avail_out) && 1 !== r); return 4 === n ? (r = a.deflateEnd(this.strm), this.onEnd(r), this.ended = !0, r === l) : 2 !== n || (this.onEnd(l), !(i.avail_out = 0)) }, p.prototype.onData = function (e) { this.chunks.push(e) }, p.prototype.onEnd = function (e) { e === l && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = o.flattenChunks(this.chunks)), this.chunks = [], this.err = e, this.msg = this.strm.msg }, r.Deflate = p, r.deflate = n, r.deflateRaw = function (e, t) { return (t = t || {}).raw = !0, n(e, t) }, r.gzip = function (e, t) { return (t = t || {}).gzip = !0, n(e, t) } }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function (e, t, r) { "use strict"; var c = e("./zlib/inflate"), d = e("./utils/common"), p = e("./utils/strings"), m = e("./zlib/constants"), n = e("./zlib/messages"), i = e("./zlib/zstream"), s = e("./zlib/gzheader"), _ = Object.prototype.toString; function a(e) { if (!(this instanceof a)) return new a(e); this.options = d.assign({ chunkSize: 16384, windowBits: 0, to: "" }, e || {}); var t = this.options; t.raw && 0 <= t.windowBits && t.windowBits < 16 && (t.windowBits = -t.windowBits, 0 === t.windowBits && (t.windowBits = -15)), !(0 <= t.windowBits && t.windowBits < 16) || e && e.windowBits || (t.windowBits += 32), 15 < t.windowBits && t.windowBits < 48 && 0 == (15 & t.windowBits) && (t.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new i, this.strm.avail_out = 0; var r = c.inflateInit2(this.strm, t.windowBits); if (r !== m.Z_OK) throw new Error(n[r]); this.header = new s, c.inflateGetHeader(this.strm, this.header) } function o(e, t) { var r = new a(t); if (r.push(e, !0), r.err) throw r.msg || n[r.err]; return r.result } a.prototype.push = function (e, t) { var r, n, i, s, a, o, h = this.strm, u = this.options.chunkSize, l = this.options.dictionary, f = !1; if (this.ended) return !1; n = t === ~~t ? t : !0 === t ? m.Z_FINISH : m.Z_NO_FLUSH, "string" == typeof e ? h.input = p.binstring2buf(e) : "[object ArrayBuffer]" === _.call(e) ? h.input = new Uint8Array(e) : h.input = e, h.next_in = 0, h.avail_in = h.input.length; do { if (0 === h.avail_out && (h.output = new d.Buf8(u), h.next_out = 0, h.avail_out = u), (r = c.inflate(h, m.Z_NO_FLUSH)) === m.Z_NEED_DICT && l && (o = "string" == typeof l ? p.string2buf(l) : "[object ArrayBuffer]" === _.call(l) ? new Uint8Array(l) : l, r = c.inflateSetDictionary(this.strm, o)), r === m.Z_BUF_ERROR && !0 === f && (r = m.Z_OK, f = !1), r !== m.Z_STREAM_END && r !== m.Z_OK) return this.onEnd(r), !(this.ended = !0); h.next_out && (0 !== h.avail_out && r !== m.Z_STREAM_END && (0 !== h.avail_in || n !== m.Z_FINISH && n !== m.Z_SYNC_FLUSH) || ("string" === this.options.to ? (i = p.utf8border(h.output, h.next_out), s = h.next_out - i, a = p.buf2string(h.output, i), h.next_out = s, h.avail_out = u - s, s && d.arraySet(h.output, h.output, i, s, 0), this.onData(a)) : this.onData(d.shrinkBuf(h.output, h.next_out)))), 0 === h.avail_in && 0 === h.avail_out && (f = !0) } while ((0 < h.avail_in || 0 === h.avail_out) && r !== m.Z_STREAM_END); return r === m.Z_STREAM_END && (n = m.Z_FINISH), n === m.Z_FINISH ? (r = c.inflateEnd(this.strm), this.onEnd(r), this.ended = !0, r === m.Z_OK) : n !== m.Z_SYNC_FLUSH || (this.onEnd(m.Z_OK), !(h.avail_out = 0)) }, a.prototype.onData = function (e) { this.chunks.push(e) }, a.prototype.onEnd = function (e) { e === m.Z_OK && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = d.flattenChunks(this.chunks)), this.chunks = [], this.err = e, this.msg = this.strm.msg }, r.Inflate = a, r.inflate = o, r.inflateRaw = function (e, t) { return (t = t || {}).raw = !0, o(e, t) }, r.ungzip = o }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function (e, t, r) { "use strict"; var n = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Int32Array; r.assign = function (e) { for (var t = Array.prototype.slice.call(arguments, 1); t.length;) { var r = t.shift(); if (r) { if ("object" != typeof r) throw new TypeError(r + "must be non-object"); for (var n in r) r.hasOwnProperty(n) && (e[n] = r[n]) } } return e }, r.shrinkBuf = function (e, t) { return e.length === t ? e : e.subarray ? e.subarray(0, t) : (e.length = t, e) }; var i = { arraySet: function (e, t, r, n, i) { if (t.subarray && e.subarray) e.set(t.subarray(r, r + n), i); else for (var s = 0; s < n; s++)e[i + s] = t[r + s] }, flattenChunks: function (e) { var t, r, n, i, s, a; for (t = n = 0, r = e.length; t < r; t++)n += e[t].length; for (a = new Uint8Array(n), t = i = 0, r = e.length; t < r; t++)s = e[t], a.set(s, i), i += s.length; return a } }, s = { arraySet: function (e, t, r, n, i) { for (var s = 0; s < n; s++)e[i + s] = t[r + s] }, flattenChunks: function (e) { return [].concat.apply([], e) } }; r.setTyped = function (e) { e ? (r.Buf8 = Uint8Array, r.Buf16 = Uint16Array, r.Buf32 = Int32Array, r.assign(r, i)) : (r.Buf8 = Array, r.Buf16 = Array, r.Buf32 = Array, r.assign(r, s)) }, r.setTyped(n) }, {}], 42: [function (e, t, r) { "use strict"; var h = e("./common"), i = !0, s = !0; try { String.fromCharCode.apply(null, [0]) } catch (e) { i = !1 } try { String.fromCharCode.apply(null, new Uint8Array(1)) } catch (e) { s = !1 } for (var u = new h.Buf8(256), n = 0; n < 256; n++)u[n] = 252 <= n ? 6 : 248 <= n ? 5 : 240 <= n ? 4 : 224 <= n ? 3 : 192 <= n ? 2 : 1; function l(e, t) { if (t < 65537 && (e.subarray && s || !e.subarray && i)) return String.fromCharCode.apply(null, h.shrinkBuf(e, t)); for (var r = "", n = 0; n < t; n++)r += String.fromCharCode(e[n]); return r } u[254] = u[254] = 1, r.string2buf = function (e) { var t, r, n, i, s, a = e.length, o = 0; for (i = 0; i < a; i++)55296 == (64512 & (r = e.charCodeAt(i))) && i + 1 < a && 56320 == (64512 & (n = e.charCodeAt(i + 1))) && (r = 65536 + (r - 55296 << 10) + (n - 56320), i++), o += r < 128 ? 1 : r < 2048 ? 2 : r < 65536 ? 3 : 4; for (t = new h.Buf8(o), i = s = 0; s < o; i++)55296 == (64512 & (r = e.charCodeAt(i))) && i + 1 < a && 56320 == (64512 & (n = e.charCodeAt(i + 1))) && (r = 65536 + (r - 55296 << 10) + (n - 56320), i++), r < 128 ? t[s++] = r : (r < 2048 ? t[s++] = 192 | r >>> 6 : (r < 65536 ? t[s++] = 224 | r >>> 12 : (t[s++] = 240 | r >>> 18, t[s++] = 128 | r >>> 12 & 63), t[s++] = 128 | r >>> 6 & 63), t[s++] = 128 | 63 & r); return t }, r.buf2binstring = function (e) { return l(e, e.length) }, r.binstring2buf = function (e) { for (var t = new h.Buf8(e.length), r = 0, n = t.length; r < n; r++)t[r] = e.charCodeAt(r); return t }, r.buf2string = function (e, t) { var r, n, i, s, a = t || e.length, o = new Array(2 * a); for (r = n = 0; r < a;)if ((i = e[r++]) < 128) o[n++] = i; else if (4 < (s = u[i])) o[n++] = 65533, r += s - 1; else { for (i &= 2 === s ? 31 : 3 === s ? 15 : 7; 1 < s && r < a;)i = i << 6 | 63 & e[r++], s--; 1 < s ? o[n++] = 65533 : i < 65536 ? o[n++] = i : (i -= 65536, o[n++] = 55296 | i >> 10 & 1023, o[n++] = 56320 | 1023 & i) } return l(o, n) }, r.utf8border = function (e, t) { var r; for ((t = t || e.length) > e.length && (t = e.length), r = t - 1; 0 <= r && 128 == (192 & e[r]);)r--; return r < 0 ? t : 0 === r ? t : r + u[e[r]] > t ? r : t } }, { "./common": 41 }], 43: [function (e, t, r) { "use strict"; t.exports = function (e, t, r, n) { for (var i = 65535 & e | 0, s = e >>> 16 & 65535 | 0, a = 0; 0 !== r;) { for (r -= a = 2e3 < r ? 2e3 : r; s = s + (i = i + t[n++] | 0) | 0, --a;); i %= 65521, s %= 65521 } return i | s << 16 | 0 } }, {}], 44: [function (e, t, r) { "use strict"; t.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 } }, {}], 45: [function (e, t, r) { "use strict"; var o = function () { for (var e, t = [], r = 0; r < 256; r++) { e = r; for (var n = 0; n < 8; n++)e = 1 & e ? 3988292384 ^ e >>> 1 : e >>> 1; t[r] = e } return t }(); t.exports = function (e, t, r, n) { var i = o, s = n + r; e ^= -1; for (var a = n; a < s; a++)e = e >>> 8 ^ i[255 & (e ^ t[a])]; return -1 ^ e } }, {}], 46: [function (e, t, r) { "use strict"; var h, c = e("../utils/common"), u = e("./trees"), d = e("./adler32"), p = e("./crc32"), n = e("./messages"), l = 0, f = 4, m = 0, _ = -2, g = -1, b = 4, i = 2, v = 8, y = 9, s = 286, a = 30, o = 19, w = 2 * s + 1, k = 15, x = 3, S = 258, z = S + x + 1, C = 42, E = 113, A = 1, I = 2, O = 3, B = 4; function R(e, t) { return e.msg = n[t], t } function T(e) { return (e << 1) - (4 < e ? 9 : 0) } function D(e) { for (var t = e.length; 0 <= --t;)e[t] = 0 } function F(e) { var t = e.state, r = t.pending; r > e.avail_out && (r = e.avail_out), 0 !== r && (c.arraySet(e.output, t.pending_buf, t.pending_out, r, e.next_out), e.next_out += r, t.pending_out += r, e.total_out += r, e.avail_out -= r, t.pending -= r, 0 === t.pending && (t.pending_out = 0)) } function N(e, t) { u._tr_flush_block(e, 0 <= e.block_start ? e.block_start : -1, e.strstart - e.block_start, t), e.block_start = e.strstart, F(e.strm) } function U(e, t) { e.pending_buf[e.pending++] = t } function P(e, t) { e.pending_buf[e.pending++] = t >>> 8 & 255, e.pending_buf[e.pending++] = 255 & t } function L(e, t) { var r, n, i = e.max_chain_length, s = e.strstart, a = e.prev_length, o = e.nice_match, h = e.strstart > e.w_size - z ? e.strstart - (e.w_size - z) : 0, u = e.window, l = e.w_mask, f = e.prev, c = e.strstart + S, d = u[s + a - 1], p = u[s + a]; e.prev_length >= e.good_match && (i >>= 2), o > e.lookahead && (o = e.lookahead); do { if (u[(r = t) + a] === p && u[r + a - 1] === d && u[r] === u[s] && u[++r] === u[s + 1]) { s += 2, r++; do { } while (u[++s] === u[++r] && u[++s] === u[++r] && u[++s] === u[++r] && u[++s] === u[++r] && u[++s] === u[++r] && u[++s] === u[++r] && u[++s] === u[++r] && u[++s] === u[++r] && s < c); if (n = S - (c - s), s = c - S, a < n) { if (e.match_start = t, o <= (a = n)) break; d = u[s + a - 1], p = u[s + a] } } } while ((t = f[t & l]) > h && 0 != --i); return a <= e.lookahead ? a : e.lookahead } function j(e) { var t, r, n, i, s, a, o, h, u, l, f = e.w_size; do { if (i = e.window_size - e.lookahead - e.strstart, e.strstart >= f + (f - z)) { for (c.arraySet(e.window, e.window, f, f, 0), e.match_start -= f, e.strstart -= f, e.block_start -= f, t = r = e.hash_size; n = e.head[--t], e.head[t] = f <= n ? n - f : 0, --r;); for (t = r = f; n = e.prev[--t], e.prev[t] = f <= n ? n - f : 0, --r;); i += f } if (0 === e.strm.avail_in) break; if (a = e.strm, o = e.window, h = e.strstart + e.lookahead, u = i, l = void 0, l = a.avail_in, u < l && (l = u), r = 0 === l ? 0 : (a.avail_in -= l, c.arraySet(o, a.input, a.next_in, l, h), 1 === a.state.wrap ? a.adler = d(a.adler, o, l, h) : 2 === a.state.wrap && (a.adler = p(a.adler, o, l, h)), a.next_in += l, a.total_in += l, l), e.lookahead += r, e.lookahead + e.insert >= x) for (s = e.strstart - e.insert, e.ins_h = e.window[s], e.ins_h = (e.ins_h << e.hash_shift ^ e.window[s + 1]) & e.hash_mask; e.insert && (e.ins_h = (e.ins_h << e.hash_shift ^ e.window[s + x - 1]) & e.hash_mask, e.prev[s & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = s, s++, e.insert--, !(e.lookahead + e.insert < x));); } while (e.lookahead < z && 0 !== e.strm.avail_in) } function Z(e, t) { for (var r, n; ;) { if (e.lookahead < z) { if (j(e), e.lookahead < z && t === l) return A; if (0 === e.lookahead) break } if (r = 0, e.lookahead >= x && (e.ins_h = (e.ins_h << e.hash_shift ^ e.window[e.strstart + x - 1]) & e.hash_mask, r = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart), 0 !== r && e.strstart - r <= e.w_size - z && (e.match_length = L(e, r)), e.match_length >= x) if (n = u._tr_tally(e, e.strstart - e.match_start, e.match_length - x), e.lookahead -= e.match_length, e.match_length <= e.max_lazy_match && e.lookahead >= x) { for (e.match_length--; e.strstart++, e.ins_h = (e.ins_h << e.hash_shift ^ e.window[e.strstart + x - 1]) & e.hash_mask, r = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart, 0 != --e.match_length;); e.strstart++ } else e.strstart += e.match_length, e.match_length = 0, e.ins_h = e.window[e.strstart], e.ins_h = (e.ins_h << e.hash_shift ^ e.window[e.strstart + 1]) & e.hash_mask; else n = u._tr_tally(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++; if (n && (N(e, !1), 0 === e.strm.avail_out)) return A } return e.insert = e.strstart < x - 1 ? e.strstart : x - 1, t === f ? (N(e, !0), 0 === e.strm.avail_out ? O : B) : e.last_lit && (N(e, !1), 0 === e.strm.avail_out) ? A : I } function W(e, t) { for (var r, n, i; ;) { if (e.lookahead < z) { if (j(e), e.lookahead < z && t === l) return A; if (0 === e.lookahead) break } if (r = 0, e.lookahead >= x && (e.ins_h = (e.ins_h << e.hash_shift ^ e.window[e.strstart + x - 1]) & e.hash_mask, r = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart), e.prev_length = e.match_length, e.prev_match = e.match_start, e.match_length = x - 1, 0 !== r && e.prev_length < e.max_lazy_match && e.strstart - r <= e.w_size - z && (e.match_length = L(e, r), e.match_length <= 5 && (1 === e.strategy || e.match_length === x && 4096 < e.strstart - e.match_start) && (e.match_length = x - 1)), e.prev_length >= x && e.match_length <= e.prev_length) { for (i = e.strstart + e.lookahead - x, n = u._tr_tally(e, e.strstart - 1 - e.prev_match, e.prev_length - x), e.lookahead -= e.prev_length - 1, e.prev_length -= 2; ++e.strstart <= i && (e.ins_h = (e.ins_h << e.hash_shift ^ e.window[e.strstart + x - 1]) & e.hash_mask, r = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart), 0 != --e.prev_length;); if (e.match_available = 0, e.match_length = x - 1, e.strstart++, n && (N(e, !1), 0 === e.strm.avail_out)) return A } else if (e.match_available) { if ((n = u._tr_tally(e, 0, e.window[e.strstart - 1])) && N(e, !1), e.strstart++, e.lookahead--, 0 === e.strm.avail_out) return A } else e.match_available = 1, e.strstart++, e.lookahead-- } return e.match_available && (n = u._tr_tally(e, 0, e.window[e.strstart - 1]), e.match_available = 0), e.insert = e.strstart < x - 1 ? e.strstart : x - 1, t === f ? (N(e, !0), 0 === e.strm.avail_out ? O : B) : e.last_lit && (N(e, !1), 0 === e.strm.avail_out) ? A : I } function M(e, t, r, n, i) { this.good_length = e, this.max_lazy = t, this.nice_length = r, this.max_chain = n, this.func = i } function H() { this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = v, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new c.Buf16(2 * w), this.dyn_dtree = new c.Buf16(2 * (2 * a + 1)), this.bl_tree = new c.Buf16(2 * (2 * o + 1)), D(this.dyn_ltree), D(this.dyn_dtree), D(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new c.Buf16(k + 1), this.heap = new c.Buf16(2 * s + 1), D(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new c.Buf16(2 * s + 1), D(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0 } function G(e) { var t; return e && e.state ? (e.total_in = e.total_out = 0, e.data_type = i, (t = e.state).pending = 0, t.pending_out = 0, t.wrap < 0 && (t.wrap = -t.wrap), t.status = t.wrap ? C : E, e.adler = 2 === t.wrap ? 0 : 1, t.last_flush = l, u._tr_init(t), m) : R(e, _) } function K(e) { var t = G(e); return t === m && function (e) { e.window_size = 2 * e.w_size, D(e.head), e.max_lazy_match = h[e.level].max_lazy, e.good_match = h[e.level].good_length, e.nice_match = h[e.level].nice_length, e.max_chain_length = h[e.level].max_chain, e.strstart = 0, e.block_start = 0, e.lookahead = 0, e.insert = 0, e.match_length = e.prev_length = x - 1, e.match_available = 0, e.ins_h = 0 }(e.state), t } function Y(e, t, r, n, i, s) { if (!e) return _; var a = 1; if (t === g && (t = 6), n < 0 ? (a = 0, n = -n) : 15 < n && (a = 2, n -= 16), i < 1 || y < i || r !== v || n < 8 || 15 < n || t < 0 || 9 < t || s < 0 || b < s) return R(e, _); 8 === n && (n = 9); var o = new H; return (e.state = o).strm = e, o.wrap = a, o.gzhead = null, o.w_bits = n, o.w_size = 1 << o.w_bits, o.w_mask = o.w_size - 1, o.hash_bits = i + 7, o.hash_size = 1 << o.hash_bits, o.hash_mask = o.hash_size - 1, o.hash_shift = ~~((o.hash_bits + x - 1) / x), o.window = new c.Buf8(2 * o.w_size), o.head = new c.Buf16(o.hash_size), o.prev = new c.Buf16(o.w_size), o.lit_bufsize = 1 << i + 6, o.pending_buf_size = 4 * o.lit_bufsize, o.pending_buf = new c.Buf8(o.pending_buf_size), o.d_buf = 1 * o.lit_bufsize, o.l_buf = 3 * o.lit_bufsize, o.level = t, o.strategy = s, o.method = r, K(e) } h = [new M(0, 0, 0, 0, function (e, t) { var r = 65535; for (r > e.pending_buf_size - 5 && (r = e.pending_buf_size - 5); ;) { if (e.lookahead <= 1) { if (j(e), 0 === e.lookahead && t === l) return A; if (0 === e.lookahead) break } e.strstart += e.lookahead, e.lookahead = 0; var n = e.block_start + r; if ((0 === e.strstart || e.strstart >= n) && (e.lookahead = e.strstart - n, e.strstart = n, N(e, !1), 0 === e.strm.avail_out)) return A; if (e.strstart - e.block_start >= e.w_size - z && (N(e, !1), 0 === e.strm.avail_out)) return A } return e.insert = 0, t === f ? (N(e, !0), 0 === e.strm.avail_out ? O : B) : (e.strstart > e.block_start && (N(e, !1), e.strm.avail_out), A) }), new M(4, 4, 8, 4, Z), new M(4, 5, 16, 8, Z), new M(4, 6, 32, 32, Z), new M(4, 4, 16, 16, W), new M(8, 16, 32, 32, W), new M(8, 16, 128, 128, W), new M(8, 32, 128, 256, W), new M(32, 128, 258, 1024, W), new M(32, 258, 258, 4096, W)], r.deflateInit = function (e, t) { return Y(e, t, v, 15, 8, 0) }, r.deflateInit2 = Y, r.deflateReset = K, r.deflateResetKeep = G, r.deflateSetHeader = function (e, t) { return e && e.state ? 2 !== e.state.wrap ? _ : (e.state.gzhead = t, m) : _ }, r.deflate = function (e, t) { var r, n, i, s; if (!e || !e.state || 5 < t || t < 0) return e ? R(e, _) : _; if (n = e.state, !e.output || !e.input && 0 !== e.avail_in || 666 === n.status && t !== f) return R(e, 0 === e.avail_out ? -5 : _); if (n.strm = e, r = n.last_flush, n.last_flush = t, n.status === C) if (2 === n.wrap) e.adler = 0, U(n, 31), U(n, 139), U(n, 8), n.gzhead ? (U(n, (n.gzhead.text ? 1 : 0) + (n.gzhead.hcrc ? 2 : 0) + (n.gzhead.extra ? 4 : 0) + (n.gzhead.name ? 8 : 0) + (n.gzhead.comment ? 16 : 0)), U(n, 255 & n.gzhead.time), U(n, n.gzhead.time >> 8 & 255), U(n, n.gzhead.time >> 16 & 255), U(n, n.gzhead.time >> 24 & 255), U(n, 9 === n.level ? 2 : 2 <= n.strategy || n.level < 2 ? 4 : 0), U(n, 255 & n.gzhead.os), n.gzhead.extra && n.gzhead.extra.length && (U(n, 255 & n.gzhead.extra.length), U(n, n.gzhead.extra.length >> 8 & 255)), n.gzhead.hcrc && (e.adler = p(e.adler, n.pending_buf, n.pending, 0)), n.gzindex = 0, n.status = 69) : (U(n, 0), U(n, 0), U(n, 0), U(n, 0), U(n, 0), U(n, 9 === n.level ? 2 : 2 <= n.strategy || n.level < 2 ? 4 : 0), U(n, 3), n.status = E); else { var a = v + (n.w_bits - 8 << 4) << 8; a |= (2 <= n.strategy || n.level < 2 ? 0 : n.level < 6 ? 1 : 6 === n.level ? 2 : 3) << 6, 0 !== n.strstart && (a |= 32), a += 31 - a % 31, n.status = E, P(n, a), 0 !== n.strstart && (P(n, e.adler >>> 16), P(n, 65535 & e.adler)), e.adler = 1 } if (69 === n.status) if (n.gzhead.extra) { for (i = n.pending; n.gzindex < (65535 & n.gzhead.extra.length) && (n.pending !== n.pending_buf_size || (n.gzhead.hcrc && n.pending > i && (e.adler = p(e.adler, n.pending_buf, n.pending - i, i)), F(e), i = n.pending, n.pending !== n.pending_buf_size));)U(n, 255 & n.gzhead.extra[n.gzindex]), n.gzindex++; n.gzhead.hcrc && n.pending > i && (e.adler = p(e.adler, n.pending_buf, n.pending - i, i)), n.gzindex === n.gzhead.extra.length && (n.gzindex = 0, n.status = 73) } else n.status = 73; if (73 === n.status) if (n.gzhead.name) { i = n.pending; do { if (n.pending === n.pending_buf_size && (n.gzhead.hcrc && n.pending > i && (e.adler = p(e.adler, n.pending_buf, n.pending - i, i)), F(e), i = n.pending, n.pending === n.pending_buf_size)) { s = 1; break } s = n.gzindex < n.gzhead.name.length ? 255 & n.gzhead.name.charCodeAt(n.gzindex++) : 0, U(n, s) } while (0 !== s); n.gzhead.hcrc && n.pending > i && (e.adler = p(e.adler, n.pending_buf, n.pending - i, i)), 0 === s && (n.gzindex = 0, n.status = 91) } else n.status = 91; if (91 === n.status) if (n.gzhead.comment) { i = n.pending; do { if (n.pending === n.pending_buf_size && (n.gzhead.hcrc && n.pending > i && (e.adler = p(e.adler, n.pending_buf, n.pending - i, i)), F(e), i = n.pending, n.pending === n.pending_buf_size)) { s = 1; break } s = n.gzindex < n.gzhead.comment.length ? 255 & n.gzhead.comment.charCodeAt(n.gzindex++) : 0, U(n, s) } while (0 !== s); n.gzhead.hcrc && n.pending > i && (e.adler = p(e.adler, n.pending_buf, n.pending - i, i)), 0 === s && (n.status = 103) } else n.status = 103; if (103 === n.status && (n.gzhead.hcrc ? (n.pending + 2 > n.pending_buf_size && F(e), n.pending + 2 <= n.pending_buf_size && (U(n, 255 & e.adler), U(n, e.adler >> 8 & 255), e.adler = 0, n.status = E)) : n.status = E), 0 !== n.pending) { if (F(e), 0 === e.avail_out) return n.last_flush = -1, m } else if (0 === e.avail_in && T(t) <= T(r) && t !== f) return R(e, -5); if (666 === n.status && 0 !== e.avail_in) return R(e, -5); if (0 !== e.avail_in || 0 !== n.lookahead || t !== l && 666 !== n.status) { var o = 2 === n.strategy ? function (e, t) { for (var r; ;) { if (0 === e.lookahead && (j(e), 0 === e.lookahead)) { if (t === l) return A; break } if (e.match_length = 0, r = u._tr_tally(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++, r && (N(e, !1), 0 === e.strm.avail_out)) return A } return e.insert = 0, t === f ? (N(e, !0), 0 === e.strm.avail_out ? O : B) : e.last_lit && (N(e, !1), 0 === e.strm.avail_out) ? A : I }(n, t) : 3 === n.strategy ? function (e, t) { for (var r, n, i, s, a = e.window; ;) { if (e.lookahead <= S) { if (j(e), e.lookahead <= S && t === l) return A; if (0 === e.lookahead) break } if (e.match_length = 0, e.lookahead >= x && 0 < e.strstart && (n = a[i = e.strstart - 1]) === a[++i] && n === a[++i] && n === a[++i]) { s = e.strstart + S; do { } while (n === a[++i] && n === a[++i] && n === a[++i] && n === a[++i] && n === a[++i] && n === a[++i] && n === a[++i] && n === a[++i] && i < s); e.match_length = S - (s - i), e.match_length > e.lookahead && (e.match_length = e.lookahead) } if (e.match_length >= x ? (r = u._tr_tally(e, 1, e.match_length - x), e.lookahead -= e.match_length, e.strstart += e.match_length, e.match_length = 0) : (r = u._tr_tally(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++), r && (N(e, !1), 0 === e.strm.avail_out)) return A } return e.insert = 0, t === f ? (N(e, !0), 0 === e.strm.avail_out ? O : B) : e.last_lit && (N(e, !1), 0 === e.strm.avail_out) ? A : I }(n, t) : h[n.level].func(n, t); if (o !== O && o !== B || (n.status = 666), o === A || o === O) return 0 === e.avail_out && (n.last_flush = -1), m; if (o === I && (1 === t ? u._tr_align(n) : 5 !== t && (u._tr_stored_block(n, 0, 0, !1), 3 === t && (D(n.head), 0 === n.lookahead && (n.strstart = 0, n.block_start = 0, n.insert = 0))), F(e), 0 === e.avail_out)) return n.last_flush = -1, m } return t !== f ? m : n.wrap <= 0 ? 1 : (2 === n.wrap ? (U(n, 255 & e.adler), U(n, e.adler >> 8 & 255), U(n, e.adler >> 16 & 255), U(n, e.adler >> 24 & 255), U(n, 255 & e.total_in), U(n, e.total_in >> 8 & 255), U(n, e.total_in >> 16 & 255), U(n, e.total_in >> 24 & 255)) : (P(n, e.adler >>> 16), P(n, 65535 & e.adler)), F(e), 0 < n.wrap && (n.wrap = -n.wrap), 0 !== n.pending ? m : 1) }, r.deflateEnd = function (e) { var t; return e && e.state ? (t = e.state.status) !== C && 69 !== t && 73 !== t && 91 !== t && 103 !== t && t !== E && 666 !== t ? R(e, _) : (e.state = null, t === E ? R(e, -3) : m) : _ }, r.deflateSetDictionary = function (e, t) { var r, n, i, s, a, o, h, u, l = t.length; if (!e || !e.state) return _; if (2 === (s = (r = e.state).wrap) || 1 === s && r.status !== C || r.lookahead) return _; for (1 === s && (e.adler = d(e.adler, t, l, 0)), r.wrap = 0, l >= r.w_size && (0 === s && (D(r.head), r.strstart = 0, r.block_start = 0, r.insert = 0), u = new c.Buf8(r.w_size), c.arraySet(u, t, l - r.w_size, r.w_size, 0), t = u, l = r.w_size), a = e.avail_in, o = e.next_in, h = e.input, e.avail_in = l, e.next_in = 0, e.input = t, j(r); r.lookahead >= x;) { for (n = r.strstart, i = r.lookahead - (x - 1); r.ins_h = (r.ins_h << r.hash_shift ^ r.window[n + x - 1]) & r.hash_mask, r.prev[n & r.w_mask] = r.head[r.ins_h], r.head[r.ins_h] = n, n++, --i;); r.strstart = n, r.lookahead = x - 1, j(r) } return r.strstart += r.lookahead, r.block_start = r.strstart, r.insert = r.lookahead, r.lookahead = 0, r.match_length = r.prev_length = x - 1, r.match_available = 0, e.next_in = o, e.input = h, e.avail_in = a, r.wrap = s, m }, r.deflateInfo = "pako deflate (from Nodeca project)" }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function (e, t, r) { "use strict"; t.exports = function () { this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1 } }, {}], 48: [function (e, t, r) { "use strict"; t.exports = function (e, t) { var r, n, i, s, a, o, h, u, l, f, c, d, p, m, _, g, b, v, y, w, k, x, S, z, C; r = e.state, n = e.next_in, z = e.input, i = n + (e.avail_in - 5), s = e.next_out, C = e.output, a = s - (t - e.avail_out), o = s + (e.avail_out - 257), h = r.dmax, u = r.wsize, l = r.whave, f = r.wnext, c = r.window, d = r.hold, p = r.bits, m = r.lencode, _ = r.distcode, g = (1 << r.lenbits) - 1, b = (1 << r.distbits) - 1; e: do { p < 15 && (d += z[n++] << p, p += 8, d += z[n++] << p, p += 8), v = m[d & g]; t: for (; ;) { if (d >>>= y = v >>> 24, p -= y, 0 === (y = v >>> 16 & 255)) C[s++] = 65535 & v; else { if (!(16 & y)) { if (0 == (64 & y)) { v = m[(65535 & v) + (d & (1 << y) - 1)]; continue t } if (32 & y) { r.mode = 12; break e } e.msg = "invalid literal/length code", r.mode = 30; break e } w = 65535 & v, (y &= 15) && (p < y && (d += z[n++] << p, p += 8), w += d & (1 << y) - 1, d >>>= y, p -= y), p < 15 && (d += z[n++] << p, p += 8, d += z[n++] << p, p += 8), v = _[d & b]; r: for (; ;) { if (d >>>= y = v >>> 24, p -= y, !(16 & (y = v >>> 16 & 255))) { if (0 == (64 & y)) { v = _[(65535 & v) + (d & (1 << y) - 1)]; continue r } e.msg = "invalid distance code", r.mode = 30; break e } if (k = 65535 & v, p < (y &= 15) && (d += z[n++] << p, (p += 8) < y && (d += z[n++] << p, p += 8)), h < (k += d & (1 << y) - 1)) { e.msg = "invalid distance too far back", r.mode = 30; break e } if (d >>>= y, p -= y, (y = s - a) < k) { if (l < (y = k - y) && r.sane) { e.msg = "invalid distance too far back", r.mode = 30; break e } if (S = c, (x = 0) === f) { if (x += u - y, y < w) { for (w -= y; C[s++] = c[x++], --y;); x = s - k, S = C } } else if (f < y) { if (x += u + f - y, (y -= f) < w) { for (w -= y; C[s++] = c[x++], --y;); if (x = 0, f < w) { for (w -= y = f; C[s++] = c[x++], --y;); x = s - k, S = C } } } else if (x += f - y, y < w) { for (w -= y; C[s++] = c[x++], --y;); x = s - k, S = C } for (; 2 < w;)C[s++] = S[x++], C[s++] = S[x++], C[s++] = S[x++], w -= 3; w && (C[s++] = S[x++], 1 < w && (C[s++] = S[x++])) } else { for (x = s - k; C[s++] = C[x++], C[s++] = C[x++], C[s++] = C[x++], 2 < (w -= 3);); w && (C[s++] = C[x++], 1 < w && (C[s++] = C[x++])) } break } } break } } while (n < i && s < o); n -= w = p >> 3, d &= (1 << (p -= w << 3)) - 1, e.next_in = n, e.next_out = s, e.avail_in = n < i ? i - n + 5 : 5 - (n - i), e.avail_out = s < o ? o - s + 257 : 257 - (s - o), r.hold = d, r.bits = p } }, {}], 49: [function (e, t, r) { "use strict"; var I = e("../utils/common"), O = e("./adler32"), B = e("./crc32"), R = e("./inffast"), T = e("./inftrees"), D = 1, F = 2, N = 0, U = -2, P = 1, n = 852, i = 592; function L(e) { return (e >>> 24 & 255) + (e >>> 8 & 65280) + ((65280 & e) << 8) + ((255 & e) << 24) } function s() { this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new I.Buf16(320), this.work = new I.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0 } function a(e) { var t; return e && e.state ? (t = e.state, e.total_in = e.total_out = t.total = 0, e.msg = "", t.wrap && (e.adler = 1 & t.wrap), t.mode = P, t.last = 0, t.havedict = 0, t.dmax = 32768, t.head = null, t.hold = 0, t.bits = 0, t.lencode = t.lendyn = new I.Buf32(n), t.distcode = t.distdyn = new I.Buf32(i), t.sane = 1, t.back = -1, N) : U } function o(e) { var t; return e && e.state ? ((t = e.state).wsize = 0, t.whave = 0, t.wnext = 0, a(e)) : U } function h(e, t) { var r, n; return e && e.state ? (n = e.state, t < 0 ? (r = 0, t = -t) : (r = 1 + (t >> 4), t < 48 && (t &= 15)), t && (t < 8 || 15 < t) ? U : (null !== n.window && n.wbits !== t && (n.window = null), n.wrap = r, n.wbits = t, o(e))) : U } function u(e, t) { var r, n; return e ? (n = new s, (e.state = n).window = null, (r = h(e, t)) !== N && (e.state = null), r) : U } var l, f, c = !0; function j(e) { if (c) { var t; for (l = new I.Buf32(512), f = new I.Buf32(32), t = 0; t < 144;)e.lens[t++] = 8; for (; t < 256;)e.lens[t++] = 9; for (; t < 280;)e.lens[t++] = 7; for (; t < 288;)e.lens[t++] = 8; for (T(D, e.lens, 0, 288, l, 0, e.work, { bits: 9 }), t = 0; t < 32;)e.lens[t++] = 5; T(F, e.lens, 0, 32, f, 0, e.work, { bits: 5 }), c = !1 } e.lencode = l, e.lenbits = 9, e.distcode = f, e.distbits = 5 } function Z(e, t, r, n) { var i, s = e.state; return null === s.window && (s.wsize = 1 << s.wbits, s.wnext = 0, s.whave = 0, s.window = new I.Buf8(s.wsize)), n >= s.wsize ? (I.arraySet(s.window, t, r - s.wsize, s.wsize, 0), s.wnext = 0, s.whave = s.wsize) : (n < (i = s.wsize - s.wnext) && (i = n), I.arraySet(s.window, t, r - n, i, s.wnext), (n -= i) ? (I.arraySet(s.window, t, r - n, n, 0), s.wnext = n, s.whave = s.wsize) : (s.wnext += i, s.wnext === s.wsize && (s.wnext = 0), s.whave < s.wsize && (s.whave += i))), 0 } r.inflateReset = o, r.inflateReset2 = h, r.inflateResetKeep = a, r.inflateInit = function (e) { return u(e, 15) }, r.inflateInit2 = u, r.inflate = function (e, t) { var r, n, i, s, a, o, h, u, l, f, c, d, p, m, _, g, b, v, y, w, k, x, S, z, C = 0, E = new I.Buf8(4), A = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]; if (!e || !e.state || !e.output || !e.input && 0 !== e.avail_in) return U; 12 === (r = e.state).mode && (r.mode = 13), a = e.next_out, i = e.output, h = e.avail_out, s = e.next_in, n = e.input, o = e.avail_in, u = r.hold, l = r.bits, f = o, c = h, x = N; e: for (; ;)switch (r.mode) { case P: if (0 === r.wrap) { r.mode = 13; break } for (; l < 16;) { if (0 === o) break e; o--, u += n[s++] << l, l += 8 } if (2 & r.wrap && 35615 === u) { E[r.check = 0] = 255 & u, E[1] = u >>> 8 & 255, r.check = B(r.check, E, 2, 0), l = u = 0, r.mode = 2; break } if (r.flags = 0, r.head && (r.head.done = !1), !(1 & r.wrap) || (((255 & u) << 8) + (u >> 8)) % 31) { e.msg = "incorrect header check", r.mode = 30; break } if (8 != (15 & u)) { e.msg = "unknown compression method", r.mode = 30; break } if (l -= 4, k = 8 + (15 & (u >>>= 4)), 0 === r.wbits) r.wbits = k; else if (k > r.wbits) { e.msg = "invalid window size", r.mode = 30; break } r.dmax = 1 << k, e.adler = r.check = 1, r.mode = 512 & u ? 10 : 12, l = u = 0; break; case 2: for (; l < 16;) { if (0 === o) break e; o--, u += n[s++] << l, l += 8 } if (r.flags = u, 8 != (255 & r.flags)) { e.msg = "unknown compression method", r.mode = 30; break } if (57344 & r.flags) { e.msg = "unknown header flags set", r.mode = 30; break } r.head && (r.head.text = u >> 8 & 1), 512 & r.flags && (E[0] = 255 & u, E[1] = u >>> 8 & 255, r.check = B(r.check, E, 2, 0)), l = u = 0, r.mode = 3; case 3: for (; l < 32;) { if (0 === o) break e; o--, u += n[s++] << l, l += 8 } r.head && (r.head.time = u), 512 & r.flags && (E[0] = 255 & u, E[1] = u >>> 8 & 255, E[2] = u >>> 16 & 255, E[3] = u >>> 24 & 255, r.check = B(r.check, E, 4, 0)), l = u = 0, r.mode = 4; case 4: for (; l < 16;) { if (0 === o) break e; o--, u += n[s++] << l, l += 8 } r.head && (r.head.xflags = 255 & u, r.head.os = u >> 8), 512 & r.flags && (E[0] = 255 & u, E[1] = u >>> 8 & 255, r.check = B(r.check, E, 2, 0)), l = u = 0, r.mode = 5; case 5: if (1024 & r.flags) { for (; l < 16;) { if (0 === o) break e; o--, u += n[s++] << l, l += 8 } r.length = u, r.head && (r.head.extra_len = u), 512 & r.flags && (E[0] = 255 & u, E[1] = u >>> 8 & 255, r.check = B(r.check, E, 2, 0)), l = u = 0 } else r.head && (r.head.extra = null); r.mode = 6; case 6: if (1024 & r.flags && (o < (d = r.length) && (d = o), d && (r.head && (k = r.head.extra_len - r.length, r.head.extra || (r.head.extra = new Array(r.head.extra_len)), I.arraySet(r.head.extra, n, s, d, k)), 512 & r.flags && (r.check = B(r.check, n, d, s)), o -= d, s += d, r.length -= d), r.length)) break e; r.length = 0, r.mode = 7; case 7: if (2048 & r.flags) { if (0 === o) break e; for (d = 0; k = n[s + d++], r.head && k && r.length < 65536 && (r.head.name += String.fromCharCode(k)), k && d < o;); if (512 & r.flags && (r.check = B(r.check, n, d, s)), o -= d, s += d, k) break e } else r.head && (r.head.name = null); r.length = 0, r.mode = 8; case 8: if (4096 & r.flags) { if (0 === o) break e; for (d = 0; k = n[s + d++], r.head && k && r.length < 65536 && (r.head.comment += String.fromCharCode(k)), k && d < o;); if (512 & r.flags && (r.check = B(r.check, n, d, s)), o -= d, s += d, k) break e } else r.head && (r.head.comment = null); r.mode = 9; case 9: if (512 & r.flags) { for (; l < 16;) { if (0 === o) break e; o--, u += n[s++] << l, l += 8 } if (u !== (65535 & r.check)) { e.msg = "header crc mismatch", r.mode = 30; break } l = u = 0 } r.head && (r.head.hcrc = r.flags >> 9 & 1, r.head.done = !0), e.adler = r.check = 0, r.mode = 12; break; case 10: for (; l < 32;) { if (0 === o) break e; o--, u += n[s++] << l, l += 8 } e.adler = r.check = L(u), l = u = 0, r.mode = 11; case 11: if (0 === r.havedict) return e.next_out = a, e.avail_out = h, e.next_in = s, e.avail_in = o, r.hold = u, r.bits = l, 2; e.adler = r.check = 1, r.mode = 12; case 12: if (5 === t || 6 === t) break e; case 13: if (r.last) { u >>>= 7 & l, l -= 7 & l, r.mode = 27; break } for (; l < 3;) { if (0 === o) break e; o--, u += n[s++] << l, l += 8 } switch (r.last = 1 & u, l -= 1, 3 & (u >>>= 1)) { case 0: r.mode = 14; break; case 1: if (j(r), r.mode = 20, 6 !== t) break; u >>>= 2, l -= 2; break e; case 2: r.mode = 17; break; case 3: e.msg = "invalid block type", r.mode = 30 }u >>>= 2, l -= 2; break; case 14: for (u >>>= 7 & l, l -= 7 & l; l < 32;) { if (0 === o) break e; o--, u += n[s++] << l, l += 8 } if ((65535 & u) != (u >>> 16 ^ 65535)) { e.msg = "invalid stored block lengths", r.mode = 30; break } if (r.length = 65535 & u, l = u = 0, r.mode = 15, 6 === t) break e; case 15: r.mode = 16; case 16: if (d = r.length) { if (o < d && (d = o), h < d && (d = h), 0 === d) break e; I.arraySet(i, n, s, d, a), o -= d, s += d, h -= d, a += d, r.length -= d; break } r.mode = 12; break; case 17: for (; l < 14;) { if (0 === o) break e; o--, u += n[s++] << l, l += 8 } if (r.nlen = 257 + (31 & u), u >>>= 5, l -= 5, r.ndist = 1 + (31 & u), u >>>= 5, l -= 5, r.ncode = 4 + (15 & u), u >>>= 4, l -= 4, 286 < r.nlen || 30 < r.ndist) { e.msg = "too many length or distance symbols", r.mode = 30; break } r.have = 0, r.mode = 18; case 18: for (; r.have < r.ncode;) { for (; l < 3;) { if (0 === o) break e; o--, u += n[s++] << l, l += 8 } r.lens[A[r.have++]] = 7 & u, u >>>= 3, l -= 3 } for (; r.have < 19;)r.lens[A[r.have++]] = 0; if (r.lencode = r.lendyn, r.lenbits = 7, S = { bits: r.lenbits }, x = T(0, r.lens, 0, 19, r.lencode, 0, r.work, S), r.lenbits = S.bits, x) { e.msg = "invalid code lengths set", r.mode = 30; break } r.have = 0, r.mode = 19; case 19: for (; r.have < r.nlen + r.ndist;) { for (; g = (C = r.lencode[u & (1 << r.lenbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l);) { if (0 === o) break e; o--, u += n[s++] << l, l += 8 } if (b < 16) u >>>= _, l -= _, r.lens[r.have++] = b; else { if (16 === b) { for (z = _ + 2; l < z;) { if (0 === o) break e; o--, u += n[s++] << l, l += 8 } if (u >>>= _, l -= _, 0 === r.have) { e.msg = "invalid bit length repeat", r.mode = 30; break } k = r.lens[r.have - 1], d = 3 + (3 & u), u >>>= 2, l -= 2 } else if (17 === b) { for (z = _ + 3; l < z;) { if (0 === o) break e; o--, u += n[s++] << l, l += 8 } l -= _, k = 0, d = 3 + (7 & (u >>>= _)), u >>>= 3, l -= 3 } else { for (z = _ + 7; l < z;) { if (0 === o) break e; o--, u += n[s++] << l, l += 8 } l -= _, k = 0, d = 11 + (127 & (u >>>= _)), u >>>= 7, l -= 7 } if (r.have + d > r.nlen + r.ndist) { e.msg = "invalid bit length repeat", r.mode = 30; break } for (; d--;)r.lens[r.have++] = k } } if (30 === r.mode) break; if (0 === r.lens[256]) { e.msg = "invalid code -- missing end-of-block", r.mode = 30; break } if (r.lenbits = 9, S = { bits: r.lenbits }, x = T(D, r.lens, 0, r.nlen, r.lencode, 0, r.work, S), r.lenbits = S.bits, x) { e.msg = "invalid literal/lengths set", r.mode = 30; break } if (r.distbits = 6, r.distcode = r.distdyn, S = { bits: r.distbits }, x = T(F, r.lens, r.nlen, r.ndist, r.distcode, 0, r.work, S), r.distbits = S.bits, x) { e.msg = "invalid distances set", r.mode = 30; break } if (r.mode = 20, 6 === t) break e; case 20: r.mode = 21; case 21: if (6 <= o && 258 <= h) { e.next_out = a, e.avail_out = h, e.next_in = s, e.avail_in = o, r.hold = u, r.bits = l, R(e, c), a = e.next_out, i = e.output, h = e.avail_out, s = e.next_in, n = e.input, o = e.avail_in, u = r.hold, l = r.bits, 12 === r.mode && (r.back = -1); break } for (r.back = 0; g = (C = r.lencode[u & (1 << r.lenbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l);) { if (0 === o) break e; o--, u += n[s++] << l, l += 8 } if (g && 0 == (240 & g)) { for (v = _, y = g, w = b; g = (C = r.lencode[w + ((u & (1 << v + y) - 1) >> v)]) >>> 16 & 255, b = 65535 & C, !(v + (_ = C >>> 24) <= l);) { if (0 === o) break e; o--, u += n[s++] << l, l += 8 } u >>>= v, l -= v, r.back += v } if (u >>>= _, l -= _, r.back += _, r.length = b, 0 === g) { r.mode = 26; break } if (32 & g) { r.back = -1, r.mode = 12; break } if (64 & g) { e.msg = "invalid literal/length code", r.mode = 30; break } r.extra = 15 & g, r.mode = 22; case 22: if (r.extra) { for (z = r.extra; l < z;) { if (0 === o) break e; o--, u += n[s++] << l, l += 8 } r.length += u & (1 << r.extra) - 1, u >>>= r.extra, l -= r.extra, r.back += r.extra } r.was = r.length, r.mode = 23; case 23: for (; g = (C = r.distcode[u & (1 << r.distbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l);) { if (0 === o) break e; o--, u += n[s++] << l, l += 8 } if (0 == (240 & g)) { for (v = _, y = g, w = b; g = (C = r.distcode[w + ((u & (1 << v + y) - 1) >> v)]) >>> 16 & 255, b = 65535 & C, !(v + (_ = C >>> 24) <= l);) { if (0 === o) break e; o--, u += n[s++] << l, l += 8 } u >>>= v, l -= v, r.back += v } if (u >>>= _, l -= _, r.back += _, 64 & g) { e.msg = "invalid distance code", r.mode = 30; break } r.offset = b, r.extra = 15 & g, r.mode = 24; case 24: if (r.extra) { for (z = r.extra; l < z;) { if (0 === o) break e; o--, u += n[s++] << l, l += 8 } r.offset += u & (1 << r.extra) - 1, u >>>= r.extra, l -= r.extra, r.back += r.extra } if (r.offset > r.dmax) { e.msg = "invalid distance too far back", r.mode = 30; break } r.mode = 25; case 25: if (0 === h) break e; if (d = c - h, r.offset > d) { if ((d = r.offset - d) > r.whave && r.sane) { e.msg = "invalid distance too far back", r.mode = 30; break } p = d > r.wnext ? (d -= r.wnext, r.wsize - d) : r.wnext - d, d > r.length && (d = r.length), m = r.window } else m = i, p = a - r.offset, d = r.length; for (h < d && (d = h), h -= d, r.length -= d; i[a++] = m[p++], --d;); 0 === r.length && (r.mode = 21); break; case 26: if (0 === h) break e; i[a++] = r.length, h--, r.mode = 21; break; case 27: if (r.wrap) { for (; l < 32;) { if (0 === o) break e; o--, u |= n[s++] << l, l += 8 } if (c -= h, e.total_out += c, r.total += c, c && (e.adler = r.check = r.flags ? B(r.check, i, c, a - c) : O(r.check, i, c, a - c)), c = h, (r.flags ? u : L(u)) !== r.check) { e.msg = "incorrect data check", r.mode = 30; break } l = u = 0 } r.mode = 28; case 28: if (r.wrap && r.flags) { for (; l < 32;) { if (0 === o) break e; o--, u += n[s++] << l, l += 8 } if (u !== (4294967295 & r.total)) { e.msg = "incorrect length check", r.mode = 30; break } l = u = 0 } r.mode = 29; case 29: x = 1; break e; case 30: x = -3; break e; case 31: return -4; case 32: default: return U }return e.next_out = a, e.avail_out = h, e.next_in = s, e.avail_in = o, r.hold = u, r.bits = l, (r.wsize || c !== e.avail_out && r.mode < 30 && (r.mode < 27 || 4 !== t)) && Z(e, e.output, e.next_out, c - e.avail_out) ? (r.mode = 31, -4) : (f -= e.avail_in, c -= e.avail_out, e.total_in += f, e.total_out += c, r.total += c, r.wrap && c && (e.adler = r.check = r.flags ? B(r.check, i, c, e.next_out - c) : O(r.check, i, c, e.next_out - c)), e.data_type = r.bits + (r.last ? 64 : 0) + (12 === r.mode ? 128 : 0) + (20 === r.mode || 15 === r.mode ? 256 : 0), (0 == f && 0 === c || 4 === t) && x === N && (x = -5), x) }, r.inflateEnd = function (e) { if (!e || !e.state) return U; var t = e.state; return t.window && (t.window = null), e.state = null, N }, r.inflateGetHeader = function (e, t) { var r; return e && e.state ? 0 == (2 & (r = e.state).wrap) ? U : ((r.head = t).done = !1, N) : U }, r.inflateSetDictionary = function (e, t) { var r, n = t.length; return e && e.state ? 0 !== (r = e.state).wrap && 11 !== r.mode ? U : 11 === r.mode && O(1, t, n, 0) !== r.check ? -3 : Z(e, t, n, n) ? (r.mode = 31, -4) : (r.havedict = 1, N) : U }, r.inflateInfo = "pako inflate (from Nodeca project)" }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function (e, t, r) { "use strict"; var D = e("../utils/common"), F = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], N = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], U = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], P = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64]; t.exports = function (e, t, r, n, i, s, a, o) { var h, u, l, f, c, d, p, m, _, g = o.bits, b = 0, v = 0, y = 0, w = 0, k = 0, x = 0, S = 0, z = 0, C = 0, E = 0, A = null, I = 0, O = new D.Buf16(16), B = new D.Buf16(16), R = null, T = 0; for (b = 0; b <= 15; b++)O[b] = 0; for (v = 0; v < n; v++)O[t[r + v]]++; for (k = g, w = 15; 1 <= w && 0 === O[w]; w--); if (w < k && (k = w), 0 === w) return i[s++] = 20971520, i[s++] = 20971520, o.bits = 1, 0; for (y = 1; y < w && 0 === O[y]; y++); for (k < y && (k = y), b = z = 1; b <= 15; b++)if (z <<= 1, (z -= O[b]) < 0) return -1; if (0 < z && (0 === e || 1 !== w)) return -1; for (B[1] = 0, b = 1; b < 15; b++)B[b + 1] = B[b] + O[b]; for (v = 0; v < n; v++)0 !== t[r + v] && (a[B[t[r + v]]++] = v); if (d = 0 === e ? (A = R = a, 19) : 1 === e ? (A = F, I -= 257, R = N, T -= 257, 256) : (A = U, R = P, -1), b = y, c = s, S = v = E = 0, l = -1, f = (C = 1 << (x = k)) - 1, 1 === e && 852 < C || 2 === e && 592 < C) return 1; for (; ;) { for (p = b - S, _ = a[v] < d ? (m = 0, a[v]) : a[v] > d ? (m = R[T + a[v]], A[I + a[v]]) : (m = 96, 0), h = 1 << b - S, y = u = 1 << x; i[c + (E >> S) + (u -= h)] = p << 24 | m << 16 | _ | 0, 0 !== u;); for (h = 1 << b - 1; E & h;)h >>= 1; if (0 !== h ? (E &= h - 1, E += h) : E = 0, v++, 0 == --O[b]) { if (b === w) break; b = t[r + a[v]] } if (k < b && (E & f) !== l) { for (0 === S && (S = k), c += y, z = 1 << (x = b - S); x + S < w && !((z -= O[x + S]) <= 0);)x++, z <<= 1; if (C += 1 << x, 1 === e && 852 < C || 2 === e && 592 < C) return 1; i[l = E & f] = k << 24 | x << 16 | c - s | 0 } } return 0 !== E && (i[c + E] = b - S << 24 | 64 << 16 | 0), o.bits = k, 0 } }, { "../utils/common": 41 }], 51: [function (e, t, r) { "use strict"; t.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" } }, {}], 52: [function (e, t, r) { "use strict"; var i = e("../utils/common"), o = 0, h = 1; function n(e) { for (var t = e.length; 0 <= --t;)e[t] = 0 } var s = 0, a = 29, u = 256, l = u + 1 + a, f = 30, c = 19, _ = 2 * l + 1, g = 15, d = 16, p = 7, m = 256, b = 16, v = 17, y = 18, w = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], k = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], x = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], S = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], z = new Array(2 * (l + 2)); n(z); var C = new Array(2 * f); n(C); var E = new Array(512); n(E); var A = new Array(256); n(A); var I = new Array(a); n(I); var O, B, R, T = new Array(f); function D(e, t, r, n, i) { this.static_tree = e, this.extra_bits = t, this.extra_base = r, this.elems = n, this.max_length = i, this.has_stree = e && e.length } function F(e, t) { this.dyn_tree = e, this.max_code = 0, this.stat_desc = t } function N(e) { return e < 256 ? E[e] : E[256 + (e >>> 7)] } function U(e, t) { e.pending_buf[e.pending++] = 255 & t, e.pending_buf[e.pending++] = t >>> 8 & 255 } function P(e, t, r) { e.bi_valid > d - r ? (e.bi_buf |= t << e.bi_valid & 65535, U(e, e.bi_buf), e.bi_buf = t >> d - e.bi_valid, e.bi_valid += r - d) : (e.bi_buf |= t << e.bi_valid & 65535, e.bi_valid += r) } function L(e, t, r) { P(e, r[2 * t], r[2 * t + 1]) } function j(e, t) { for (var r = 0; r |= 1 & e, e >>>= 1, r <<= 1, 0 < --t;); return r >>> 1 } function Z(e, t, r) { var n, i, s = new Array(g + 1), a = 0; for (n = 1; n <= g; n++)s[n] = a = a + r[n - 1] << 1; for (i = 0; i <= t; i++) { var o = e[2 * i + 1]; 0 !== o && (e[2 * i] = j(s[o]++, o)) } } function W(e) { var t; for (t = 0; t < l; t++)e.dyn_ltree[2 * t] = 0; for (t = 0; t < f; t++)e.dyn_dtree[2 * t] = 0; for (t = 0; t < c; t++)e.bl_tree[2 * t] = 0; e.dyn_ltree[2 * m] = 1, e.opt_len = e.static_len = 0, e.last_lit = e.matches = 0 } function M(e) { 8 < e.bi_valid ? U(e, e.bi_buf) : 0 < e.bi_valid && (e.pending_buf[e.pending++] = e.bi_buf), e.bi_buf = 0, e.bi_valid = 0 } function H(e, t, r, n) { var i = 2 * t, s = 2 * r; return e[i] < e[s] || e[i] === e[s] && n[t] <= n[r] } function G(e, t, r) { for (var n = e.heap[r], i = r << 1; i <= e.heap_len && (i < e.heap_len && H(t, e.heap[i + 1], e.heap[i], e.depth) && i++, !H(t, n, e.heap[i], e.depth));)e.heap[r] = e.heap[i], r = i, i <<= 1; e.heap[r] = n } function K(e, t, r) { var n, i, s, a, o = 0; if (0 !== e.last_lit) for (; n = e.pending_buf[e.d_buf + 2 * o] << 8 | e.pending_buf[e.d_buf + 2 * o + 1], i = e.pending_buf[e.l_buf + o], o++, 0 === n ? L(e, i, t) : (L(e, (s = A[i]) + u + 1, t), 0 !== (a = w[s]) && P(e, i -= I[s], a), L(e, s = N(--n), r), 0 !== (a = k[s]) && P(e, n -= T[s], a)), o < e.last_lit;); L(e, m, t) } function Y(e, t) { var r, n, i, s = t.dyn_tree, a = t.stat_desc.static_tree, o = t.stat_desc.has_stree, h = t.stat_desc.elems, u = -1; for (e.heap_len = 0, e.heap_max = _, r = 0; r < h; r++)0 !== s[2 * r] ? (e.heap[++e.heap_len] = u = r, e.depth[r] = 0) : s[2 * r + 1] = 0; for (; e.heap_len < 2;)s[2 * (i = e.heap[++e.heap_len] = u < 2 ? ++u : 0)] = 1, e.depth[i] = 0, e.opt_len--, o && (e.static_len -= a[2 * i + 1]); for (t.max_code = u, r = e.heap_len >> 1; 1 <= r; r--)G(e, s, r); for (i = h; r = e.heap[1], e.heap[1] = e.heap[e.heap_len--], G(e, s, 1), n = e.heap[1], e.heap[--e.heap_max] = r, e.heap[--e.heap_max] = n, s[2 * i] = s[2 * r] + s[2 * n], e.depth[i] = (e.depth[r] >= e.depth[n] ? e.depth[r] : e.depth[n]) + 1, s[2 * r + 1] = s[2 * n + 1] = i, e.heap[1] = i++, G(e, s, 1), 2 <= e.heap_len;); e.heap[--e.heap_max] = e.heap[1], function (e, t) { var r, n, i, s, a, o, h = t.dyn_tree, u = t.max_code, l = t.stat_desc.static_tree, f = t.stat_desc.has_stree, c = t.stat_desc.extra_bits, d = t.stat_desc.extra_base, p = t.stat_desc.max_length, m = 0; for (s = 0; s <= g; s++)e.bl_count[s] = 0; for (h[2 * e.heap[e.heap_max] + 1] = 0, r = e.heap_max + 1; r < _; r++)p < (s = h[2 * h[2 * (n = e.heap[r]) + 1] + 1] + 1) && (s = p, m++), h[2 * n + 1] = s, u < n || (e.bl_count[s]++, a = 0, d <= n && (a = c[n - d]), o = h[2 * n], e.opt_len += o * (s + a), f && (e.static_len += o * (l[2 * n + 1] + a))); if (0 !== m) { do { for (s = p - 1; 0 === e.bl_count[s];)s--; e.bl_count[s]--, e.bl_count[s + 1] += 2, e.bl_count[p]--, m -= 2 } while (0 < m); for (s = p; 0 !== s; s--)for (n = e.bl_count[s]; 0 !== n;)u < (i = e.heap[--r]) || (h[2 * i + 1] !== s && (e.opt_len += (s - h[2 * i + 1]) * h[2 * i], h[2 * i + 1] = s), n--) } }(e, t), Z(s, u, e.bl_count) } function X(e, t, r) { var n, i, s = -1, a = t[1], o = 0, h = 7, u = 4; for (0 === a && (h = 138, u = 3), t[2 * (r + 1) + 1] = 65535, n = 0; n <= r; n++)i = a, a = t[2 * (n + 1) + 1], ++o < h && i === a || (o < u ? e.bl_tree[2 * i] += o : 0 !== i ? (i !== s && e.bl_tree[2 * i]++, e.bl_tree[2 * b]++) : o <= 10 ? e.bl_tree[2 * v]++ : e.bl_tree[2 * y]++, s = i, u = (o = 0) === a ? (h = 138, 3) : i === a ? (h = 6, 3) : (h = 7, 4)) } function V(e, t, r) { var n, i, s = -1, a = t[1], o = 0, h = 7, u = 4; for (0 === a && (h = 138, u = 3), n = 0; n <= r; n++)if (i = a, a = t[2 * (n + 1) + 1], !(++o < h && i === a)) { if (o < u) for (; L(e, i, e.bl_tree), 0 != --o;); else 0 !== i ? (i !== s && (L(e, i, e.bl_tree), o--), L(e, b, e.bl_tree), P(e, o - 3, 2)) : o <= 10 ? (L(e, v, e.bl_tree), P(e, o - 3, 3)) : (L(e, y, e.bl_tree), P(e, o - 11, 7)); s = i, u = (o = 0) === a ? (h = 138, 3) : i === a ? (h = 6, 3) : (h = 7, 4) } } n(T); var q = !1; function J(e, t, r, n) { P(e, (s << 1) + (n ? 1 : 0), 3), function (e, t, r, n) { M(e), n && (U(e, r), U(e, ~r)), i.arraySet(e.pending_buf, e.window, t, r, e.pending), e.pending += r }(e, t, r, !0) } r._tr_init = function (e) { q || (function () { var e, t, r, n, i, s = new Array(g + 1); for (n = r = 0; n < a - 1; n++)for (I[n] = r, e = 0; e < 1 << w[n]; e++)A[r++] = n; for (A[r - 1] = n, n = i = 0; n < 16; n++)for (T[n] = i, e = 0; e < 1 << k[n]; e++)E[i++] = n; for (i >>= 7; n < f; n++)for (T[n] = i << 7, e = 0; e < 1 << k[n] - 7; e++)E[256 + i++] = n; for (t = 0; t <= g; t++)s[t] = 0; for (e = 0; e <= 143;)z[2 * e + 1] = 8, e++, s[8]++; for (; e <= 255;)z[2 * e + 1] = 9, e++, s[9]++; for (; e <= 279;)z[2 * e + 1] = 7, e++, s[7]++; for (; e <= 287;)z[2 * e + 1] = 8, e++, s[8]++; for (Z(z, l + 1, s), e = 0; e < f; e++)C[2 * e + 1] = 5, C[2 * e] = j(e, 5); O = new D(z, w, u + 1, l, g), B = new D(C, k, 0, f, g), R = new D(new Array(0), x, 0, c, p) }(), q = !0), e.l_desc = new F(e.dyn_ltree, O), e.d_desc = new F(e.dyn_dtree, B), e.bl_desc = new F(e.bl_tree, R), e.bi_buf = 0, e.bi_valid = 0, W(e) }, r._tr_stored_block = J, r._tr_flush_block = function (e, t, r, n) { var i, s, a = 0; 0 < e.level ? (2 === e.strm.data_type && (e.strm.data_type = function (e) { var t, r = 4093624447; for (t = 0; t <= 31; t++, r >>>= 1)if (1 & r && 0 !== e.dyn_ltree[2 * t]) return o; if (0 !== e.dyn_ltree[18] || 0 !== e.dyn_ltree[20] || 0 !== e.dyn_ltree[26]) return h; for (t = 32; t < u; t++)if (0 !== e.dyn_ltree[2 * t]) return h; return o }(e)), Y(e, e.l_desc), Y(e, e.d_desc), a = function (e) { var t; for (X(e, e.dyn_ltree, e.l_desc.max_code), X(e, e.dyn_dtree, e.d_desc.max_code), Y(e, e.bl_desc), t = c - 1; 3 <= t && 0 === e.bl_tree[2 * S[t] + 1]; t--); return e.opt_len += 3 * (t + 1) + 5 + 5 + 4, t }(e), i = e.opt_len + 3 + 7 >>> 3, (s = e.static_len + 3 + 7 >>> 3) <= i && (i = s)) : i = s = r + 5, r + 4 <= i && -1 !== t ? J(e, t, r, n) : 4 === e.strategy || s === i ? (P(e, 2 + (n ? 1 : 0), 3), K(e, z, C)) : (P(e, 4 + (n ? 1 : 0), 3), function (e, t, r, n) { var i; for (P(e, t - 257, 5), P(e, r - 1, 5), P(e, n - 4, 4), i = 0; i < n; i++)P(e, e.bl_tree[2 * S[i] + 1], 3); V(e, e.dyn_ltree, t - 1), V(e, e.dyn_dtree, r - 1) }(e, e.l_desc.max_code + 1, e.d_desc.max_code + 1, a + 1), K(e, e.dyn_ltree, e.dyn_dtree)), W(e), n && M(e) }, r._tr_tally = function (e, t, r) { return e.pending_buf[e.d_buf + 2 * e.last_lit] = t >>> 8 & 255, e.pending_buf[e.d_buf + 2 * e.last_lit + 1] = 255 & t, e.pending_buf[e.l_buf + e.last_lit] = 255 & r, e.last_lit++, 0 === t ? e.dyn_ltree[2 * r]++ : (e.matches++, t--, e.dyn_ltree[2 * (A[r] + u + 1)]++, e.dyn_dtree[2 * N(t)]++), e.last_lit === e.lit_bufsize - 1 }, r._tr_align = function (e) { P(e, 2, 3), L(e, m, z), function (e) { 16 === e.bi_valid ? (U(e, e.bi_buf), e.bi_buf = 0, e.bi_valid = 0) : 8 <= e.bi_valid && (e.pending_buf[e.pending++] = 255 & e.bi_buf, e.bi_buf >>= 8, e.bi_valid -= 8) }(e) } }, { "../utils/common": 41 }], 53: [function (e, t, r) { "use strict"; t.exports = function () { this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0 } }, {}], 54: [function (e, t, r) { (function (e) { !function (r, n) { "use strict"; if (!r.setImmediate) { var i, s, t, a, o = 1, h = {}, u = !1, l = r.document, e = Object.getPrototypeOf && Object.getPrototypeOf(r); e = e && e.setTimeout ? e : r, i = "[object process]" === {}.toString.call(r.process) ? function (e) { process.nextTick(function () { c(e) }) } : function () { if (r.postMessage && !r.importScripts) { var e = !0, t = r.onmessage; return r.onmessage = function () { e = !1 }, r.postMessage("", "*"), r.onmessage = t, e } }() ? (a = "setImmediate$" + Math.random() + "$", r.addEventListener ? r.addEventListener("message", d, !1) : r.attachEvent("onmessage", d), function (e) { r.postMessage(a + e, "*") }) : r.MessageChannel ? ((t = new MessageChannel).port1.onmessage = function (e) { c(e.data) }, function (e) { t.port2.postMessage(e) }) : l && "onreadystatechange" in l.createElement("script") ? (s = l.documentElement, function (e) { var t = l.createElement("script"); t.onreadystatechange = function () { c(e), t.onreadystatechange = null, s.removeChild(t), t = null }, s.appendChild(t) }) : function (e) { setTimeout(c, 0, e) }, e.setImmediate = function (e) { "function" != typeof e && (e = new Function("" + e)); for (var t = new Array(arguments.length - 1), r = 0; r < t.length; r++)t[r] = arguments[r + 1]; var n = { callback: e, args: t }; return h[o] = n, i(o), o++ }, e.clearImmediate = f } function f(e) { delete h[e] } function c(e) { if (u) setTimeout(c, 0, e); else { var t = h[e]; if (t) { u = !0; try { !function (e) { var t = e.callback, r = e.args; switch (r.length) { case 0: t(); break; case 1: t(r[0]); break; case 2: t(r[0], r[1]); break; case 3: t(r[0], r[1], r[2]); break; default: t.apply(n, r) } }(t) } finally { f(e), u = !1 } } } } function d(e) { e.source === r && "string" == typeof e.data && 0 === e.data.indexOf(a) && c(+e.data.slice(a.length)) } }("undefined" == typeof self ? void 0 === e ? this : e : self) }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}) }, {}] }, {}, [10])(10) });    </script>
    <style>
        /* ===== Theme Variables ===== */
        [data-theme="light"] {
            --bg-primary: #ffffff;
            --bg-secondary: #f6f6f7;
            --bg-card: rgba(255, 255, 255, 0.85);
            --text-primary: #1b1b1f;
            --text-secondary: #60646c;
            --border-color: #e2e2e3;
            --accent: #3b82f6;
            --accent-hover: #2563eb;
            --accent-soft: rgba(59, 130, 246, 0.1);
            --nav-bg: rgba(255, 255, 255, 0.75);
            --code-bg: #f6f6f7;
            --shadow: 0 1px 3px rgba(0, 0, 0, 0.08), 0 4px 16px rgba(0, 0, 0, 0.04);
            --shadow-lg: 0 8px 32px rgba(0, 0, 0, 0.08);
            --hero-gradient: linear-gradient(135deg, #fff5f0 0%, #fef0e8 30%, #f0f4ff 100%);
        }

        [data-theme="dark"] {
            --bg-primary: #1b1b1f;
            --bg-secondary: #252529;
            --bg-card: rgba(37, 37, 41, 0.85);
            --text-primary: #e0e0e4;
            --text-secondary: #a0a0a8;
            --border-color: #3a3a40;
            --accent: #3b82f6;
            --accent-hover: #60a5fa;
            --accent-soft: rgba(59, 130, 246, 0.15);
            --nav-bg: rgba(27, 27, 31, 0.8);
            --code-bg: #252529;
            --shadow: 0 1px 3px rgba(0, 0, 0, 0.3), 0 4px 16px rgba(0, 0, 0, 0.2);
            --shadow-lg: 0 8px 32px rgba(0, 0, 0, 0.35);
            --hero-gradient: linear-gradient(135deg, #1f1a17 0%, #1e1c20 50%, #19191d 100%);
        }

        *,
        *::before,
        *::after {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            background-color: var(--bg-primary);
            color: var(--text-primary);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            transition: background-color 0.3s, color 0.3s;
        }

        a {
            color: var(--accent);
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }

        .navbar {
            position: sticky;
            top: 0;
            z-index: 100;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 24px;
            height: 56px;
            background: var(--nav-bg);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border-bottom: 1px solid var(--border-color);
            transition: background 0.3s;
        }

        .navbar-brand {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 1.15rem;
            font-weight: 700;
            color: var(--text-primary);
        }

        .navbar-brand svg {
            width: 28px;
            height: 28px;
        }

        .navbar-actions {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .icon-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 36px;
            height: 36px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            background: transparent;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s;
        }

        .icon-btn:hover {
            background: var(--accent-soft);
            color: var(--accent);
            border-color: var(--accent);
        }

        .lang-select {
            padding: 4px 8px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            background: transparent;
            color: var(--text-primary);
            cursor: pointer;
            font-size: 0.85rem;
            outline: none;
            transition: all 0.2s;
        }

        .lang-select:hover {
            border-color: var(--accent);
        }

        /* Toggle Switch */
        .theme-switch-wrapper {
            display: flex;
            align-items: center;
        }

        .theme-switch {
            display: inline-block;
            height: 24px;
            position: relative;
            width: 44px;
        }

        .theme-switch input {
            display: none;
        }

        .slider {
            background-color: var(--border-color);
            bottom: 0;
            cursor: pointer;
            left: 0;
            position: absolute;
            right: 0;
            top: 0;
            transition: .4s;
            border-radius: 34px;
        }

        .slider:before {
            background-color: #fff;
            bottom: 3px;
            content: "";
            height: 18px;
            left: 3px;
            position: absolute;
            transition: .4s;
            width: 18px;
            border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        input:checked+.slider {
            background-color: var(--accent);
        }

        input:checked+.slider:before {
            transform: translateX(20px);
        }

        .hero {
            background: var(--hero-gradient);
            padding: 64px 24px 48px;
            text-align: center;
            transition: background 0.3s;
        }

        .hero h1 {
            font-size: clamp(2rem, 5vw, 3rem);
            font-weight: 800;
            letter-spacing: -0.02em;
            margin-bottom: 12px;
        }

        .hero h1 .accent {
            color: var(--accent);
        }

        .hero p {
            font-size: 1.1rem;
            color: var(--text-secondary);
            max-width: 540px;
            margin: 0 auto 32px;
        }

        .main-container {
            max-width: 800px;
            margin: -32px auto 0;
            padding: 0 24px 48px;
            position: relative;
            z-index: 1;
        }

        .card {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            padding: 28px;
            box-shadow: var(--shadow-lg);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            transition: all 0.3s;
        }

        .form-section {
            margin-bottom: 20px;
        }

        .form-label {
            display: block;
            margin-bottom: 6px;
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .form-input {
            width: 100%;
            padding: 10px 14px;
            border-radius: 10px;
            border: 1px solid var(--border-color);
            background: var(--bg-secondary);
            color: var(--text-primary);
            font-size: 0.95rem;
            outline: none;
            transition: all 0.2s;
        }

        .form-input:focus {
            border-color: var(--accent);
            box-shadow: 0 0 0 3px var(--accent-soft);
        }

        .form-input::placeholder {
            color: var(--text-secondary);
            opacity: 0.6;
        }

        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 12px 24px;
            border-radius: 10px;
            border: none;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            width: 100%;
        }

        .btn-primary {
            background: var(--accent);
            color: #fff;
        }

        .btn-primary:hover {
            background: var(--accent-hover);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(232, 102, 45, 0.3);
        }

        .btn-primary:active {
            transform: translateY(0);
        }

        .btn-primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .btn-secondary {
            background: var(--bg-secondary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }

        .btn-secondary:hover {
            border-color: var(--accent);
            color: var(--accent);
        }

        .btn-secondary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-bottom: 16px;
        }

        .status-bar {
            text-align: center;
            padding: 10px;
            margin: 16px 0;
            font-size: 0.9rem;
            color: var(--text-secondary);
            border-radius: 8px;
            background: var(--bg-secondary);
            min-height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .output-area {
            width: 100%;
            min-height: 200px;
            max-height: 400px;
            padding: 14px;
            border-radius: 10px;
            border: 1px solid var(--border-color);
            background: var(--code-bg);
            color: var(--text-primary);
            font-family: "SF Mono", "Fira Code", "Fira Mono", Menlo, Consolas, monospace;
            font-size: 0.85rem;
            line-height: 1.5;
            resize: vertical;
            outline: none;
            transition: all 0.2s;
        }

        .output-area:focus {
            border-color: var(--accent);
        }

        .token-info {
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-top: 4px;
        }

        .divider {
            border: none;
            height: 1px;
            background: var(--border-color);
            margin: 20px 0;
        }

        .feature-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 16px;
            max-width: 800px;
            margin: 32px auto 0;
            padding: 0 24px;
        }

        .feature-card {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 20px;
            transition: all 0.25s;
            backdrop-filter: blur(4px);
        }

        .feature-card:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
            border-color: var(--accent);
        }

        .feature-icon {
            font-size: 1.5rem;
            margin-bottom: 10px;
        }

        .feature-card h3 {
            font-size: 0.95rem;
            font-weight: 600;
            margin-bottom: 6px;
            color: var(--text-primary);
        }

        .feature-card p {
            font-size: 0.85rem;
            color: var(--text-secondary);
            line-height: 1.5;
        }

        .footer {
            text-align: center;
            padding: 32px 24px;
            font-size: 0.8rem;
            color: var(--text-secondary);
            border-top: 1px solid var(--border-color);
            margin-top: 48px;
        }

        .footer a {
            color: var(--accent);
        }

        @media (max-width: 640px) {
            .hero {
                padding: 40px 16px 32px;
            }

            .hero h1 {
                font-size: 1.8rem;
            }

            .main-container {
                padding: 0 16px 32px;
            }

            .card {
                padding: 20px;
            }

            .btn-group {
                grid-template-columns: 1fr;
            }

            .feature-grid {
                grid-template-columns: 1fr;
                padding: 0 16px;
            }

            .navbar {
                padding: 0 16px;
            }
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .animate-in {
            animation: fadeInUp 0.5s ease-out both;
        }

        .delay-1 {
            animation-delay: 0.1s;
        }

        .delay-2 {
            animation-delay: 0.2s;
        }

        .delay-3 {
            animation-delay: 0.3s;
        }

        /* ===== Tab Interface (Repomix Style) ===== */
        .tab-container {
            display: flex;
            background: var(--bg-secondary);
            padding: 4px;
            border-radius: 12px;
            margin-bottom: 24px;
            border: 1px solid var(--border-color);
        }

        .tab-item {
            flex: 1;
            text-align: center;
            padding: 8px 12px;
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--text-secondary);
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.2s;
            user-select: none;
        }

        .tab-item:hover {
            color: var(--text-primary);
            background: rgba(0, 0, 0, 0.02);
        }

        .tab-item.active {
            background: var(--bg-card);
            color: var(--accent);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .tab-panel {
            display: none;
            animation: fadeIn 0.3s ease-out;
        }

        .tab-panel.active {
            display: block;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(4px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .upload-area {
            border: 2px dashed var(--border-color);
            border-radius: 12px;
            padding: 32px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            background: var(--bg-secondary);
            margin-bottom: 16px;
        }

        .upload-area:hover {
            border-color: var(--accent);
            background: var(--bg-card);
        }

        .upload-icon {
            font-size: 2rem;
            margin-bottom: 12px;
            color: var(--text-secondary);
        }

        .checkbox-wrapper {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 8px;
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .checkbox-wrapper input[type="checkbox"] {
            cursor: pointer;
            width: 16px;
            height: 16px;
            accent-color: var(--accent);
        }

        /* ===== Toast Notification ===== */
        .toast-container {
            position: fixed;
            top: 24px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 8px;
            pointer-events: none;
        }

        .toast {
            background: var(--bg-card);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 12px 24px;
            box-shadow: var(--shadow-lg);
            color: var(--text-primary);
            font-size: 0.9rem;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 8px;
            opacity: 0;
            transform: translateY(-10px);
            animation: toastSlideIn 0.3s forwards;
            pointer-events: auto;
        }

        .toast.success {
            border-left: 4px solid #22c55e;
        }

        .toast.error {
            border-left: 4px solid #ef4444;
        }

        .toast.info {
            border-left: 4px solid var(--accent);
        }

        @keyframes toastSlideIn {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes toastFadeOut {
            to {
                opacity: 0;
                transform: translateY(-10px);
            }
        }
    </style>
    <style>
        .CodeMirror {
            font-family: monospace;
            height: 300px;
            color: #000;
            direction: ltr
        }

        .CodeMirror-lines {
            padding: 4px 0
        }

        .CodeMirror pre.CodeMirror-line,
        .CodeMirror pre.CodeMirror-line-like {
            padding: 0 4px
        }

        .CodeMirror-gutter-filler,
        .CodeMirror-scrollbar-filler {
            background-color: #fff
        }

        .CodeMirror-gutters {
            border-right: 1px solid #ddd;
            background-color: #f7f7f7;
            white-space: nowrap
        }

        .CodeMirror-linenumber {
            padding: 0 3px 0 5px;
            min-width: 20px;
            text-align: right;
            color: #999;
            white-space: nowrap
        }

        .CodeMirror-guttermarker {
            color: #000
        }

        .CodeMirror-guttermarker-subtle {
            color: #999
        }

        .CodeMirror-cursor {
            border-left: 1px solid #000;
            border-right: none;
            width: 0
        }

        .CodeMirror div.CodeMirror-secondarycursor {
            border-left: 1px solid silver
        }

        .cm-fat-cursor .CodeMirror-cursor {
            width: auto;
            border: 0 !important;
            background: #7e7
        }

        .cm-fat-cursor div.CodeMirror-cursors {
            z-index: 1
        }

        .cm-fat-cursor .CodeMirror-line::selection,
        .cm-fat-cursor .CodeMirror-line>span::selection,
        .cm-fat-cursor .CodeMirror-line>span>span::selection {
            background: 0 0
        }

        .cm-fat-cursor .CodeMirror-line::-moz-selection,
        .cm-fat-cursor .CodeMirror-line>span::-moz-selection,
        .cm-fat-cursor .CodeMirror-line>span>span::-moz-selection {
            background: 0 0
        }

        .cm-fat-cursor {
            caret-color: transparent
        }

        @-moz-keyframes blink {
            50% {
                background-color: transparent
            }
        }

        @-webkit-keyframes blink {
            50% {
                background-color: transparent
            }
        }

        @keyframes blink {
            50% {
                background-color: transparent
            }
        }

        .cm-tab {
            display: inline-block;
            text-decoration: inherit
        }

        .CodeMirror-rulers {
            position: absolute;
            left: 0;
            right: 0;
            top: -50px;
            bottom: 0;
            overflow: hidden
        }

        .CodeMirror-ruler {
            border-left: 1px solid #ccc;
            top: 0;
            bottom: 0;
            position: absolute
        }

        .cm-s-default .cm-header {
            color: #00f
        }

        .cm-s-default .cm-quote {
            color: #090
        }

        .cm-negative {
            color: #d44
        }

        .cm-positive {
            color: #292
        }

        .cm-header,
        .cm-strong {
            font-weight: 700
        }

        .cm-em {
            font-style: italic
        }

        .cm-link {
            text-decoration: underline
        }

        .cm-strikethrough {
            text-decoration: line-through
        }

        .cm-s-default .cm-keyword {
            color: #708
        }

        .cm-s-default .cm-atom {
            color: #219
        }

        .cm-s-default .cm-number {
            color: #164
        }

        .cm-s-default .cm-def {
            color: #00f
        }

        .cm-s-default .cm-variable-2 {
            color: #05a
        }

        .cm-s-default .cm-type,
        .cm-s-default .cm-variable-3 {
            color: #085
        }

        .cm-s-default .cm-comment {
            color: #a50
        }

        .cm-s-default .cm-string {
            color: #a11
        }

        .cm-s-default .cm-string-2 {
            color: #f50
        }

        .cm-s-default .cm-meta {
            color: #555
        }

        .cm-s-default .cm-qualifier {
            color: #555
        }

        .cm-s-default .cm-builtin {
            color: #30a
        }

        .cm-s-default .cm-bracket {
            color: #997
        }

        .cm-s-default .cm-tag {
            color: #170
        }

        .cm-s-default .cm-attribute {
            color: #00c
        }

        .cm-s-default .cm-hr {
            color: #999
        }

        .cm-s-default .cm-link {
            color: #00c
        }

        .cm-s-default .cm-error {
            color: red
        }

        .cm-invalidchar {
            color: red
        }

        .CodeMirror-composing {
            border-bottom: 2px solid
        }

        div.CodeMirror span.CodeMirror-matchingbracket {
            color: #0b0
        }

        div.CodeMirror span.CodeMirror-nonmatchingbracket {
            color: #a22
        }

        .CodeMirror-matchingtag {
            background: rgba(255, 150, 0, .3)
        }

        .CodeMirror-activeline-background {
            background: #e8f2ff
        }

        .CodeMirror {
            position: relative;
            overflow: hidden;
            background: #fff
        }

        .CodeMirror-scroll {
            overflow: scroll !important;
            margin-bottom: -50px;
            margin-right: -50px;
            padding-bottom: 50px;
            height: 100%;
            outline: 0;
            position: relative;
            z-index: 0
        }

        .CodeMirror-sizer {
            position: relative;
            border-right: 50px solid transparent
        }

        .CodeMirror-gutter-filler,
        .CodeMirror-hscrollbar,
        .CodeMirror-scrollbar-filler,
        .CodeMirror-vscrollbar {
            position: absolute;
            z-index: 6;
            display: none;
            outline: 0
        }

        .CodeMirror-vscrollbar {
            right: 0;
            top: 0;
            overflow-x: hidden;
            overflow-y: scroll
        }

        .CodeMirror-hscrollbar {
            bottom: 0;
            left: 0;
            overflow-y: hidden;
            overflow-x: scroll
        }

        .CodeMirror-scrollbar-filler {
            right: 0;
            bottom: 0
        }

        .CodeMirror-gutter-filler {
            left: 0;
            bottom: 0
        }

        .CodeMirror-gutters {
            position: absolute;
            left: 0;
            top: 0;
            min-height: 100%;
            z-index: 3
        }

        .CodeMirror-gutter {
            white-space: normal;
            height: 100%;
            display: inline-block;
            vertical-align: top;
            margin-bottom: -50px
        }

        .CodeMirror-gutter-wrapper {
            position: absolute;
            z-index: 4;
            background: 0 0 !important;
            border: none !important
        }

        .CodeMirror-gutter-background {
            position: absolute;
            top: 0;
            bottom: 0;
            z-index: 4
        }

        .CodeMirror-gutter-elt {
            position: absolute;
            cursor: default;
            z-index: 4
        }

        .CodeMirror-gutter-wrapper ::selection {
            background-color: transparent
        }

        .CodeMirror-gutter-wrapper ::-moz-selection {
            background-color: transparent
        }

        .CodeMirror-lines {
            cursor: text;
            min-height: 1px
        }

        .CodeMirror pre.CodeMirror-line,
        .CodeMirror pre.CodeMirror-line-like {
            -moz-border-radius: 0;
            -webkit-border-radius: 0;
            border-radius: 0;
            border-width: 0;
            background: 0 0;
            font-family: inherit;
            font-size: inherit;
            margin: 0;
            white-space: pre;
            word-wrap: normal;
            line-height: inherit;
            color: inherit;
            z-index: 2;
            position: relative;
            overflow: visible;
            -webkit-tap-highlight-color: transparent;
            -webkit-font-variant-ligatures: contextual;
            font-variant-ligatures: contextual
        }

        .CodeMirror-wrap pre.CodeMirror-line,
        .CodeMirror-wrap pre.CodeMirror-line-like {
            word-wrap: break-word;
            white-space: pre-wrap;
            word-break: normal
        }

        .CodeMirror-linebackground {
            position: absolute;
            left: 0;
            right: 0;
            top: 0;
            bottom: 0;
            z-index: 0
        }

        .CodeMirror-linewidget {
            position: relative;
            z-index: 2;
            padding: .1px
        }

        .CodeMirror-rtl pre {
            direction: rtl
        }

        .CodeMirror-code {
            outline: 0
        }

        .CodeMirror-gutter,
        .CodeMirror-gutters,
        .CodeMirror-linenumber,
        .CodeMirror-scroll,
        .CodeMirror-sizer {
            -moz-box-sizing: content-box;
            box-sizing: content-box
        }

        .CodeMirror-measure {
            position: absolute;
            width: 100%;
            height: 0;
            overflow: hidden;
            visibility: hidden
        }

        .CodeMirror-cursor {
            position: absolute;
            pointer-events: none
        }

        .CodeMirror-measure pre {
            position: static
        }

        div.CodeMirror-cursors {
            visibility: hidden;
            position: relative;
            z-index: 3
        }

        div.CodeMirror-dragcursors {
            visibility: visible
        }

        .CodeMirror-focused div.CodeMirror-cursors {
            visibility: visible
        }

        .CodeMirror-selected {
            background: #d9d9d9
        }

        .CodeMirror-focused .CodeMirror-selected {
            background: #d7d4f0
        }

        .CodeMirror-crosshair {
            cursor: crosshair
        }

        .CodeMirror-line::selection,
        .CodeMirror-line>span::selection,
        .CodeMirror-line>span>span::selection {
            background: #d7d4f0
        }

        .CodeMirror-line::-moz-selection,
        .CodeMirror-line>span::-moz-selection,
        .CodeMirror-line>span>span::-moz-selection {
            background: #d7d4f0
        }

        .cm-searching {
            background-color: #ffa;
            background-color: rgba(255, 255, 0, .4)
        }

        .cm-force-border {
            padding-right: .1px
        }

        @media print {
            .CodeMirror div.CodeMirror-cursors {
                visibility: hidden
            }
        }

        .cm-tab-wrap-hack:after {
            content: ''
        }

        span.CodeMirror-selectedtext {
            background: 0 0
        }

        .cm-s-dracula .CodeMirror-gutters,
        .cm-s-dracula.CodeMirror {
            background-color: #282a36 !important;
            color: #f8f8f2 !important;
            border: none
        }

        .cm-s-dracula .CodeMirror-gutters {
            color: #282a36
        }

        .cm-s-dracula .CodeMirror-cursor {
            border-left: solid thin #f8f8f0
        }

        .cm-s-dracula .CodeMirror-linenumber {
            color: #6d8a88
        }

        .cm-s-dracula .CodeMirror-selected {
            background: rgba(255, 255, 255, .1)
        }

        .cm-s-dracula .CodeMirror-line::selection,
        .cm-s-dracula .CodeMirror-line>span::selection,
        .cm-s-dracula .CodeMirror-line>span>span::selection {
            background: rgba(255, 255, 255, .1)
        }

        .cm-s-dracula .CodeMirror-line::-moz-selection,
        .cm-s-dracula .CodeMirror-line>span::-moz-selection,
        .cm-s-dracula .CodeMirror-line>span>span::-moz-selection {
            background: rgba(255, 255, 255, .1)
        }

        .cm-s-dracula span.cm-comment {
            color: #6272a4
        }

        .cm-s-dracula span.cm-string,
        .cm-s-dracula span.cm-string-2 {
            color: #f1fa8c
        }

        .cm-s-dracula span.cm-number {
            color: #bd93f9
        }

        .cm-s-dracula span.cm-variable {
            color: #50fa7b
        }

        .cm-s-dracula span.cm-variable-2 {
            color: #fff
        }

        .cm-s-dracula span.cm-def {
            color: #50fa7b
        }

        .cm-s-dracula span.cm-operator {
            color: #ff79c6
        }

        .cm-s-dracula span.cm-keyword {
            color: #ff79c6
        }

        .cm-s-dracula span.cm-atom {
            color: #bd93f9
        }

        .cm-s-dracula span.cm-meta {
            color: #f8f8f2
        }

        .cm-s-dracula span.cm-tag {
            color: #ff79c6
        }

        .cm-s-dracula span.cm-attribute {
            color: #50fa7b
        }

        .cm-s-dracula span.cm-qualifier {
            color: #50fa7b
        }

        .cm-s-dracula span.cm-property {
            color: #66d9ef
        }

        .cm-s-dracula span.cm-builtin {
            color: #50fa7b
        }

        .cm-s-dracula span.cm-type,
        .cm-s-dracula span.cm-variable-3 {
            color: #ffb86c
        }

        .cm-s-dracula .CodeMirror-activeline-background {
            background: rgba(255, 255, 255, .1)
        }

        .cm-s-dracula .CodeMirror-matchingbracket {
            text-decoration: underline;
            color: #fff !important
        }
    </style>
    <script>
        !function (e, t) { "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = e || self).CodeMirror = t() }(this, function () { "use strict"; var e = navigator.userAgent, l = navigator.platform, d = /gecko\/\d/i.test(e), s = /MSIE \d/.test(e), a = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(e), u = /Edge\/(\d+)/.exec(e), w = s || a || u, v = w && (s ? document.documentMode || 6 : +(u || a)[1]), x = !u && /WebKit\//.test(e), s = x && /Qt\/\d+\.\d+/.test(e), m = !u && /Chrome\/(\d+)/.exec(e), V = m && +m[1], K = /Opera\//.test(e), j = /Apple Computer/.test(navigator.vendor), c = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(e), X = /PhantomJS/.test(e), Y = j && (/Mobile\/\w+/.test(e) || 2 < navigator.maxTouchPoints), $ = /Android/.test(e), _ = Y || $ || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(e), C = Y || /Mac/.test(l), q = /\bCrOS\b/.test(e), a = /win/i.test(l), u = K && e.match(/Version\/(\d*\.\d*)/), Z = ((u = u && Number(u[1])) && 15 <= u && (x = !(K = !1)), C && (s || K && (null == u || u < 12.11))), Q = d || w && 9 <= v; function J(e) { return new RegExp("(^|\\s)" + e + "(?:$|\\s)\\s*") } var ee = function (e, t) { var n, r = e.className, t = J(t).exec(r); t && (n = r.slice(t.index + t[0].length), e.className = r.slice(0, t.index) + (n ? t[1] + n : "")) }; function te(e) { for (var t = e.childNodes.length; 0 < t; --t)e.removeChild(e.firstChild); return e } function y(e, t) { return te(e).appendChild(t) } function M(e, t, n, r) { var i = document.createElement(e); if (n && (i.className = n), r && (i.style.cssText = r), "string" == typeof t) i.appendChild(document.createTextNode(t)); else if (t) for (var o = 0; o < t.length; ++o)i.appendChild(t[o]); return i } function ne(e, t, n, r) { e = M(e, t, n, r); return e.setAttribute("role", "presentation"), e } function re(e, t) { if (3 == t.nodeType && (t = t.parentNode), e.contains) return e.contains(t); do { if ((t = 11 == t.nodeType ? t.host : t) == e) return !0 } while (t = t.parentNode) } function N(e) { var t, n = e.ownerDocument || e; try { t = e.activeElement } catch (e) { t = n.body || null } for (; t && t.shadowRoot && t.shadowRoot.activeElement;)t = t.shadowRoot.activeElement; return t } function ie(e, t) { var n = e.className; J(t).test(n) || (e.className += (n ? " " : "") + t) } function oe(e, t) { for (var n = e.split(" "), r = 0; r < n.length; r++)n[r] && !J(n[r]).test(t) && (t += " " + n[r]); return t } var le = document.createRange ? function (e, t, n, r) { var i = document.createRange(); return i.setEnd(r || e, n), i.setStart(e, t), i } : function (e, t, n) { var r = document.body.createTextRange(); try { r.moveToElementText(e.parentNode) } catch (e) { return r } return r.collapse(!0), r.moveEnd("character", n), r.moveStart("character", t), r }, se = function (e) { e.select() }; function ae(e) { return e.display.wrapper.ownerDocument } function ue(e) { return ce(e.display.wrapper) } function ce(e) { return e.getRootNode ? e.getRootNode() : e.ownerDocument } function he(e) { return ae(e).defaultView } function de(e) { var t = Array.prototype.slice.call(arguments, 1); return function () { return e.apply(null, t) } } function fe(e, t, n) { for (var r in t = t || {}, e) !e.hasOwnProperty(r) || !1 === n && t.hasOwnProperty(r) || (t[r] = e[r]); return t } function S(e, t, n, r, i) { null == t && -1 == (t = e.search(/[^\s\u00a0]/)) && (t = e.length); for (var o = r || 0, l = i || 0; ;) { var s = e.indexOf("\t", o); if (s < 0 || t <= s) return l + (t - o); l = (l += s - o) + (n - l % n), o = s + 1 } } Y ? se = function (e) { e.selectionStart = 0, e.selectionEnd = e.value.length } : w && (se = function (e) { try { e.select() } catch (e) { } }); function pe() { this.id = null, this.f = null, this.time = 0, this.handler = de(this.onTimeout, this) } function L(e, t) { for (var n = 0; n < e.length; ++n)if (e[n] == t) return n; return -1 } pe.prototype.onTimeout = function (e) { e.id = 0, e.time <= +new Date ? e.f() : setTimeout(e.handler, e.time - +new Date) }; var ge = 50, me = { toString: function () { return "CodeMirror.Pass" } }, ve = { scroll: !(pe.prototype.set = function (e, t) { this.f = t; t = +new Date + e; (!this.id || t < this.time) && (clearTimeout(this.id), this.id = setTimeout(this.handler, e), this.time = t) }) }, ye = { origin: "*mouse" }, be = { origin: "+move" }; function we(e, t, n) { for (var r = 0, i = 0; ;) { var o = e.indexOf("\t", r), l = (o = -1 == o ? e.length : o) - r; if (o == e.length || t <= i + l) return r + Math.min(l, t - i); if (i += o - r, r = o + 1, t <= (i += n - i % n)) return r } } var xe = [""]; function Ce(e) { for (; xe.length <= e;)xe.push(z(xe) + " "); return xe[e] } function z(e) { return e[e.length - 1] } function Se(e, t) { for (var n = [], r = 0; r < e.length; r++)n[r] = t(e[r], r); return n } function Le() { } function ke(e, t) { e = Object.create ? Object.create(e) : (Le.prototype = e, new Le); return t && fe(t, e), e } var Te = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/; function Me(e) { return /\w/.test(e) || "" < e && (e.toUpperCase() != e.toLowerCase() || Te.test(e)) } function Ne(e, t) { return t ? !!(-1 < t.source.indexOf("\\w") && Me(e)) || t.test(e) : Me(e) } function Oe(e) { for (var t in e) if (e.hasOwnProperty(t) && e[t]) return; return 1 } var Ae = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/; function De(e) { return 768 <= e.charCodeAt(0) && Ae.test(e) } function We(e, t, n) { for (; (n < 0 ? 0 < t : t < e.length) && De(e.charAt(t));)t += n; return t } function He(e, t, n) { for (var r = n < t ? -1 : 1; ;) { if (t == n) return t; var i = (t + n) / 2, i = r < 0 ? Math.ceil(i) : Math.floor(i); if (i == t) return e(i) ? t : n; e(i) ? n = i : t = i + r } } var Fe = null; function Pe(e, t, n) { var r; Fe = null; for (var i = 0; i < e.length; ++i) { var o = e[i]; if (o.from < t && o.to > t) return i; o.to == t && (o.from != o.to && "before" == n ? r = i : Fe = i), o.from == t && (o.from != o.to && "before" != n ? r = i : Fe = i) } return null != r ? r : Fe } Ee = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/, Re = /[stwN]/, ze = /[LRr]/, Ie = /[Lb1n]/, Be = /[1n]/; var Ee, Re, ze, Ie, Be, Ge = function (e, t) { var n = "ltr" == t ? "L" : "R"; if (0 == e.length || "ltr" == t && !Ee.test(e)) return !1; for (var r, i = e.length, o = [], l = 0; l < i; ++l)o.push((r = e.charCodeAt(l)) <= 247 ? "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN".charAt(r) : 1424 <= r && r <= 1524 ? "R" : 1536 <= r && r <= 1785 ? "nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111".charAt(r - 1536) : 1774 <= r && r <= 2220 ? "r" : 8192 <= r && r <= 8203 ? "w" : 8204 == r ? "b" : "L"); for (var s = 0, a = n; s < i; ++s) { var u = o[s]; "m" == u ? o[s] = a : a = u } for (var c = 0, h = n; c < i; ++c) { var d = o[c]; "1" == d && "r" == h ? o[c] = "n" : ze.test(d) && "r" == (h = d) && (o[c] = "R") } for (var f = 1, p = o[0]; f < i - 1; ++f) { var g = o[f]; "+" == g && "1" == p && "1" == o[f + 1] ? o[f] = "1" : "," != g || p != o[f + 1] || "1" != p && "n" != p || (o[f] = p), p = g } for (var m = 0; m < i; ++m) { var v = o[m]; if ("," == v) o[m] = "N"; else if ("%" == v) { for (var y = void 0, y = m + 1; y < i && "%" == o[y]; ++y); for (var b = m && "!" == o[m - 1] || y < i && "1" == o[y] ? "1" : "N", w = m; w < y; ++w)o[w] = b; m = y - 1 } } for (var x = 0, C = n; x < i; ++x) { var S = o[x]; "L" == C && "1" == S ? o[x] = "L" : ze.test(S) && (C = S) } for (var L = 0; L < i; ++L)if (Re.test(o[L])) { for (var k = void 0, k = L + 1; k < i && Re.test(o[k]); ++k); for (var T = "L" == (L ? o[L - 1] : n), M = T == ("L" == (k < i ? o[k] : n)) ? T ? "L" : "R" : n, N = L; N < k; ++N)o[N] = M; L = k - 1 } for (var O, A = [], D = 0; D < i;)if (Ie.test(o[D])) { var E = D; for (++D; D < i && Ie.test(o[D]); ++D); A.push(new Ue(0, E, D)) } else { var W = D, H = A.length, F = "rtl" == t ? 1 : 0; for (++D; D < i && "L" != o[D]; ++D); for (var P = W; P < D;)if (Be.test(o[P])) { W < P && (A.splice(H, 0, new Ue(1, W, P)), H += F); var R = P; for (++P; P < D && Be.test(o[P]); ++P); A.splice(H, 0, new Ue(2, R, P)), H += F, W = P } else ++P; W < D && A.splice(H, 0, new Ue(1, W, D)) } return "ltr" == t && (1 == A[0].level && (O = e.match(/^\s+/)) && (A[0].from = O[0].length, A.unshift(new Ue(0, 0, O[0].length))), 1 == z(A).level && (O = e.match(/\s+$/)) && (z(A).to -= O[0].length, A.push(new Ue(0, i - O[0].length, i)))), "rtl" == t ? A.reverse() : A }; function Ue(e, t, n) { this.level = e, this.from = t, this.to = n } function Ve(e, t) { var n = e.order; return n = null == n ? e.order = Ge(e.text, t) : n } var Ke = [], k = function (e, t, n) { e.addEventListener ? e.addEventListener(t, n, !1) : e.attachEvent ? e.attachEvent("on" + t, n) : (e = e._handlers || (e._handlers = {}))[t] = (e[t] || Ke).concat(n) }; function je(e, t) { return e._handlers && e._handlers[t] || Ke } function T(e, t, n) { var r; e.removeEventListener ? e.removeEventListener(t, n, !1) : e.detachEvent ? e.detachEvent("on" + t, n) : (r = (e = e._handlers) && e[t]) && -1 < (n = L(r, n)) && (e[t] = r.slice(0, n).concat(r.slice(n + 1))) } function O(e, t) { var n = je(e, t); if (n.length) for (var r = Array.prototype.slice.call(arguments, 2), i = 0; i < n.length; ++i)n[i].apply(null, r) } function A(e, t, n) { return "string" == typeof t && (t = { type: t, preventDefault: function () { this.defaultPrevented = !0 } }), O(e, n || t.type, e, t), qe(t) || t.codemirrorIgnore } function Xe(e) { var t = e._handlers && e._handlers.cursorActivity; if (t) for (var n = e.curOp.cursorActivityHandlers || (e.curOp.cursorActivityHandlers = []), r = 0; r < t.length; ++r)-1 == L(n, t[r]) && n.push(t[r]) } function Ye(e, t) { return 0 < je(e, t).length } function $e(e) { e.prototype.on = function (e, t) { k(this, e, t) }, e.prototype.off = function (e, t) { T(this, e, t) } } function D(e) { e.preventDefault ? e.preventDefault() : e.returnValue = !1 } function _e(e) { e.stopPropagation ? e.stopPropagation() : e.cancelBubble = !0 } function qe(e) { return null != e.defaultPrevented ? e.defaultPrevented : 0 == e.returnValue } function Ze(e) { D(e), _e(e) } function Qe(e) { return e.target || e.srcElement } function Je(e) { var t = e.which; return null == t && (1 & e.button ? t = 1 : 2 & e.button ? t = 3 : 4 & e.button && (t = 2)), t = C && e.ctrlKey && 1 == t ? 3 : t } var et, tt, nt = function () { if (w && v < 9) return !1; var e = M("div"); return "draggable" in e || "dragDrop" in e }(); var rt = 3 != "\n\nb".split(/\n/).length ? function (e) { for (var t = 0, n = [], r = e.length; t <= r;) { var i = e.indexOf("\n", t), o = (-1 == i && (i = e.length), e.slice(t, "\r" == e.charAt(i - 1) ? i - 1 : i)), l = o.indexOf("\r"); -1 != l ? (n.push(o.slice(0, l)), t += l + 1) : (n.push(o), t = i + 1) } return n } : function (e) { return e.split(/\r\n?|\n/) }, it = window.getSelection ? function (e) { try { return e.selectionStart != e.selectionEnd } catch (e) { return !1 } } : function (e) { var t; try { t = e.ownerDocument.selection.createRange() } catch (e) { } return !(!t || t.parentElement() != e) && 0 != t.compareEndPoints("StartToEnd", t) }, ot = "oncopy" in (l = M("div")) || (l.setAttribute("oncopy", "return;"), "function" == typeof l.oncopy), lt = null; var st = {}, at = {}; function ut(e) { if ("string" == typeof e && at.hasOwnProperty(e)) e = at[e]; else if (e && "string" == typeof e.name && at.hasOwnProperty(e.name)) { var t = at[e.name]; (e = ke(t = "string" == typeof t ? { name: t } : t, e)).name = t.name } else { if ("string" == typeof e && /^[\w\-]+\/[\w\-]+\+xml$/.test(e)) return ut("application/xml"); if ("string" == typeof e && /^[\w\-]+\/[\w\-]+\+json$/.test(e)) return ut("application/json") } return "string" == typeof e ? { name: e } : e || { name: "null" } } function ct(e, t) { t = ut(t); var n = st[t.name]; if (!n) return ct(e, "text/plain"); var r = n(e, t); if (ht.hasOwnProperty(t.name)) { var i, o = ht[t.name]; for (i in o) o.hasOwnProperty(i) && (r.hasOwnProperty(i) && (r["_" + i] = r[i]), r[i] = o[i]) } if (r.name = t.name, t.helperType && (r.helperType = t.helperType), t.modeProps) for (var l in t.modeProps) r[l] = t.modeProps[l]; return r } var ht = {}; function dt(e, t) { fe(t, ht.hasOwnProperty(e) ? ht[e] : ht[e] = {}) } function ft(e, t) { if (!0 === t) return t; if (e.copyState) return e.copyState(t); var n, r = {}; for (n in t) { var i = t[n]; i instanceof Array && (i = i.concat([])), r[n] = i } return r } function pt(e, t) { for (var n; e.innerMode && (n = e.innerMode(t)) && n.mode != e;)t = n.state, e = n.mode; return n || { mode: e, state: t } } function gt(e, t, n) { return !e.startState || e.startState(t, n) } var g = function (e, t, n) { this.pos = this.start = 0, this.string = e, this.tabSize = t || 8, this.lastColumnPos = this.lastColumnValue = 0, this.lineStart = 0, this.lineOracle = n }; function W(e, t) { if ((t -= e.first) < 0 || t >= e.size) throw new Error("There is no line " + (t + e.first) + " in the document."); for (var n = e; !n.lines;)for (var r = 0; ; ++r) { var i = n.children[r], o = i.chunkSize(); if (t < o) { n = i; break } t -= o } return n.lines[t] } function mt(e, t, n) { var r = [], i = t.line; return e.iter(t.line, n.line + 1, function (e) { e = e.text; i == n.line && (e = e.slice(0, n.ch)), i == t.line && (e = e.slice(t.ch)), r.push(e), ++i }), r } function vt(e, t, n) { var r = []; return e.iter(t, n, function (e) { r.push(e.text) }), r } function yt(e, t) { var n = t - e.height; if (n) for (var r = e; r; r = r.parent)r.height += n } function H(e) { if (null == e.parent) return null; for (var t = e.parent, n = L(t.lines, e), r = t.parent; r; r = (t = r).parent)for (var i = 0; r.children[i] != t; ++i)n += r.children[i].chunkSize(); return n + t.first } function bt(e, t) { var n = e.first; e: do { for (var r = 0; r < e.children.length; ++r) { var i = e.children[r], o = i.height; if (t < o) { e = i; continue e } t -= o, n += i.chunkSize() } return n } while (!e.lines); for (var l = 0; l < e.lines.length; ++l) { var s = e.lines[l].height; if (t < s) break; t -= s } return n + l } function wt(e, t) { return t >= e.first && t < e.first + e.size } function xt(e, t) { return String(e.lineNumberFormatter(t + e.firstLineNumber)) } function F(e, t, n) { if (void 0 === n && (n = null), !(this instanceof F)) return new F(e, t, n); this.line = e, this.ch = t, this.sticky = n } function P(e, t) { return e.line - t.line || e.ch - t.ch } function Ct(e, t) { return e.sticky == t.sticky && 0 == P(e, t) } function St(e) { return F(e.line, e.ch) } function Lt(e, t) { return P(e, t) < 0 ? t : e } function kt(e, t) { return P(e, t) < 0 ? e : t } function Tt(e, t) { return Math.max(e.first, Math.min(t, e.first + e.size - 1)) } function E(e, t) { if (t.line < e.first) return F(e.first, 0); var n = e.first + e.size - 1; return t.line > n ? F(n, W(e, n).text.length) : (e = W(e, (n = t).line).text.length, null == (t = n.ch) || e < t ? F(n.line, e) : t < 0 ? F(n.line, 0) : n) } function Mt(e, t) { for (var n = [], r = 0; r < t.length; r++)n[r] = E(e, t[r]); return n } g.prototype.eol = function () { return this.pos >= this.string.length }, g.prototype.sol = function () { return this.pos == this.lineStart }, g.prototype.peek = function () { return this.string.charAt(this.pos) || void 0 }, g.prototype.next = function () { if (this.pos < this.string.length) return this.string.charAt(this.pos++) }, g.prototype.eat = function (e) { var t = this.string.charAt(this.pos), e = "string" == typeof e ? t == e : t && (e.test ? e.test(t) : e(t)); if (e) return ++this.pos, t }, g.prototype.eatWhile = function (e) { for (var t = this.pos; this.eat(e);); return this.pos > t }, g.prototype.eatSpace = function () { for (var e = this.pos; /[\s\u00a0]/.test(this.string.charAt(this.pos));)++this.pos; return this.pos > e }, g.prototype.skipToEnd = function () { this.pos = this.string.length }, g.prototype.skipTo = function (e) { e = this.string.indexOf(e, this.pos); if (-1 < e) return this.pos = e, !0 }, g.prototype.backUp = function (e) { this.pos -= e }, g.prototype.column = function () { return this.lastColumnPos < this.start && (this.lastColumnValue = S(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue), this.lastColumnPos = this.start), this.lastColumnValue - (this.lineStart ? S(this.string, this.lineStart, this.tabSize) : 0) }, g.prototype.indentation = function () { return S(this.string, null, this.tabSize) - (this.lineStart ? S(this.string, this.lineStart, this.tabSize) : 0) }, g.prototype.match = function (e, t, n) { var r; if ("string" != typeof e) return (r = this.string.slice(this.pos).match(e)) && 0 < r.index ? null : (r && !1 !== t && (this.pos += r[0].length), r); function i(e) { return n ? e.toLowerCase() : e } return i(this.string.substr(this.pos, e.length)) == i(e) ? (!1 !== t && (this.pos += e.length), !0) : void 0 }, g.prototype.current = function () { return this.string.slice(this.start, this.pos) }, g.prototype.hideFirstChars = function (e, t) { this.lineStart += e; try { return t() } finally { this.lineStart -= e } }, g.prototype.lookAhead = function (e) { var t = this.lineOracle; return t && t.lookAhead(e) }, g.prototype.baseToken = function () { var e = this.lineOracle; return e && e.baseToken(this.pos) }; function Nt(e, t) { this.state = e, this.lookAhead = t } var Ot = function (e, t, n, r) { this.state = t, this.doc = e, this.line = n, this.maxLookAhead = r || 0, this.baseTokens = null, this.baseTokenPos = 1 }; function At(t, n, r, e) { for (var a = [t.state.modeGen], i = {}, u = (It(t, n.text, t.doc.mode, r, function (e, t) { a.push(e, t) }, i, e), r.state), o = 0; o < t.state.overlays.length; ++o)!function (e) { r.baseTokens = a; var o = t.state.overlays[e], l = 1, s = 0; r.state = !0, It(t, n.text, o.mode, r, function (e, t) { for (var n = l; s < e;) { var r = a[l]; e < r && a.splice(l, 1, e, a[l + 1], r), l += 2, s = Math.min(e, r) } if (t) if (o.opaque) a.splice(n, l - n, e, "overlay " + t), l = n + 2; else for (; n < l; n += 2) { var i = a[n + 1]; a[n + 1] = (i ? i + " " : "") + "overlay " + t } }, i), r.state = u, r.baseTokens = null, r.baseTokenPos = 1 }(o); return { styles: a, classes: i.bgClass || i.textClass ? i : null } } function Dt(e, t, n) { var r, i, o; return t.styles && t.styles[0] == e.state.modeGen || (r = Wt(e, H(t)), i = t.text.length > e.options.maxHighlightLength && ft(e.doc.mode, r.state), o = At(e, t, r), i && (r.state = i), t.stateAfter = r.save(!i), t.styles = o.styles, o.classes ? t.styleClasses = o.classes : t.styleClasses && (t.styleClasses = null), n === e.doc.highlightFrontier && (e.doc.modeFrontier = Math.max(e.doc.modeFrontier, ++e.doc.highlightFrontier))), t.styles } function Wt(n, r, e) { var t = n.doc, i = n.display; if (!t.mode.startState) return new Ot(t, !0, r); var o = function (e, t, n) { for (var r, i, o = e.doc, l = n ? -1 : t - (e.doc.mode.innerMode ? 1e3 : 100), s = t; l < s; --s) { if (s <= o.first) return o.first; var a = W(o, s - 1), u = a.stateAfter; if (u && (!n || s + (u instanceof Nt ? u.lookAhead : 0) <= o.modeFrontier)) return s; u = S(a.text, null, e.options.tabSize); (null == i || u < r) && (i = s - 1, r = u) } return i }(n, r, e), l = o > t.first && W(t, o - 1).stateAfter, s = l ? Ot.fromSaved(t, l, o) : new Ot(t, gt(t.mode), o); return t.iter(o, r, function (e) { Ht(n, e.text, s); var t = s.line; e.stateAfter = t == r - 1 || t % 5 == 0 || t >= i.viewFrom && t < i.viewTo ? s.save() : null, s.nextLine() }), e && (t.modeFrontier = s.line), s } function Ht(e, t, n, r) { var i = e.doc.mode, o = new g(t, e.options.tabSize, n); for (o.start = o.pos = r || 0, "" == t && Ft(i, n.state); !o.eol();)Pt(i, o, n.state), o.start = o.pos } function Ft(e, t) { if (e.blankLine) return e.blankLine(t); if (e.innerMode) return e = pt(e, t), e.mode.blankLine ? e.mode.blankLine(e.state) : void 0 } function Pt(e, t, n, r) { for (var i = 0; i < 10; i++) { r && (r[0] = pt(e, n).mode); var o = e.token(t, n); if (t.pos > t.start) return o } throw new Error("Mode " + e.name + " failed to advance stream.") } Ot.prototype.lookAhead = function (e) { var t = this.doc.getLine(this.line + e); return null != t && e > this.maxLookAhead && (this.maxLookAhead = e), t }, Ot.prototype.baseToken = function (e) { if (!this.baseTokens) return null; for (; this.baseTokens[this.baseTokenPos] <= e;)this.baseTokenPos += 2; var t = this.baseTokens[this.baseTokenPos + 1]; return { type: t && t.replace(/( |^)overlay .*/, ""), size: this.baseTokens[this.baseTokenPos] - e } }, Ot.prototype.nextLine = function () { this.line++, 0 < this.maxLookAhead && this.maxLookAhead-- }, Ot.fromSaved = function (e, t, n) { return t instanceof Nt ? new Ot(e, ft(e.mode, t.state), n, t.lookAhead) : new Ot(e, ft(e.mode, t), n) }, Ot.prototype.save = function (e) { e = !1 !== e ? ft(this.doc.mode, this.state) : this.state; return 0 < this.maxLookAhead ? new Nt(e, this.maxLookAhead) : e }; var Et = function (e, t, n) { this.start = e.start, this.end = e.pos, this.string = e.current(), this.type = t || null, this.state = n }; function Rt(e, t, n, r) { var i, o, l = e.doc, s = l.mode, a = W(l, (t = E(l, t)).line), u = Wt(e, t.line, n), c = new g(a.text, e.options.tabSize, u); for (r && (o = []); (r || c.pos < t.ch) && !c.eol();)c.start = c.pos, i = Pt(s, c, u.state), r && o.push(new Et(c, i, ft(l.mode, u.state))); return r ? o : new Et(c, i, u.state) } function zt(e, t) { if (e) for (; ;) { var n = e.match(/(?:^|\s+)line-(background-)?(\S+)/); if (!n) break; e = e.slice(0, n.index) + e.slice(n.index + n[0].length); var r = n[1] ? "bgClass" : "textClass"; null == t[r] ? t[r] = n[2] : new RegExp("(?:^|\\s)" + n[2] + "(?:$|\\s)").test(t[r]) || (t[r] += " " + n[2]) } return e } function It(e, t, n, r, i, o, l) { var s = n.flattenSpans, a = (null == s && (s = e.options.flattenSpans), 0), u = null, c = new g(t, e.options.tabSize, r), h = e.options.addModeClass && [null]; for ("" == t && zt(Ft(n, r.state), o); !c.eol();) { var d, f = c.pos > e.options.maxHighlightLength ? (s = !1, l && Ht(e, t, r, c.pos), c.pos = t.length, null) : zt(Pt(n, c, r.state, h), o); if (!h || (d = h[0].name) && (f = "m-" + (f ? d + " " + f : d)), !s || u != f) { for (; a < c.start;)i(a = Math.min(c.start, a + 5e3), u); u = f } c.start = c.pos } for (; a < c.pos;) { var p = Math.min(c.pos, a + 5e3); i(p, u), a = p } } var Bt = !1, Gt = !1; function Ut(e, t, n) { this.marker = e, this.from = t, this.to = n } function Vt(e, t) { if (e) for (var n = 0; n < e.length; ++n) { var r = e[n]; if (r.marker == t) return r } } function Kt(e, t) { if (t.full) return null; var n = wt(e, t.from.line) && W(e, t.from.line).markedSpans, e = wt(e, t.to.line) && W(e, t.to.line).markedSpans; if (!n && !e) return null; var r = t.from.ch, i = t.to.ch, o = 0 == P(t.from, t.to), l = function (e, t, n) { var r; if (e) for (var i = 0; i < e.length; ++i) { var o, l = e[i], s = l.marker; !(null == l.from || (s.inclusiveLeft ? l.from <= t : l.from < t)) && (l.from != t || "bookmark" != s.type || n && l.marker.insertLeft) || (o = null == l.to || (s.inclusiveRight ? l.to >= t : l.to > t), (r = r || []).push(new Ut(s, l.from, o ? null : l.to))) } return r }(n, r, o), s = function (e, t, n) { var r; if (e) for (var i = 0; i < e.length; ++i) { var o, l = e[i], s = l.marker; !(null == l.to || (s.inclusiveRight ? l.to >= t : l.to > t)) && (l.from != t || "bookmark" != s.type || n && !l.marker.insertLeft) || (o = null == l.from || (s.inclusiveLeft ? l.from <= t : l.from < t), (r = r || []).push(new Ut(s, o ? null : l.from - t, null == l.to ? null : l.to - t))) } return r }(e, i, o), a = 1 == t.text.length, u = z(t.text).length + (a ? r : 0); if (l) for (var c = 0; c < l.length; ++c) { var h, d = l[c]; null == d.to && ((h = Vt(s, d.marker)) ? a && (d.to = null == h.to ? null : h.to + u) : d.to = r) } if (s) for (var f = 0; f < s.length; ++f) { var p = s[f]; null != p.to && (p.to += u), null == p.from ? Vt(l, p.marker) || (p.from = u, a && (l = l || []).push(p)) : (p.from += u, a && (l = l || []).push(p)) } l = l && jt(l), s && s != l && (s = jt(s)); var g = [l]; if (!a) { var m, v = t.text.length - 2; if (0 < v && l) for (var y = 0; y < l.length; ++y)null == l[y].to && (m = m || []).push(new Ut(l[y].marker, null, null)); for (var b = 0; b < v; ++b)g.push(m); g.push(s) } return g } function jt(e) { for (var t = 0; t < e.length; ++t) { var n = e[t]; null != n.from && n.from == n.to && !1 !== n.marker.clearWhenEmpty && e.splice(t--, 1) } return e.length ? e : null } function Xt(e) { var t = e.markedSpans; if (t) { for (var n = 0; n < t.length; ++n)t[n].marker.detachLine(e); e.markedSpans = null } } function Yt(e, t) { if (t) { for (var n = 0; n < t.length; ++n)t[n].marker.attachLine(e); e.markedSpans = t } } function $t(e) { return e.inclusiveLeft ? -1 : 0 } function _t(e) { return e.inclusiveRight ? 1 : 0 } function qt(e, t) { var n = e.lines.length - t.lines.length; if (0 != n) return n; var n = e.find(), r = t.find(), i = P(n.from, r.from) || $t(e) - $t(t); if (i) return -i; i = P(n.to, r.to) || _t(e) - _t(t); return i || t.id - e.id } function Zt(e, t) { var n, r = Gt && e.markedSpans; if (r) for (var i, o = 0; o < r.length; ++o)(i = r[o]).marker.collapsed && null == (t ? i.from : i.to) && (!n || qt(n, i.marker) < 0) && (n = i.marker); return n } function Qt(e) { return Zt(e, !0) } function Jt(e) { return Zt(e, !1) } function en(e, t, n, r, i) { var e = W(e, t), o = Gt && e.markedSpans; if (o) for (var l = 0; l < o.length; ++l) { var s = o[l]; if (s.marker.collapsed) { var a = s.marker.find(0), u = P(a.from, n) || $t(s.marker) - $t(i), c = P(a.to, r) || _t(s.marker) - _t(i); if (!(0 <= u && c <= 0 || u <= 0 && 0 <= c) && (u <= 0 && (s.marker.inclusiveRight && i.inclusiveLeft ? 0 <= P(a.to, n) : 0 < P(a.to, n)) || 0 <= u && (s.marker.inclusiveRight && i.inclusiveLeft ? P(a.from, r) <= 0 : P(a.from, r) < 0))) return 1 } } } function tn(e) { for (var t; t = Qt(e);)e = t.find(-1, !0).line; return e } function nn(e, t) { var e = W(e, t), n = tn(e); return e == n ? t : H(n) } function rn(e, t) { if (t > e.lastLine()) return t; var n, r = W(e, t); if (!on(e, r)) return t; for (; n = Jt(r);)r = n.find(1, !0).line; return H(r) + 1 } function on(e, t) { var n = Gt && t.markedSpans; if (n) for (var r, i = 0; i < n.length; ++i)if ((r = n[i]).marker.collapsed) { if (null == r.from) return !0; if (!r.marker.widgetNode && 0 == r.from && r.marker.inclusiveLeft && function e(t, n, r) { { var i; if (null == r.to) return i = r.marker.find(1, !0), e(t, i.line, Vt(i.line.markedSpans, r.marker)) } if (r.marker.inclusiveRight && r.to == n.text.length) return !0; for (var o = void 0, l = 0; l < n.markedSpans.length; ++l)if ((o = n.markedSpans[l]).marker.collapsed && !o.marker.widgetNode && o.from == r.to && (null == o.to || o.to != r.from) && (o.marker.inclusiveLeft || r.marker.inclusiveRight) && e(t, n, o)) return !0 }(e, t, r)) return !0 } } function ln(e) { for (var t = 0, n = (e = tn(e)).parent, r = 0; r < n.lines.length; ++r) { var i = n.lines[r]; if (i == e) break; t += i.height } for (var o = n.parent; o; o = (n = o).parent)for (var l = 0; l < o.children.length; ++l) { var s = o.children[l]; if (s == n) break; t += s.height } return t } function sn(e) { if (0 == e.height) return 0; for (var t, n = e.text.length, r = e; t = Qt(r);) { var i = t.find(0, !0), r = i.from.line; n += i.from.ch - i.to.ch } for (r = e; t = Jt(r);)var o = t.find(0, !0), n = (n -= r.text.length - o.from.ch) + ((r = o.to.line).text.length - o.to.ch); return n } function an(e) { var n = e.display, e = e.doc; n.maxLine = W(e, e.first), n.maxLineLength = sn(n.maxLine), n.maxLineChanged = !0, e.iter(function (e) { var t = sn(e); t > n.maxLineLength && (n.maxLineLength = t, n.maxLine = e) }) } var un = function (e, t, n) { this.text = e, Yt(this, t), this.height = n ? n(this) : 1 }; un.prototype.lineNo = function () { return H(this) }, $e(un); var cn = {}, hn = {}; function dn(e, t) { if (!e || /^\s*$/.test(e)) return null; t = t.addModeClass ? hn : cn; return t[e] || (t[e] = e.replace(/\S+/g, "cm-$&")) } function fn(e, t) { var n = ne("span", null, null, x ? "padding-right: .1px" : null), r = { pre: ne("pre", [n], "CodeMirror-line"), content: n, col: 0, pos: 0, cm: e, trailingSpace: !1, splitSpaces: e.getOption("lineWrapping") }; t.measure = {}; for (var i = 0; i <= (t.rest ? t.rest.length : 0); i++) { var o = i ? t.rest[i - 1] : t.line, l = void 0, l = (r.pos = 0, r.addToken = gn, function (e) { if (null != tt) return tt; var t = y(e, document.createTextNode("AخA")), n = le(t, 0, 1).getBoundingClientRect(), t = le(t, 1, 2).getBoundingClientRect(); return te(e), n && n.left != n.right && (tt = t.right - n.right < 3) }(e.display.measure) && (l = Ve(o, e.doc.direction)) && (r.addToken = function (h, d) { return function (e, t, n, r, i, o, l) { n = n ? n + " cm-force-border" : "cm-force-border"; for (var s = e.pos, a = s + t.length; ;) { for (var u = void 0, c = 0; c < d.length && !((u = d[c]).to > s && u.from <= s); c++); if (u.to >= a) return h(e, t, n, r, i, o, l); h(e, t.slice(0, u.to - s), n, r, null, o, l), r = null, t = t.slice(u.to - s), s = u.to } } }(r.addToken, l)), r.map = [], t != e.display.externalMeasured && H(o)); !function (e, t, n) { var r = e.markedSpans, i = e.text, o = 0; if (r) for (var l, s, a, u, c, h, d, f = i.length, p = 0, g = 1, m = "", v = 0; ;) { if (v == p) { a = u = c = s = "", h = d = null, v = 1 / 0; for (var y = [], b = void 0, w = 0; w < r.length; ++w) { var x = r[w], C = x.marker; if ("bookmark" == C.type && x.from == p && C.widgetNode) y.push(C); else if (x.from <= p && (null == x.to || x.to > p || C.collapsed && x.to == p && x.from == p)) { if (null != x.to && x.to != p && v > x.to && (v = x.to, u = ""), C.className && (a += " " + C.className), C.css && (s = (s ? s + ";" : "") + C.css), C.startStyle && x.from == p && (c += " " + C.startStyle), C.endStyle && x.to == v && (b = b || []).push(C.endStyle, x.to), C.title && ((d = d || {}).title = C.title), C.attributes) for (var S in C.attributes) (d = d || {})[S] = C.attributes[S]; C.collapsed && (!h || qt(h.marker, C) < 0) && (h = x) } else x.from > p && v > x.from && (v = x.from) } if (b) for (var L = 0; L < b.length; L += 2)b[L + 1] == v && (u += " " + b[L]); if (!h || h.from == p) for (var k = 0; k < y.length; ++k)mn(t, 0, y[k]); if (h && (h.from || 0) == p) { if (mn(t, (null == h.to ? f + 1 : h.to) - p, h.marker, null == h.from), null == h.to) return; h.to == p && (h = !1) } } if (f <= p) break; for (var T = Math.min(f, v); ;) { if (m) { var M, N = p + m.length; if (h || (M = T < N ? m.slice(0, T - p) : m, t.addToken(t, M, l ? l + a : a, c, p + M.length == v ? u : "", s, d)), T <= N) { m = m.slice(T - p), p = T; break } p = N, c = "" } m = i.slice(o, o = n[g++]), l = dn(n[g++], t.cm.options) } } else for (var O = 1; O < n.length; O += 2)t.addToken(t, i.slice(o, o = n[O]), dn(n[O + 1], t.cm.options)) }(o, r, Dt(e, o, l)), o.styleClasses && (o.styleClasses.bgClass && (r.bgClass = oe(o.styleClasses.bgClass, r.bgClass || "")), o.styleClasses.textClass && (r.textClass = oe(o.styleClasses.textClass, r.textClass || ""))), 0 == r.map.length && r.map.push(0, 0, r.content.appendChild((l = e.display.measure, o = void 0, null == et && (o = M("span", "​"), y(l, M("span", [o, document.createTextNode("x")])), 0 != l.firstChild.offsetHeight && (et = o.offsetWidth <= 1 && 2 < o.offsetHeight && !(w && v < 8))), (l = et ? M("span", "​") : M("span", " ", null, "display: inline-block; width: 1px; margin-right: -1px")).setAttribute("cm-text", ""), l))), 0 == i ? (t.measure.map = r.map, t.measure.cache = {}) : ((t.measure.maps || (t.measure.maps = [])).push(r.map), (t.measure.caches || (t.measure.caches = [])).push({})) } return x && (n = r.content.lastChild, (/\bcm-tab\b/.test(n.className) || n.querySelector && n.querySelector(".cm-tab")) && (r.content.className = "cm-tab-wrap-hack")), O(e, "renderLine", e, t.line, r.pre), r.pre.className && (r.textClass = oe(r.pre.className, r.textClass || "")), r } function pn(e) { var t = M("span", "•", "cm-invalidchar"); return t.title = "\\u" + e.charCodeAt(0).toString(16), t.setAttribute("aria-label", t.title), t } function gn(e, t, n, r, i, o, l) { if (t) { var s = e.splitSpaces ? function (e, t) { if (1 < e.length && !/  /.test(e)) return e; for (var n = t, r = "", i = 0; i < e.length; i++) { var o = e.charAt(i); " " != o || !n || i != e.length - 1 && 32 != e.charCodeAt(i + 1) || (o = " "), r += o, n = " " == o } return r }(t, e.trailingSpace) : t, a = e.cm.state.specialChars, u = !1; if (a.test(t)) for (var c = document.createDocumentFragment(), h = 0; ;) { a.lastIndex = h; var d = a.exec(t), f = d ? d.index - h : t.length - h; if (f && (p = document.createTextNode(s.slice(h, h + f)), w && v < 9 ? c.appendChild(M("span", [p])) : c.appendChild(p), e.map.push(e.pos, e.pos + f, p), e.col += f, e.pos += f), !d) break; h += 1 + f; var p = void 0; "\t" == d[0] ? (f = (f = e.cm.options.tabSize) - e.col % f, (p = c.appendChild(M("span", Ce(f), "cm-tab"))).setAttribute("role", "presentation"), p.setAttribute("cm-text", "\t"), e.col += f) : ("\r" == d[0] || "\n" == d[0] ? (p = c.appendChild(M("span", "\r" == d[0] ? "␍" : "␤", "cm-invalidchar"))).setAttribute("cm-text", d[0]) : ((p = e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text", d[0]), w && v < 9 ? c.appendChild(M("span", [p])) : c.appendChild(p)), e.col += 1), e.map.push(e.pos, e.pos + 1, p), e.pos++ } else e.col += t.length, c = document.createTextNode(s), e.map.push(e.pos, e.pos + t.length, c), w && v < 9 && (u = !0), e.pos += t.length; if (e.trailingSpace = 32 == s.charCodeAt(t.length - 1), n || r || i || u || o || l) { var u = n || "", g = (r && (u += r), i && (u += i), M("span", [c], u, o)); if (l) for (var m in l) l.hasOwnProperty(m) && "style" != m && "class" != m && g.setAttribute(m, l[m]); return e.content.appendChild(g) } e.content.appendChild(c) } } function mn(e, t, n, r) { var i = !r && n.widgetNode; i && e.map.push(e.pos, e.pos + t, i), !r && e.cm.display.input.needsContentAttribute && (i = i || e.content.appendChild(document.createElement("span"))).setAttribute("cm-marker", n.id), i && (e.cm.display.input.setUneditable(i), e.content.appendChild(i)), e.pos += t, e.trailingSpace = !1 } function vn(e, t, n) { this.line = t, this.rest = function (e) { for (var t, n; t = Jt(e);)e = t.find(1, !0).line, (n = n || []).push(e); return n }(t), this.size = this.rest ? H(z(this.rest)) - n + 1 : 1, this.node = this.text = null, this.hidden = on(e, t) } function yn(e, t, n) { for (var r = [], i = t; i < n; i = l) { var o = new vn(e.doc, W(e.doc, i), i), l = i + o.size; r.push(o) } return r } var bn = null; var wn = null; function b(e, t) { var n = je(e, t); if (n.length) for (var r, i = Array.prototype.slice.call(arguments, 2), o = (bn ? r = bn.delayedCallbacks : wn ? r = wn : (r = wn = [], setTimeout(xn, 0)), 0); o < n.length; ++o)!function (e) { r.push(function () { return n[e].apply(null, i) }) }(o) } function xn() { var e = wn; wn = null; for (var t = 0; t < e.length; ++t)e[t]() } function Cn(e, t, n, r) { for (var i = 0; i < t.changes.length; i++) { var o = t.changes[i]; if ("text" == o) { u = a = s = l = void 0; var l = e, s = t, a = s.text.className, u = Ln(l, s); s.text == s.node && (s.node = u.pre), s.text.parentNode.replaceChild(u.pre, s.text), s.text = u.pre, u.bgClass != s.bgClass || u.textClass != s.textClass ? (s.bgClass = u.bgClass, s.textClass = u.textClass, kn(l, s)) : a && (s.text.className = a) } else if ("gutter" == o) Tn(e, t, n, r); else if ("class" == o) kn(e, t); else if ("widget" == o) { f = d = h = l = c = u = void 0; var u = e, c = t, l = r; c.alignable && (c.alignable = null); for (var h = J("CodeMirror-linewidget"), d = c.node.firstChild, f = void 0; d; d = f)f = d.nextSibling, h.test(d.className) && c.node.removeChild(d); Mn(u, c, l) } } t.changes = null } function Sn(e) { return e.node == e.text && (e.node = M("div", null, null, "position: relative"), e.text.parentNode && e.text.parentNode.replaceChild(e.node, e.text), e.node.appendChild(e.text), w && v < 8 && (e.node.style.zIndex = 2)), e.node } function Ln(e, t) { var n = e.display.externalMeasured; return n && n.line == t.line ? (e.display.externalMeasured = null, t.measure = n.measure, n.built) : fn(e, t) } function kn(e, t) { e = e, (i = (n = t).bgClass ? n.bgClass + " " + (n.line.bgClass || "") : n.line.bgClass) && (i += " CodeMirror-linebackground"), n.background ? i ? n.background.className = i : (n.background.parentNode.removeChild(n.background), n.background = null) : i && (r = Sn(n), n.background = r.insertBefore(M("div", null, i), r.firstChild), e.display.input.setUneditable(n.background)), t.line.wrapClass ? Sn(t).className = t.line.wrapClass : t.node != t.text && (t.node.className = ""); var n, r, i = t.textClass ? t.textClass + " " + (t.line.textClass || "") : t.line.textClass; t.text.className = i || "" } function Tn(e, t, n, r) { t.gutter && (t.node.removeChild(t.gutter), t.gutter = null), t.gutterBackground && (t.node.removeChild(t.gutterBackground), t.gutterBackground = null), t.line.gutterClass && (o = Sn(t), t.gutterBackground = M("div", null, "CodeMirror-gutter-background " + t.line.gutterClass, "left: " + (e.options.fixedGutter ? r.fixedPos : -r.gutterTotalWidth) + "px; width: " + r.gutterTotalWidth + "px"), e.display.input.setUneditable(t.gutterBackground), o.insertBefore(t.gutterBackground, t.text)); var i = t.line.gutterMarkers; if (e.options.lineNumbers || i) { var o = Sn(t), l = t.gutter = M("div", null, "CodeMirror-gutter-wrapper", "left: " + (e.options.fixedGutter ? r.fixedPos : -r.gutterTotalWidth) + "px"); if (l.setAttribute("aria-hidden", "true"), e.display.input.setUneditable(l), o.insertBefore(l, t.text), t.line.gutterClass && (l.className += " " + t.line.gutterClass), !e.options.lineNumbers || i && i["CodeMirror-linenumbers"] || (t.lineNumber = l.appendChild(M("div", xt(e.options, n), "CodeMirror-linenumber CodeMirror-gutter-elt", "left: " + r.gutterLeft["CodeMirror-linenumbers"] + "px; width: " + e.display.lineNumInnerWidth + "px"))), i) for (var s = 0; s < e.display.gutterSpecs.length; ++s) { var a = e.display.gutterSpecs[s].className, u = i.hasOwnProperty(a) && i[a]; u && l.appendChild(M("div", [u], "CodeMirror-gutter-elt", "left: " + r.gutterLeft[a] + "px; width: " + r.gutterWidth[a] + "px")) } } } function Mn(e, t, n) { if (Nn(e, t.line, t, n, !0), t.rest) for (var r = 0; r < t.rest.length; r++)Nn(e, t.rest[r], t, n, !1) } function Nn(e, t, n, r, i) { if (t.widgets) for (var o = Sn(n), l = 0, s = t.widgets; l < s.length; ++l) { var a = s[l], u = M("div", [a.node], "CodeMirror-linewidget" + (a.className ? " " + a.className : "")), c = (a.handleMouseEvents || u.setAttribute("cm-ignore-events", "true"), d = f = d = h = c = void 0, a), h = u, d = n, f = r; c.noHScroll && ((d.alignable || (d.alignable = [])).push(h), d = f.wrapperWidth, h.style.left = f.fixedPos + "px", c.coverGutter || (d -= f.gutterTotalWidth, h.style.paddingLeft = f.gutterTotalWidth + "px"), h.style.width = d + "px"), c.coverGutter && (h.style.zIndex = 5, h.style.position = "relative", c.noHScroll || (h.style.marginLeft = -f.gutterTotalWidth + "px")), e.display.input.setUneditable(u), i && a.above ? o.insertBefore(u, n.gutter || n.text) : o.appendChild(u), b(a, "redraw") } } function On(e) { if (null != e.height) return e.height; var t, n = e.doc.cm; return n ? (re(document.body, e.node) || (t = "position: relative;", e.coverGutter && (t += "margin-left: -" + n.display.gutters.offsetWidth + "px;"), e.noHScroll && (t += "width: " + n.display.wrapper.clientWidth + "px;"), y(n.display.measure, M("div", [e.node], null, t))), e.height = e.node.parentNode.offsetHeight) : 0 } function An(e, t) { for (var n = Qe(t); n != e.wrapper; n = n.parentNode)if (!n || 1 == n.nodeType && "true" == n.getAttribute("cm-ignore-events") || n.parentNode == e.sizer && n != e.mover) return 1 } function Dn(e) { return e.lineSpace.offsetTop } function Wn(e) { return e.mover.offsetHeight - e.lineSpace.offsetHeight } function Hn(e) { if (e.cachedPaddingH) return e.cachedPaddingH; var t = y(e.measure, M("pre", "x", "CodeMirror-line-like")), t = window.getComputedStyle ? window.getComputedStyle(t) : t.currentStyle, t = { left: parseInt(t.paddingLeft), right: parseInt(t.paddingRight) }; return isNaN(t.left) || isNaN(t.right) || (e.cachedPaddingH = t), t } function Fn(e) { return ge - e.display.nativeBarWidth } function Pn(e) { return e.display.scroller.clientWidth - Fn(e) - e.display.barWidth } function En(e) { return e.display.scroller.clientHeight - Fn(e) - e.display.barHeight } function Rn(e, t, n) { if (e.line == t) return { map: e.measure.map, cache: e.measure.cache }; if (e.rest) { for (var r = 0; r < e.rest.length; r++)if (e.rest[r] == t) return { map: e.measure.maps[r], cache: e.measure.caches[r] }; for (var i = 0; i < e.rest.length; i++)if (H(e.rest[i]) > n) return { map: e.measure.maps[i], cache: e.measure.caches[i], before: !0 } } } function zn(e, t, n, r) { return Gn(e, Bn(e, t), n, r) } function In(e, t) { if (t >= e.display.viewFrom && t < e.display.viewTo) return e.display.view[mr(e, t)]; e = e.display.externalMeasured; return e && t >= e.lineN && t < e.lineN + e.size ? e : void 0 } function Bn(e, t) { var n, r, i = H(t), o = In(e, i), e = (o && !o.text ? o = null : o && o.changes && (Cn(e, o, i, hr(e)), e.curOp.forceUpdate = !0), o || (e = e, r = H(n = tn(n = t)), (n = e.display.externalMeasured = new vn(e.doc, n, r)).lineN = r, r = n.built = fn(e, n), n.text = r.pre, y(e.display.lineMeasure, r.pre), o = n), Rn(o, t, i)); return { line: t, view: o, rect: null, map: e.map, cache: e.cache, before: e.before, hasHeights: !1 } } function Gn(e, t, n, r, i) { var o, l = (n = t.before ? -1 : n) + (r || ""); if (t.cache.hasOwnProperty(l)) o = t.cache[l]; else { if (t.rect || (t.rect = t.view.text.getBoundingClientRect()), !t.hasHeights) { var s = e, a = t.view, u = t.rect, c = s.options.lineWrapping, s = c && Pn(s); if (!a.measure.heights || c && a.measure.width != s) { var h = a.measure.heights = []; if (c) { a.measure.width = s; for (var d = a.text.firstChild.getClientRects(), f = 0; f < d.length - 1; f++) { var p = d[f], g = d[f + 1]; 2 < Math.abs(p.bottom - g.bottom) && h.push((p.bottom + g.top) / 2 - u.top) } } h.push(u.bottom - u.top) } t.hasHeights = !0 } (o = function (e, t, n, r) { var i, o = Kn(t.map, n, r), l = o.node, s = o.start, a = o.end, u = o.collapse; if (3 == l.nodeType) { for (var c = 0; c < 4; c++) { for (; s && De(t.line.text.charAt(o.coverStart + s));)--s; for (; o.coverStart + a < o.coverEnd && De(t.line.text.charAt(o.coverStart + a));)++a; if ((i = w && v < 9 && 0 == s && a == o.coverEnd - o.coverStart ? l.parentNode.getBoundingClientRect() : function (e, t) { var n = Vn; if ("left" == t) for (var r = 0; r < e.length && (n = e[r]).left == n.right; r++); else for (var i = e.length - 1; 0 <= i && (n = e[i]).left == n.right; i--); return n }(le(l, s, a).getClientRects(), r)).left || i.right || 0 == s) break; a = s, s -= 1, u = "right" } w && v < 11 && (i = function (e, t) { if (!window.screen || null == screen.logicalXDPI || screen.logicalXDPI == screen.deviceXDPI || !function (e) { if (null != lt) return lt; var t = (e = y(e, M("span", "x"))).getBoundingClientRect(), e = le(e, 0, 1).getBoundingClientRect(); return lt = 1 < Math.abs(t.left - e.left) }(e)) return t; var e = screen.logicalXDPI / screen.deviceXDPI, n = screen.logicalYDPI / screen.deviceYDPI; return { left: t.left * e, right: t.right * e, top: t.top * n, bottom: t.bottom * n } }(e.display.measure, i)) } else 0 < s && (u = r = "right"), i = e.options.lineWrapping && 1 < (n = l.getClientRects()).length ? n["right" == r ? n.length - 1 : 0] : l.getBoundingClientRect(); !(w && v < 9) || s || i && (i.left || i.right) || (n = l.parentNode.getClientRects()[0], i = n ? { left: n.left, right: n.left + cr(e.display), top: n.top, bottom: n.bottom } : Vn); for (var n = i.top - t.rect.top, h = i.bottom - t.rect.top, d = (n + h) / 2, f = t.view.measure.heights, p = 0; p < f.length - 1 && !(d < f[p]); p++); var g = p ? f[p - 1] : 0, m = f[p], g = { left: ("right" == u ? i.right : i.left) - t.rect.left, right: ("left" == u ? i.left : i.right) - t.rect.left, top: g, bottom: m }; i.left || i.right || (g.bogus = !0); e.options.singleCursorHeightPerLine || (g.rtop = n, g.rbottom = h); return g }(e, t, n, r)).bogus || (t.cache[l] = o) } return { left: o.left, right: o.right, top: i ? o.rtop : o.top, bottom: i ? o.rbottom : o.bottom } } var Un, Vn = { left: 0, right: 0, top: 0, bottom: 0 }; function Kn(e, t, n) { for (var r, i, o, l, s, a, u = 0; u < e.length; u += 3)if (s = e[u], a = e[u + 1], t < s ? (i = 0, o = 1, l = "left") : t < a ? o = (i = t - s) + 1 : (u == e.length - 3 || t == a && e[u + 3] > t) && (i = (o = a - s) - 1, a <= t && (l = "right")), null != i) { if (r = e[u + 2], s == a && n == (r.insertLeft ? "left" : "right") && (l = n), "left" == n && 0 == i) for (; u && e[u - 2] == e[u - 3] && e[u - 1].insertLeft;)r = e[2 + (u -= 3)], l = "left"; if ("right" == n && i == a - s) for (; u < e.length - 3 && e[u + 3] == e[u + 4] && !e[u + 5].insertLeft;)r = e[(u += 3) + 2], l = "right"; break } return { node: r, start: i, end: o, collapse: l, coverStart: s, coverEnd: a } } function jn(e) { if (e.measure && (e.measure.cache = {}, e.measure.heights = null, e.rest)) for (var t = 0; t < e.rest.length; t++)e.measure.caches[t] = {} } function Xn(e) { e.display.externalMeasure = null, te(e.display.lineMeasure); for (var t = 0; t < e.display.view.length; t++)jn(e.display.view[t]) } function Yn(e) { Xn(e), e.display.cachedCharWidth = e.display.cachedTextHeight = e.display.cachedPaddingH = null, e.options.lineWrapping || (e.display.maxLineChanged = !0), e.display.lineNumChars = null } function $n(e) { return m && $ ? -(e.body.getBoundingClientRect().left - parseInt(getComputedStyle(e.body).marginLeft)) : e.defaultView.pageXOffset || (e.documentElement || e.body).scrollLeft } function _n(e) { return m && $ ? -(e.body.getBoundingClientRect().top - parseInt(getComputedStyle(e.body).marginTop)) : e.defaultView.pageYOffset || (e.documentElement || e.body).scrollTop } function qn(e) { var t = tn(e).widgets, n = 0; if (t) for (var r = 0; r < t.length; ++r)t[r].above && (n += On(t[r])); return n } function Zn(e, t, n, r, i) { if (i || (i = qn(t), n.top += i, n.bottom += i), "line" == r) return n; r = r || "local"; i = ln(t); return "local" == r ? i += Dn(e.display) : i -= e.display.viewOffset, "page" != r && "window" != r || (i += (t = e.display.lineSpace.getBoundingClientRect()).top + ("window" == r ? 0 : _n(ae(e))), t = t.left + ("window" == r ? 0 : $n(ae(e))), n.left += t, n.right += t), n.top += i, n.bottom += i, n } function Qn(e, t, n) { if ("div" == n) return t; var r = t.left, t = t.top, n = ("page" == n ? (r -= $n(ae(e)), t -= _n(ae(e))) : "local" != n && n || (r += (n = e.display.sizer.getBoundingClientRect()).left, t += n.top), e.display.lineSpace.getBoundingClientRect()); return { left: r - n.left, top: t - n.top } } function Jn(e, t, n, r, i) { return Zn(e, r = r || W(e.doc, t.line), zn(e, r, t.ch, i), n) } function er(n, e, r, i, o, l) { function s(e, t) { e = Gn(n, o, e, t ? "right" : "left", l); return t ? e.left = e.right : e.right = e.left, Zn(n, i, e, r) } i = i || W(n.doc, e.line), o = o || Bn(n, i); var a = Ve(i, n.doc.direction), t = e.ch, e = e.sticky; if (t >= i.text.length ? (t = i.text.length, e = "before") : t <= 0 && (t = 0, e = "after"), !a) return s("before" == e ? t - 1 : t, "before" == e); function u(e, t, n) { return s(n ? e - 1 : e, 1 == a[t].level != n) } var c = Pe(a, t, e), h = Fe, c = u(t, c, "before" == e); return null != h && (c.other = u(t, h, "before" != e)), c } function tr(e, t) { var n = 0, t = (t = E(e.doc, t), e.options.lineWrapping || (n = cr(e.display) * t.ch), W(e.doc, t.line)), e = ln(t) + Dn(e.display); return { left: n, right: n, top: e, bottom: e + t.height } } function nr(e, t, n, r, i) { e = F(e, t, n); return e.xRel = i, r && (e.outside = r), e } function rr(e, t, n) { var r = e.doc; if ((n += e.display.viewOffset) < 0) return nr(r.first, 0, null, -1, -1); var i = bt(r, n), o = r.first + r.size - 1; if (o < i) return nr(r.first + r.size - 1, W(r, o).text.length, null, 1, 1); t < 0 && (t = 0); for (var l = W(r, i); ;) { var s = function (n, e, t, r, i) { i -= ln(e); var o = Bn(n, e), l = qn(e), s = 0, a = e.text.length, u = !0, c = Ve(e, n.doc.direction); c && (c = (n.options.lineWrapping ? ar : sr)(n, e, t, o, c, r, i), u = 1 != c.level, s = u ? c.from : c.to - 1, a = u ? c.to : c.from - 1); var h = null, d = null, c = He(function (e) { var t = Gn(n, o, e); return t.top += l, t.bottom += l, lr(t, r, i, !1) && (t.top <= i && t.left <= r && (h = e, d = t), 1) }, s, a), f = !1; { var p, g; d ? (p = r - d.left < d.right - r, c = h + ((g = p == u) ? 0 : 1), g = g ? "after" : "before", p = p ? d.left : d.right) : (u || c != a && c != s || c++, g = 0 == c || c != e.text.length && Gn(n, o, c - (u ? 1 : 0)).bottom + l <= i == u ? "after" : "before", a = er(n, F(t, c, g), "line", e, o), p = a.left, f = i < a.top ? -1 : i >= a.bottom ? 1 : 0) } return c = We(e.text, c, 1), nr(t, c, g, f, r - p) }(e, l, i, t, n), a = function (e, t) { var n, r = Gt && e.markedSpans; if (r) for (var i = 0; i < r.length; ++i) { var o = r[i]; o.marker.collapsed && (null == o.from || o.from < t) && (null == o.to || o.to > t) && (!n || qt(n, o.marker) < 0) && (n = o.marker) } return n }(l, s.ch + (0 < s.xRel || 0 < s.outside ? 1 : 0)); if (!a) return s; s = a.find(1); if (s.line == i) return s; l = W(r, i = s.line) } } function ir(t, e, n, r) { r -= qn(e); var e = e.text.length, i = He(function (e) { return Gn(t, n, e - 1).bottom <= r }, e, 0); return { begin: i, end: He(function (e) { return Gn(t, n, e).top > r }, i, e) } } function or(e, t, n, r) { return ir(e, t, n = n || Bn(e, t), Zn(e, t, Gn(e, n, r), "line").top) } function lr(e, t, n, r) { return !(e.bottom <= n) && (e.top > n || (r ? e.left : e.right) > t) } function sr(n, r, i, o, l, s, a) { var e, t = He(function (e) { var e = l[e], t = 1 != e.level; return lr(er(n, F(i, t ? e.to : e.from, t ? "before" : "after"), "line", r, o), s, a, !0) }, 0, l.length - 1), u = l[t]; return 0 < t && (e = 1 != u.level, lr(e = er(n, F(i, e ? u.from : u.to, e ? "after" : "before"), "line", r, o), s, a, !0) && e.top > a && (u = l[t - 1])), u } function ar(e, t, n, r, i, o, l) { for (var l = ir(e, t, r, l), s = l.begin, a = l.end, u = (/\s/.test(t.text.charAt(a - 1)) && a--, null), c = null, h = 0; h < i.length; h++) { var d, f = i[h]; f.from >= a || f.to <= s || (d = (d = Gn(e, r, 1 != f.level ? Math.min(a, f.to) - 1 : Math.max(s, f.from)).right) < o ? o - d + 1e9 : d - o, (!u || d < c) && (u = f, c = d)) } return u = (u = (u = u || i[i.length - 1]).from < s ? { from: s, to: u.to, level: u.level } : u).to > a ? { from: u.from, to: a, level: u.level } : u } function ur(e) { if (null != e.cachedTextHeight) return e.cachedTextHeight; if (null == Un) { Un = M("pre", null, "CodeMirror-line-like"); for (var t = 0; t < 49; ++t)Un.appendChild(document.createTextNode("x")), Un.appendChild(M("br")); Un.appendChild(document.createTextNode("x")) } y(e.measure, Un); var n = Un.offsetHeight / 50; return 3 < n && (e.cachedTextHeight = n), te(e.measure), n || 1 } function cr(e) { if (null != e.cachedCharWidth) return e.cachedCharWidth; var t = M("span", "xxxxxxxxxx"), n = M("pre", [t], "CodeMirror-line-like"), n = (y(e.measure, n), t.getBoundingClientRect()), t = (n.right - n.left) / 10; return 2 < t && (e.cachedCharWidth = t), t || 10 } function hr(e) { for (var t = e.display, n = {}, r = {}, i = t.gutters.clientLeft, o = t.gutters.firstChild, l = 0; o; o = o.nextSibling, ++l) { var s = e.display.gutterSpecs[l].className; n[s] = o.offsetLeft + o.clientLeft + i, r[s] = o.clientWidth } return { fixedPos: dr(t), gutterTotalWidth: t.gutters.offsetWidth, gutterLeft: n, gutterWidth: r, wrapperWidth: t.wrapper.clientWidth } } function dr(e) { return e.scroller.getBoundingClientRect().left - e.sizer.getBoundingClientRect().left } function fr(r) { var i = ur(r.display), o = r.options.lineWrapping, l = o && Math.max(5, r.display.scroller.clientWidth / cr(r.display) - 3); return function (e) { if (on(r.doc, e)) return 0; var t = 0; if (e.widgets) for (var n = 0; n < e.widgets.length; n++)e.widgets[n].height && (t += e.widgets[n].height); return o ? t + (Math.ceil(e.text.length / l) || 1) * i : t + i } } function pr(e) { var t = e.doc, n = fr(e); t.iter(function (e) { var t = n(e); t != e.height && yt(e, t) }) } function gr(e, t, n, r) { var i = e.display; if (!n && "true" == Qe(t).getAttribute("cm-not-content")) return null; var o, l, n = i.lineSpace.getBoundingClientRect(); try { o = t.clientX - n.left, l = t.clientY - n.top } catch (e) { return null } i = rr(e, o, l); return r && 0 < i.xRel && (t = W(e.doc, i.line).text).length == i.ch && (n = S(t, t.length, e.options.tabSize) - t.length, i = F(i.line, Math.max(0, Math.round((o - Hn(e.display).left) / cr(e.display)) - n))), i } function mr(e, t) { if (t >= e.display.viewTo) return null; if ((t -= e.display.viewFrom) < 0) return null; for (var n = e.display.view, r = 0; r < n.length; r++)if ((t -= n[r].size) < 0) return r } function R(e, t, n, r) { null == t && (t = e.doc.first), null == n && (n = e.doc.first + e.doc.size); var i, o = e.display, l = ((r = r || 0) && n < o.viewTo && (null == o.updateLineNumbers || o.updateLineNumbers > t) && (o.updateLineNumbers = t), e.curOp.viewChanged = !0, t >= o.viewTo ? Gt && nn(e.doc, t) < o.viewTo && yr(e) : n <= o.viewFrom ? Gt && rn(e.doc, n + r) > o.viewFrom ? yr(e) : (o.viewFrom += r, o.viewTo += r) : t <= o.viewFrom && n >= o.viewTo ? yr(e) : t <= o.viewFrom ? (l = br(e, n, n + r, 1)) ? (o.view = o.view.slice(l.index), o.viewFrom = l.lineN, o.viewTo += r) : yr(e) : n >= o.viewTo ? (l = br(e, t, t, -1)) ? (o.view = o.view.slice(0, l.index), o.viewTo = l.lineN) : yr(e) : (l = br(e, t, t, -1), i = br(e, n, n + r, 1), l && i ? (o.view = o.view.slice(0, l.index).concat(yn(e, l.lineN, i.lineN)).concat(o.view.slice(i.index)), o.viewTo += r) : yr(e)), o.externalMeasured); l && (n < l.lineN ? l.lineN += r : t < l.lineN + l.size && (o.externalMeasured = null)) } function vr(e, t, n) { e.curOp.viewChanged = !0; var r = e.display, i = e.display.externalMeasured; i && t >= i.lineN && t < i.lineN + i.size && (r.externalMeasured = null), t < r.viewFrom || t >= r.viewTo || null != (i = r.view[mr(e, t)]).node && -1 == L(r = i.changes || (i.changes = []), n) && r.push(n) } function yr(e) { e.display.viewFrom = e.display.viewTo = e.doc.first, e.display.view = [], e.display.viewOffset = 0 } function br(e, t, n, r) { var i, o = mr(e, t), l = e.display.view; if (!Gt || n == e.doc.first + e.doc.size) return { index: o, lineN: n }; for (var s = e.display.viewFrom, a = 0; a < o; a++)s += l[a].size; if (s != t) { if (0 < r) { if (o == l.length - 1) return null; i = s + l[o].size - t, o++ } else i = s - t; t += i, n += i } for (; nn(e.doc, n) != n;) { if (o == (r < 0 ? 0 : l.length - 1)) return null; n += r * l[o - (r < 0 ? 1 : 0)].size, o += r } return { index: o, lineN: n } } function wr(e) { for (var t = e.display.view, n = 0, r = 0; r < t.length; r++) { var i = t[r]; i.hidden || i.node && !i.changes || ++n } return n } function xr(e) { e.display.input.showSelection(e.display.input.prepareSelection()) } function Cr(e, t) { void 0 === t && (t = !0); var n = e.doc, r = {}, i = r.cursors = document.createDocumentFragment(), o = r.selection = document.createDocumentFragment(), l = e.options.$customCursor; l && (t = !0); for (var s, a, u, c = 0; c < n.sel.ranges.length; c++)!t && c == n.sel.primIndex || ((s = n.sel.ranges[c]).from().line >= e.display.viewTo || s.to().line < e.display.viewFrom || (a = s.empty(), l ? (u = l(e, s)) && Sr(e, u, i) : (a || e.options.showCursorWhenSelecting) && Sr(e, s.head, i), a || function (i, e, t) { var n = i.display, o = i.doc, l = document.createDocumentFragment(), r = Hn(i.display), S = r.left, L = Math.max(n.sizerWidth, Pn(i) - n.sizer.offsetLeft) - r.right, k = "ltr" == o.direction; function T(e, t, n, r) { t < 0 && (t = 0), t = Math.round(t), r = Math.round(r), l.appendChild(M("div", null, "CodeMirror-selected", "position: absolute; left: " + e + "px;\n                             top: " + t + "px; width: " + (null == n ? L - e : n) + "px;\n                             height: " + (r - t) + "px")) } function s(n, g, m) { var v, y, r = W(o, n), b = r.text.length; function w(e, t) { return Jn(i, F(n, e), "div", r, t) } function x(e, t, n) { e = or(i, r, null, e), t = "ltr" == t == ("after" == n) ? "left" : "right"; return w("after" == n ? e.begin : e.end - (/\s/.test(r.text.charAt(e.end - 1)) ? 2 : 1), t)[t] } var C = Ve(r, o.direction); return function (e, t, n, r) { if (!e) return r(t, n, "ltr", 0); for (var i = !1, o = 0; o < e.length; ++o) { var l = e[o]; (l.from < n && l.to > t || t == n && l.to == t) && (r(Math.max(l.from, t), Math.min(l.to, n), 1 == l.level ? "rtl" : "ltr", o), i = !0) } i || r(t, n, "ltr") }(C, g || 0, null == m ? b : m, function (e, t, n, r) { var i, o, l, s, a, u = "ltr" == n, c = w(e, u ? "left" : "right"), h = w(t - 1, u ? "right" : "left"), d = null == g && 0 == e, f = null == m && t == b, p = 0 == r, r = !C || r == C.length - 1; h.top - c.top <= 3 ? (i = (k ? d : f) && p ? S : (u ? c : h).left, a = (k ? f : d) && r ? L : (u ? h : c).right, T(i, c.top, a - i, c.bottom)) : (a = u ? (o = k && d && p ? S : c.left, l = k ? L : x(e, n, "before"), s = k ? S : x(t, n, "after"), k && f && r ? L : h.right) : (o = k ? x(e, n, "before") : S, l = !k && d && p ? L : c.right, s = !k && f && r ? S : h.left, k ? x(t, n, "after") : L), T(o, c.top, l - o, c.bottom), c.bottom < h.top && T(S, c.bottom, null, h.top), T(s, h.top, a - s, h.bottom)), (!v || Lr(c, v) < 0) && (v = c), Lr(h, v) < 0 && (v = h), (!y || Lr(c, y) < 0) && (y = c), Lr(h, y) < 0 && (y = h) }), { start: v, end: y } } n = e.from(), r = e.to(); { var a; n.line == r.line ? s(n.line, n.ch, r.ch) : (e = W(o, n.line), a = W(o, r.line), a = tn(e) == tn(a), n = s(n.line, n.ch, a ? e.text.length + 1 : null).end, e = s(r.line, a ? 0 : null, r.ch).start, a && (n.top < e.top - 2 ? (T(n.right, n.top, null, n.bottom), T(S, e.top, e.left, e.bottom)) : T(n.right, n.top, e.left - n.right, n.bottom)), n.bottom < e.top && T(S, n.bottom, null, e.top)) } t.appendChild(l) }(e, s, o))); return r } function Sr(e, t, n) { var r = er(e, t, "div", null, null, !e.options.singleCursorHeightPerLine), i = n.appendChild(M("div", " ", "CodeMirror-cursor")); i.style.left = r.left + "px", i.style.top = r.top + "px", i.style.height = Math.max(0, r.bottom - r.top) * e.options.cursorHeight + "px", /\bcm-fat-cursor\b/.test(e.getWrapperElement().className) && (t = (t = Jn(e, t, "div", null, null)).right - t.left, i.style.width = (0 < t ? t : e.defaultCharWidth()) + "px"), r.other && ((i = n.appendChild(M("div", " ", "CodeMirror-cursor CodeMirror-secondarycursor"))).style.display = "", i.style.left = r.other.left + "px", i.style.top = r.other.top + "px", i.style.height = .85 * (r.other.bottom - r.other.top) + "px") } function Lr(e, t) { return e.top - t.top || e.left - t.left } function kr(e) { var t, n; e.state.focused && (t = e.display, clearInterval(t.blinker), n = !0, t.cursorDiv.style.visibility = "", 0 < e.options.cursorBlinkRate ? t.blinker = setInterval(function () { e.hasFocus() || Or(e), t.cursorDiv.style.visibility = (n = !n) ? "" : "hidden" }, e.options.cursorBlinkRate) : e.options.cursorBlinkRate < 0 && (t.cursorDiv.style.visibility = "hidden")) } function Tr(e) { e.hasFocus() || (e.display.input.focus(), e.state.focused || Nr(e)) } function Mr(e) { e.state.delayingBlurEvent = !0, setTimeout(function () { e.state.delayingBlurEvent && (e.state.delayingBlurEvent = !1, e.state.focused && Or(e)) }, 100) } function Nr(e, t) { e.state.delayingBlurEvent && !e.state.draggingText && (e.state.delayingBlurEvent = !1), "nocursor" != e.options.readOnly && (e.state.focused || (O(e, "focus", e, t), e.state.focused = !0, ie(e.display.wrapper, "CodeMirror-focused"), e.curOp || e.display.selForContextMenu == e.doc.sel || (e.display.input.reset(), x && setTimeout(function () { return e.display.input.reset(!0) }, 20)), e.display.input.receivedFocus()), kr(e)) } function Or(e, t) { e.state.delayingBlurEvent || (e.state.focused && (O(e, "blur", e, t), e.state.focused = !1, ee(e.display.wrapper, "CodeMirror-focused")), clearInterval(e.display.blinker), setTimeout(function () { e.state.focused || (e.display.shift = !1) }, 150)) } function Ar(e) { for (var t = e.display, n = t.lineDiv.offsetTop, r = Math.max(0, t.scroller.getBoundingClientRect().top), i = t.lineDiv.getBoundingClientRect().top, o = 0, l = 0; l < t.view.length; l++) { var s = t.view[l], a = e.options.lineWrapping, u = void 0, c = 0; if (!s.hidden) { i += s.line.height, w && v < 8 ? (u = (h = s.node.offsetTop + s.node.offsetHeight) - n, n = h) : (u = (h = s.node.getBoundingClientRect()).bottom - h.top, !a && s.text.firstChild && (c = s.text.firstChild.getBoundingClientRect().right - h.left - 1)); var h, a = s.line.height - u; if ((.005 < a || a < -.005) && (i < r && (o -= a), yt(s.line, u), Dr(s.line), s.rest)) for (var d = 0; d < s.rest.length; d++)Dr(s.rest[d]); c > e.display.sizerWidth && ((a = Math.ceil(c / cr(e.display))) > e.display.maxLineLength && (e.display.maxLineLength = a, e.display.maxLine = s.line, e.display.maxLineChanged = !0)) } } 2 < Math.abs(o) && (t.scroller.scrollTop += o) } function Dr(e) { if (e.widgets) for (var t = 0; t < e.widgets.length; ++t) { var n = e.widgets[t], r = n.node.parentNode; r && (n.height = r.offsetHeight) } } function Wr(e, t, n) { var r, i = n && null != n.top ? Math.max(0, n.top) : e.scroller.scrollTop, i = Math.floor(i - Dn(e)), o = n && null != n.bottom ? n.bottom : i + e.wrapper.clientHeight, i = bt(t, i), o = bt(t, o); return n && n.ensure && (r = n.ensure.from.line, n = n.ensure.to.line, r < i ? o = bt(t, ln(W(t, i = r)) + e.wrapper.clientHeight) : Math.min(n, t.lastLine()) >= o && (i = bt(t, ln(W(t, n)) - e.wrapper.clientHeight), o = n)), { from: i, to: Math.max(o, i + 1) } } function Hr(e, t) { var n = e.display, r = ur(e.display), i = (t.top < 0 && (t.top = 0), (e.curOp && null != e.curOp.scrollTop ? e.curOp : n.scroller).scrollTop), o = En(e), l = {}, s = (t.bottom - t.top > o && (t.bottom = t.top + o), e.doc.height + Wn(n)), a = t.top < r, r = t.bottom > s - r, r = (t.top < i ? l.scrollTop = a ? 0 : t.top : t.bottom > i + o && ((a = Math.min(t.top, (r ? s : t.bottom) - o)) != i && (l.scrollTop = a)), e.options.fixedGutter ? 0 : n.gutters.offsetWidth), s = e.curOp && null != e.curOp.scrollLeft ? e.curOp.scrollLeft : n.scroller.scrollLeft - r, o = Pn(e) - n.gutters.offsetWidth, i = t.right - t.left > o; return i && (t.right = t.left + o), t.left < 10 ? l.scrollLeft = 0 : t.left < s ? l.scrollLeft = Math.max(0, t.left + r - (i ? 0 : 10)) : t.right > o + s - 3 && (l.scrollLeft = t.right + (i ? 0 : 10) - o), l } function Fr(e, t) { null != t && (Rr(e), e.curOp.scrollTop = (null == e.curOp.scrollTop ? e.doc : e.curOp).scrollTop + t) } function Pr(e) { Rr(e); var t = e.getCursor(); e.curOp.scrollToPos = { from: t, to: t, margin: e.options.cursorScrollMargin } } function Er(e, t, n) { null == t && null == n || Rr(e), null != t && (e.curOp.scrollLeft = t), null != n && (e.curOp.scrollTop = n) } function Rr(e) { var t = e.curOp.scrollToPos; t && (e.curOp.scrollToPos = null, zr(e, tr(e, t.from), tr(e, t.to), t.margin)) } function zr(e, t, n, r) { t = Hr(e, { left: Math.min(t.left, n.left), top: Math.min(t.top, n.top) - r, right: Math.max(t.right, n.right), bottom: Math.max(t.bottom, n.bottom) + r }); Er(e, t.scrollLeft, t.scrollTop) } function Ir(e, t) { Math.abs(e.doc.scrollTop - t) < 2 || (d || ri(e, { top: t }), Br(e, t, !0), d && ri(e), Qr(e, 100)) } function Br(e, t, n) { t = Math.max(0, Math.min(e.display.scroller.scrollHeight - e.display.scroller.clientHeight, t)), e.display.scroller.scrollTop == t && !n || (e.doc.scrollTop = t, e.display.scrollbars.setScrollTop(t), e.display.scroller.scrollTop != t && (e.display.scroller.scrollTop = t)) } function Gr(e, t, n, r) { t = Math.max(0, Math.min(t, e.display.scroller.scrollWidth - e.display.scroller.clientWidth)), (n ? t == e.doc.scrollLeft : Math.abs(e.doc.scrollLeft - t) < 2) && !r || (e.doc.scrollLeft = t, li(e), e.display.scroller.scrollLeft != t && (e.display.scroller.scrollLeft = t), e.display.scrollbars.setScrollLeft(t)) } function Ur(e) { var t = e.display, n = t.gutters.offsetWidth, r = Math.round(e.doc.height + Wn(e.display)); return { clientHeight: t.scroller.clientHeight, viewHeight: t.wrapper.clientHeight, scrollWidth: t.scroller.scrollWidth, clientWidth: t.scroller.clientWidth, viewWidth: t.wrapper.clientWidth, barLeft: e.options.fixedGutter ? n : 0, docHeight: r, scrollHeight: r + Fn(e) + t.barHeight, nativeBarWidth: t.nativeBarWidth, gutterWidth: n } } function Vr(e, t, n) { this.cm = n; var r = this.vert = M("div", [M("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar"), i = this.horiz = M("div", [M("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar"); r.tabIndex = i.tabIndex = -1, e(r), e(i), k(r, "scroll", function () { r.clientHeight && t(r.scrollTop, "vertical") }), k(i, "scroll", function () { i.clientWidth && t(i.scrollLeft, "horizontal") }), this.checkedZeroWidth = !1, w && v < 8 && (this.horiz.style.minHeight = this.vert.style.minWidth = "18px") } function Kr() { } Vr.prototype.update = function (e) { var t, n = e.scrollWidth > e.clientWidth + 1, r = e.scrollHeight > e.clientHeight + 1, i = e.nativeBarWidth; return r ? (this.vert.style.display = "block", this.vert.style.bottom = n ? i + "px" : "0", t = e.viewHeight - (n ? i : 0), this.vert.firstChild.style.height = Math.max(0, e.scrollHeight - e.clientHeight + t) + "px") : (this.vert.scrollTop = 0, this.vert.style.display = "", this.vert.firstChild.style.height = "0"), n ? (this.horiz.style.display = "block", this.horiz.style.right = r ? i + "px" : "0", this.horiz.style.left = e.barLeft + "px", t = e.viewWidth - e.barLeft - (r ? i : 0), this.horiz.firstChild.style.width = Math.max(0, e.scrollWidth - e.clientWidth + t) + "px") : (this.horiz.style.display = "", this.horiz.firstChild.style.width = "0"), !this.checkedZeroWidth && 0 < e.clientHeight && (0 == i && this.zeroWidthHack(), this.checkedZeroWidth = !0), { right: r ? i : 0, bottom: n ? i : 0 } }, Vr.prototype.setScrollLeft = function (e) { this.horiz.scrollLeft != e && (this.horiz.scrollLeft = e), this.disableHoriz && this.enableZeroWidthBar(this.horiz, this.disableHoriz, "horiz") }, Vr.prototype.setScrollTop = function (e) { this.vert.scrollTop != e && (this.vert.scrollTop = e), this.disableVert && this.enableZeroWidthBar(this.vert, this.disableVert, "vert") }, Vr.prototype.zeroWidthHack = function () { this.horiz.style.height = this.vert.style.width = C && !c ? "12px" : "18px", this.horiz.style.visibility = this.vert.style.visibility = "hidden", this.disableHoriz = new pe, this.disableVert = new pe }, Vr.prototype.enableZeroWidthBar = function (n, r, i) { n.style.visibility = "", r.set(1e3, function e() { var t = n.getBoundingClientRect(); ("vert" == i ? document.elementFromPoint(t.right - 1, (t.top + t.bottom) / 2) : document.elementFromPoint((t.right + t.left) / 2, t.bottom - 1)) != n ? n.style.visibility = "hidden" : r.set(1e3, e) }) }, Vr.prototype.clear = function () { var e = this.horiz.parentNode; e.removeChild(this.horiz), e.removeChild(this.vert) }; function jr(e, t) { t = t || Ur(e); var n = e.display.barWidth, r = e.display.barHeight; Xr(e, t); for (var i = 0; i < 4 && n != e.display.barWidth || r != e.display.barHeight; i++)n != e.display.barWidth && e.options.lineWrapping && Ar(e), Xr(e, Ur(e)), n = e.display.barWidth, r = e.display.barHeight } function Xr(e, t) { var n = e.display, r = n.scrollbars.update(t); n.sizer.style.paddingRight = (n.barWidth = r.right) + "px", n.sizer.style.paddingBottom = (n.barHeight = r.bottom) + "px", n.heightForcer.style.borderBottom = r.bottom + "px solid transparent", r.right && r.bottom ? (n.scrollbarFiller.style.display = "block", n.scrollbarFiller.style.height = r.bottom + "px", n.scrollbarFiller.style.width = r.right + "px") : n.scrollbarFiller.style.display = "", r.bottom && e.options.coverGutterNextToScrollbar && e.options.fixedGutter ? (n.gutterFiller.style.display = "block", n.gutterFiller.style.height = r.bottom + "px", n.gutterFiller.style.width = t.gutterWidth + "px") : n.gutterFiller.style.display = "" } Kr.prototype.update = function () { return { bottom: 0, right: 0 } }, Kr.prototype.setScrollLeft = function () { }, Kr.prototype.setScrollTop = function () { }, Kr.prototype.clear = function () { }; var Yr = { native: Vr, null: Kr }; function $r(n) { n.display.scrollbars && (n.display.scrollbars.clear(), n.display.scrollbars.addClass && ee(n.display.wrapper, n.display.scrollbars.addClass)), n.display.scrollbars = new Yr[n.options.scrollbarStyle](function (e) { n.display.wrapper.insertBefore(e, n.display.scrollbarFiller), k(e, "mousedown", function () { n.state.focused && setTimeout(function () { return n.display.input.focus() }, 0) }), e.setAttribute("cm-not-content", "true") }, function (e, t) { ("horizontal" == t ? Gr : Ir)(n, e) }, n), n.display.scrollbars.addClass && ie(n.display.wrapper, n.display.scrollbars.addClass) } var _r = 0; function qr(e) { e.curOp = { cm: e, viewChanged: !1, startHeight: e.doc.height, forceUpdate: !1, updateInput: 0, typing: !1, changeObjs: null, cursorActivityHandlers: null, cursorActivityCalled: 0, selectionChanged: !1, updateMaxLine: !1, scrollLeft: null, scrollTop: null, scrollToPos: null, focus: !1, id: ++_r, markArrays: null }, e = e.curOp, bn ? bn.ops.push(e) : e.ownsGroup = bn = { ops: [e], delayedCallbacks: [] } } function Zr(e) { e = e.curOp; if (e) { var t = function (e) { for (var t = 0; t < e.ops.length; t++)e.ops[t].cm.curOp = null; for (var n = e.ops, r = 0; r < n.length; r++) { l = o = i = void 0; var i = n[r], o = i.cm, l = o.display; (function (e) { var t = e.display; !t.scrollbarsClipped && t.scroller.offsetWidth && (t.nativeBarWidth = t.scroller.offsetWidth - t.scroller.clientWidth, t.heightForcer.style.height = Fn(e) + "px", t.sizer.style.marginBottom = -t.nativeBarWidth + "px", t.sizer.style.borderRightWidth = Fn(e) + "px", t.scrollbarsClipped = !0) })(o), i.updateMaxLine && an(o), i.mustUpdate = i.viewChanged || i.forceUpdate || null != i.scrollTop || i.scrollToPos && (i.scrollToPos.from.line < l.viewFrom || i.scrollToPos.to.line >= l.viewTo) || l.maxLineChanged && o.options.lineWrapping, i.update = i.mustUpdate && new ei(o, i.mustUpdate && { top: i.scrollTop, ensure: i.scrollToPos }, i.forceUpdate) } for (var s = 0; s < n.length; s++) { a = void 0; var a = n[s]; a.updatedDisplay = a.mustUpdate && ti(a.cm, a.update) } for (var u = 0; u < n.length; u++) { c = void 0; h = void 0; d = void 0; var c = n[u]; var h = c.cm, d = h.display; c.updatedDisplay && Ar(h); c.barMeasure = Ur(h), d.maxLineChanged && !h.options.lineWrapping && (c.adjustWidthTo = zn(h, d.maxLine, d.maxLine.text.length).left + 3, h.display.sizerWidth = c.adjustWidthTo, c.barMeasure.scrollWidth = Math.max(d.scroller.clientWidth, d.sizer.offsetLeft + c.adjustWidthTo + Fn(h) + h.display.barWidth), c.maxScrollLeft = Math.max(0, d.sizer.offsetLeft + c.adjustWidthTo - Pn(h))); (c.updatedDisplay || c.selectionChanged) && (c.preparedSelection = d.input.prepareSelection()) } for (var f = 0; f < n.length; f++) { p = void 0; g = void 0; m = void 0; var p = n[f]; var g = p.cm; null != p.adjustWidthTo && (g.display.sizer.style.minWidth = p.adjustWidthTo + "px", p.maxScrollLeft < g.doc.scrollLeft && Gr(g, Math.min(g.display.scroller.scrollLeft, p.maxScrollLeft), !0), g.display.maxLineChanged = !1); var m = p.focus && p.focus == N(ue(g)); p.preparedSelection && g.display.input.showSelection(p.preparedSelection, m); !p.updatedDisplay && p.startHeight == g.doc.height || jr(g, p.barMeasure); p.updatedDisplay && oi(g, p.barMeasure); p.selectionChanged && kr(g); g.state.focused && p.updateInput && g.display.input.reset(p.typing); m && Tr(p.cm) } for (var v, y = 0; y < n.length; y++) { b = void 0; w = void 0; x = void 0; C = void 0; v = void 0; S = void 0; L = void 0; k = void 0; T = void 0; var b = n[y]; var w = b.cm, x = w.display, C = w.doc; b.updatedDisplay && ni(w, b.update); null == x.wheelStartX || null == b.scrollTop && null == b.scrollLeft && !b.scrollToPos || (x.wheelStartX = x.wheelStartY = null); null != b.scrollTop && Br(w, b.scrollTop, b.forceScroll); null != b.scrollLeft && Gr(w, b.scrollLeft, !0, !0); b.scrollToPos && (v = function (e, t, n, r) { null == r && (r = 0), e.options.lineWrapping || t != n || (n = "before" == t.sticky ? F(t.line, t.ch + 1, "before") : t, t = t.ch ? F(t.line, "before" == t.sticky ? t.ch - 1 : t.ch, "after") : t); for (var i = 0; i < 5; i++) { var o, l = !1, s = er(e, t), a = n && n != t ? er(e, n) : s, s = Hr(e, o = { left: Math.min(s.left, a.left), top: Math.min(s.top, a.top) - r, right: Math.max(s.left, a.left), bottom: Math.max(s.bottom, a.bottom) + r }), a = e.doc.scrollTop, u = e.doc.scrollLeft; if (null != s.scrollTop && (Ir(e, s.scrollTop), 1 < Math.abs(e.doc.scrollTop - a) && (l = !0)), null != s.scrollLeft && (Gr(e, s.scrollLeft), 1 < Math.abs(e.doc.scrollLeft - u) && (l = !0)), !l) break } return o }(w, E(C, b.scrollToPos.from), E(C, b.scrollToPos.to), b.scrollToPos.margin), function (e, t) { var n, r, i, o; A(e, "scrollCursorIntoView") || (o = (n = e.display).sizer.getBoundingClientRect(), r = null, i = n.wrapper.ownerDocument, t.top + o.top < 0 ? r = !0 : t.bottom + o.top > (i.defaultView.innerHeight || i.documentElement.clientHeight) && (r = !1), null == r || X || (o = M("div", "​", null, "position: absolute;\n                         top: " + (t.top - n.viewOffset - Dn(e.display)) + "px;\n                         height: " + (t.bottom - t.top + Fn(e) + n.barHeight) + "px;\n                         left: " + t.left + "px; width: " + Math.max(2, t.right - t.left) + "px;"), e.display.lineSpace.appendChild(o), o.scrollIntoView(r), e.display.lineSpace.removeChild(o))) }(w, v)); var S = b.maybeHiddenMarkers, L = b.maybeUnhiddenMarkers; if (S) for (var k = 0; k < S.length; ++k)S[k].lines.length || O(S[k], "hide"); if (L) for (var T = 0; T < L.length; ++T)L[T].lines.length && O(L[T], "unhide"); x.wrapper.offsetHeight && (C.scrollTop = w.display.scroller.scrollTop); b.changeObjs && O(w, "changes", w, b.changeObjs); b.update && b.update.finish() } }; if (e = e.ownsGroup) try { var n = e, r = n.delayedCallbacks, i = 0; do { for (; i < r.length; i++)r[i].call(null); for (var o = 0; o < n.ops.length; o++) { var l = n.ops[o]; if (l.cursorActivityHandlers) for (; l.cursorActivityCalled < l.cursorActivityHandlers.length;)l.cursorActivityHandlers[l.cursorActivityCalled++].call(null, l.cm) } } while (i < r.length) } finally { bn = null, t(e) } } } function h(e, t) { if (e.curOp) return t(); qr(e); try { return t() } finally { Zr(e) } } function I(e, t) { return function () { if (e.curOp) return t.apply(e, arguments); qr(e); try { return t.apply(e, arguments) } finally { Zr(e) } } } function t(e) { return function () { if (this.curOp) return e.apply(this, arguments); qr(this); try { return e.apply(this, arguments) } finally { Zr(this) } } } function n(t) { return function () { var e = this.cm; if (!e || e.curOp) return t.apply(this, arguments); qr(e); try { return t.apply(this, arguments) } finally { Zr(e) } } } function Qr(e, t) { e.doc.highlightFrontier < e.display.viewTo && e.state.highlight.set(t, de(Jr, e)) } function Jr(l) { var s, a, u, c = l.doc; c.highlightFrontier >= l.display.viewTo || (s = +new Date + l.options.workTime, a = Wt(l, c.highlightFrontier), u = [], c.iter(a.line, Math.min(c.first + c.size, l.display.viewTo + 500), function (e) { if (a.line >= l.display.viewFrom) { for (var t = e.styles, n = e.text.length > l.options.maxHighlightLength ? ft(c.mode, a.state) : null, r = At(l, e, a, !0), n = (n && (a.state = n), e.styles = r.styles, e.styleClasses), r = r.classes, i = (r ? e.styleClasses = r : n && (e.styleClasses = null), !t || t.length != e.styles.length || n != r && (!n || !r || n.bgClass != r.bgClass || n.textClass != r.textClass)), o = 0; !i && o < t.length; ++o)i = t[o] != e.styles[o]; i && u.push(a.line), e.stateAfter = a.save(), a.nextLine() } else e.text.length <= l.options.maxHighlightLength && Ht(l, e.text, a), e.stateAfter = a.line % 5 == 0 ? a.save() : null, a.nextLine(); if (+new Date > s) return Qr(l, l.options.workDelay), !0 }), c.highlightFrontier = a.line, c.modeFrontier = Math.max(c.modeFrontier, a.line), u.length && h(l, function () { for (var e = 0; e < u.length; e++)vr(l, u[e], "text") })) } var ei = function (e, t, n) { var r = e.display; this.viewport = t, this.visible = Wr(r, e.doc, t), this.editorIsHidden = !r.wrapper.offsetWidth, this.wrapperHeight = r.wrapper.clientHeight, this.wrapperWidth = r.wrapper.clientWidth, this.oldDisplayWidth = Pn(e), this.force = n, this.dims = hr(e), this.events = [] }; function ti(e, t) { var n = e.display, r = e.doc; if (t.editorIsHidden) return yr(e), !1; if (!t.force && t.visible.from >= n.viewFrom && t.visible.to <= n.viewTo && (null == n.updateLineNumbers || n.updateLineNumbers >= n.viewTo) && n.renderedView == n.view && 0 == wr(e)) return !1; si(e) && (yr(e), t.dims = hr(e)); var i = r.first + r.size, o = Math.max(t.visible.from - e.options.viewportMargin, r.first), l = Math.min(i, t.visible.to + e.options.viewportMargin), r = (n.viewFrom < o && o - n.viewFrom < 20 && (o = Math.max(r.first, n.viewFrom)), n.viewTo > l && n.viewTo - l < 20 && (l = Math.min(i, n.viewTo)), Gt && (o = nn(e.doc, o), l = rn(e.doc, l)), o != n.viewFrom || l != n.viewTo || n.lastWrapHeight != t.wrapperHeight || n.lastWrapWidth != t.wrapperWidth), i = (i = o, o = l, 0 == (c = (l = e).display).view.length || i >= c.viewTo || o <= c.viewFrom ? (c.view = yn(l, i, o), c.viewFrom = i) : (c.viewFrom > i ? c.view = yn(l, i, c.viewFrom).concat(c.view) : c.viewFrom < i && (c.view = c.view.slice(mr(l, i))), c.viewFrom = i, c.viewTo < o ? c.view = c.view.concat(yn(l, c.viewTo, o)) : c.viewTo > o && (c.view = c.view.slice(0, mr(l, o)))), c.viewTo = o, n.viewOffset = ln(W(e.doc, n.viewFrom)), e.display.mover.style.top = n.viewOffset + "px", wr(e)); if (!r && 0 == i && !t.force && n.renderedView == n.view && (null == n.updateLineNumbers || n.updateLineNumbers >= n.viewTo)) return !1; var l = function (e) { if (e.hasFocus()) return null; if (!(n = N(ue(e))) || !re(e.display.lineDiv, n)) return null; var t, n = { activeElt: n }; return window.getSelection && (t = he(e).getSelection()).anchorNode && t.extend && re(e.display.lineDiv, t.anchorNode) && (n.anchorNode = t.anchorNode, n.anchorOffset = t.anchorOffset, n.focusNode = t.focusNode, n.focusOffset = t.focusOffset), n }(e), s = (4 < i && (n.lineDiv.style.display = "none"), e), a = n.updateLineNumbers, u = t.dims, c = s.display, h = s.options.lineNumbers, d = c.lineDiv, f = d.firstChild; function p(e) { var t = e.nextSibling; return x && C && s.display.currentWheelTarget == e ? e.style.display = "none" : e.parentNode.removeChild(e), t } for (var g = c.view, m = c.viewFrom, v = 0; v < g.length; v++) { var y = g[v]; if (!y.hidden) if (y.node && y.node.parentNode == d) { for (; f != y.node;)f = p(f); var b = h && null != a && a <= m && y.lineNumber; y.changes && (-1 < L(y.changes, "gutter") && (b = !1), Cn(s, y, m, u)), b && (te(y.lineNumber), y.lineNumber.appendChild(document.createTextNode(xt(s.options, m)))), f = y.node.nextSibling } else { b = function (e, t, n, r) { var i = Ln(e, t); return t.text = t.node = i.pre, i.bgClass && (t.bgClass = i.bgClass), i.textClass && (t.textClass = i.textClass), kn(e, t), Tn(e, t, n, r), Mn(e, t, r), t.node }(s, y, m, u); d.insertBefore(b, f) } m += y.size } for (; f;)f = p(f); return 4 < i && (n.lineDiv.style.display = ""), n.renderedView = n.view, (o = l) && o.activeElt && o.activeElt != N(ce(o.activeElt)) && (o.activeElt.focus(), !/^(INPUT|TEXTAREA)$/.test(o.activeElt.nodeName) && o.anchorNode && re(document.body, o.anchorNode) && re(document.body, o.focusNode) && (i = (c = o.activeElt.ownerDocument).defaultView.getSelection(), (c = c.createRange()).setEnd(o.anchorNode, o.anchorOffset), c.collapse(!1), i.removeAllRanges(), i.addRange(c), i.extend(o.focusNode, o.focusOffset))), te(n.cursorDiv), te(n.selectionDiv), n.gutters.style.height = n.sizer.style.minHeight = 0, r && (n.lastWrapHeight = t.wrapperHeight, n.lastWrapWidth = t.wrapperWidth, Qr(e, 400)), !(n.updateLineNumbers = null) } function ni(e, t) { for (var n = t.viewport, r = !0; ; r = !1) { if (r && e.options.lineWrapping && t.oldDisplayWidth != Pn(e)) r && (t.visible = Wr(e.display, e.doc, n)); else if (n && null != n.top && (n = { top: Math.min(e.doc.height + Wn(e.display) - En(e), n.top) }), t.visible = Wr(e.display, e.doc, n), t.visible.from >= e.display.viewFrom && t.visible.to <= e.display.viewTo) break; if (!ti(e, t)) break; Ar(e); var i = Ur(e); xr(e), jr(e, i), oi(e, i), t.force = !1 } t.signal(e, "update", e), e.display.viewFrom == e.display.reportedViewFrom && e.display.viewTo == e.display.reportedViewTo || (t.signal(e, "viewportChange", e, e.display.viewFrom, e.display.viewTo), e.display.reportedViewFrom = e.display.viewFrom, e.display.reportedViewTo = e.display.viewTo) } function ri(e, t) { var n, t = new ei(e, t); ti(e, t) && (Ar(e), ni(e, t), n = Ur(e), xr(e), jr(e, n), oi(e, n), t.finish()) } function ii(e) { var t = e.gutters.offsetWidth; e.sizer.style.marginLeft = t + "px", b(e, "gutterChanged", e) } function oi(e, t) { e.display.sizer.style.minHeight = t.docHeight + "px", e.display.heightForcer.style.top = t.docHeight + "px", e.display.gutters.style.height = t.docHeight + e.display.barHeight + Fn(e) + "px" } function li(e) { var t = e.display, n = t.view; if (t.alignWidgets || t.gutters.firstChild && e.options.fixedGutter) { for (var r = dr(t) - t.scroller.scrollLeft + e.doc.scrollLeft, i = t.gutters.offsetWidth, o = r + "px", l = 0; l < n.length; l++)if (!n[l].hidden) { e.options.fixedGutter && (n[l].gutter && (n[l].gutter.style.left = o), n[l].gutterBackground && (n[l].gutterBackground.style.left = o)); var s = n[l].alignable; if (s) for (var a = 0; a < s.length; a++)s[a].style.left = o } e.options.fixedGutter && (t.gutters.style.left = r + i + "px") } } function si(e) { var t, n, r, i; if (e.options.lineNumbers) return t = e.doc, t = xt(e.options, t.first + t.size - 1), n = e.display, t.length != n.lineNumChars ? (r = (i = n.measure.appendChild(M("div", [M("div", t)], "CodeMirror-linenumber CodeMirror-gutter-elt"))).firstChild.offsetWidth, i = i.offsetWidth - r, n.lineGutter.style.width = "", n.lineNumInnerWidth = Math.max(r, n.lineGutter.offsetWidth - i) + 1, n.lineNumWidth = n.lineNumInnerWidth + i, n.lineNumChars = n.lineNumInnerWidth ? t.length : -1, n.lineGutter.style.width = n.lineNumWidth + "px", ii(e.display), 1) : void 0 } function ai(e, t) { for (var n = [], r = !1, i = 0; i < e.length; i++) { var o = e[i], l = null; if ("string" != typeof o && (l = o.style, o = o.className), "CodeMirror-linenumbers" == o) { if (!t) continue; r = !0 } n.push({ className: o, style: l }) } return t && !r && n.push({ className: "CodeMirror-linenumbers", style: null }), n } function ui(e) { var t = e.gutters, n = e.gutterSpecs; te(t), e.lineGutter = null; for (var r = 0; r < n.length; ++r) { var i = n[r], o = i.className, i = i.style, l = t.appendChild(M("div", null, "CodeMirror-gutter " + o)); i && (l.style.cssText = i), "CodeMirror-linenumbers" == o && ((e.lineGutter = l).style.width = (e.lineNumWidth || 1) + "px") } t.style.display = n.length ? "" : "none", ii(e) } function ci(e) { ui(e.display), R(e), li(e) } function hi(e, t, n, r) { var i = this, o = (this.input = n, i.scrollbarFiller = M("div", null, "CodeMirror-scrollbar-filler"), i.scrollbarFiller.setAttribute("cm-not-content", "true"), i.gutterFiller = M("div", null, "CodeMirror-gutter-filler"), i.gutterFiller.setAttribute("cm-not-content", "true"), i.lineDiv = ne("div", null, "CodeMirror-code"), i.selectionDiv = M("div", null, null, "position: relative; z-index: 1"), i.cursorDiv = M("div", null, "CodeMirror-cursors"), i.measure = M("div", null, "CodeMirror-measure"), i.lineMeasure = M("div", null, "CodeMirror-measure"), i.lineSpace = ne("div", [i.measure, i.lineMeasure, i.selectionDiv, i.cursorDiv, i.lineDiv], null, "position: relative; outline: none"), ne("div", [i.lineSpace], "CodeMirror-lines")); i.mover = M("div", [o], null, "position: relative"), i.sizer = M("div", [i.mover], "CodeMirror-sizer"), i.sizerWidth = null, i.heightForcer = M("div", null, null, "position: absolute; height: " + ge + "px; width: 1px;"), i.gutters = M("div", null, "CodeMirror-gutters"), i.lineGutter = null, i.scroller = M("div", [i.sizer, i.heightForcer, i.gutters], "CodeMirror-scroll"), i.scroller.setAttribute("tabIndex", "-1"), i.wrapper = M("div", [i.scrollbarFiller, i.gutterFiller, i.scroller], "CodeMirror"), m && 105 <= V && (i.wrapper.style.clipPath = "inset(0px)"), i.wrapper.setAttribute("translate", "no"), w && v < 8 && (i.gutters.style.zIndex = -1, i.scroller.style.paddingRight = 0), x || d && _ || (i.scroller.draggable = !0), e && (e.appendChild ? e.appendChild(i.wrapper) : e(i.wrapper)), i.viewFrom = i.viewTo = t.first, i.reportedViewFrom = i.reportedViewTo = t.first, i.view = [], i.renderedView = null, i.externalMeasured = null, i.viewOffset = 0, i.lastWrapHeight = i.lastWrapWidth = 0, i.updateLineNumbers = null, i.nativeBarWidth = i.barHeight = i.barWidth = 0, i.scrollbarsClipped = !1, i.lineNumWidth = i.lineNumInnerWidth = i.lineNumChars = null, i.alignWidgets = !1, i.cachedCharWidth = i.cachedTextHeight = i.cachedPaddingH = null, i.maxLine = null, i.maxLineLength = 0, i.maxLineChanged = !1, i.wheelDX = i.wheelDY = i.wheelStartX = i.wheelStartY = null, i.shift = !1, i.selForContextMenu = null, i.activeTouch = null, i.gutterSpecs = ai(r.gutters, r.lineNumbers), ui(i), n.init(i) } ei.prototype.signal = function (e, t) { Ye(e, t) && this.events.push(arguments) }, ei.prototype.finish = function () { for (var e = 0; e < this.events.length; e++)O.apply(null, this.events[e]) }; var di = 0, fi = null; function pi(e) { var t = e.wheelDeltaX, n = e.wheelDeltaY; return null == t && e.detail && e.axis == e.HORIZONTAL_AXIS && (t = e.detail), null == n && e.detail && e.axis == e.VERTICAL_AXIS ? n = e.detail : null == n && (n = e.wheelDelta), { x: t, y: n } } function gi(e) { e = pi(e); return e.x *= fi, e.y *= fi, e } function mi(e, t) { m && 102 == V && (null == e.display.chromeScrollHack ? e.display.sizer.style.pointerEvents = "none" : clearTimeout(e.display.chromeScrollHack), e.display.chromeScrollHack = setTimeout(function () { e.display.chromeScrollHack = null, e.display.sizer.style.pointerEvents = "" }, 100)); var n = pi(t), r = n.x, n = n.y, i = fi, o = (0 === t.deltaMode && (r = t.deltaX, n = t.deltaY, i = 1), e.display), l = o.scroller, s = l.scrollWidth > l.clientWidth, a = l.scrollHeight > l.clientHeight; if (r && s || n && a) { if (n && C && x) e: for (var u = t.target, c = o.view; u != l; u = u.parentNode)for (var h = 0; h < c.length; h++)if (c[h].node == u) { e.display.currentWheelTarget = u; break e } if (r && !d && !K && null != i) return n && a && Ir(e, Math.max(0, l.scrollTop + n * i)), Gr(e, Math.max(0, l.scrollLeft + r * i)), n && !a || D(t), void (o.wheelStartX = null); n && null != i && (a = (s = e.doc.scrollTop) + o.wrapper.clientHeight, (i = n * i) < 0 ? s = Math.max(0, s + i - 50) : a = Math.min(e.doc.height, a + i + 50), ri(e, { top: s, bottom: a })), di < 20 && 0 !== t.deltaMode && (null == o.wheelStartX ? (o.wheelStartX = l.scrollLeft, o.wheelStartY = l.scrollTop, o.wheelDX = r, o.wheelDY = n, setTimeout(function () { var e, t; null != o.wheelStartX && (e = l.scrollLeft - o.wheelStartX, t = (t = l.scrollTop - o.wheelStartY) && o.wheelDY && t / o.wheelDY || e && o.wheelDX && e / o.wheelDX, o.wheelStartX = o.wheelStartY = null, t && (fi = (fi * di + t) / (di + 1), ++di)) }, 200)) : (o.wheelDX += r, o.wheelDY += n)) } } w ? fi = -.53 : d ? fi = 15 : m ? fi = -.7 : j && (fi = -1 / 3); var B = function (e, t) { this.ranges = e, this.primIndex = t }, G = (B.prototype.primary = function () { return this.ranges[this.primIndex] }, B.prototype.equals = function (e) { if (e == this) return !0; if (e.primIndex != this.primIndex || e.ranges.length != this.ranges.length) return !1; for (var t = 0; t < this.ranges.length; t++) { var n = this.ranges[t], r = e.ranges[t]; if (!Ct(n.anchor, r.anchor) || !Ct(n.head, r.head)) return !1 } return !0 }, B.prototype.deepCopy = function () { for (var e = [], t = 0; t < this.ranges.length; t++)e[t] = new G(St(this.ranges[t].anchor), St(this.ranges[t].head)); return new B(e, this.primIndex) }, B.prototype.somethingSelected = function () { for (var e = 0; e < this.ranges.length; e++)if (!this.ranges[e].empty()) return !0; return !1 }, B.prototype.contains = function (e, t) { t = t || e; for (var n = 0; n < this.ranges.length; n++) { var r = this.ranges[n]; if (0 <= P(t, r.from()) && P(e, r.to()) <= 0) return n } return -1 }, function (e, t) { this.anchor = e, this.head = t }); function vi(e, t, n) { var r = e && e.options.selectionsMayTouch, e = t[n]; t.sort(function (e, t) { return P(e.from(), t.from()) }), n = L(t, e); for (var i = 1; i < t.length; i++) { var o, l = t[i], s = t[i - 1], a = P(s.to(), l.from()); (r && !l.empty() ? 0 < a : 0 <= a) && (a = kt(s.from(), l.from()), o = Lt(s.to(), l.to()), l = s.empty() ? l.from() == l.head : s.from() == s.head, i <= n && --n, t.splice(--i, 2, new G(l ? o : a, l ? a : o))) } return new B(t, n) } function yi(e, t) { return new B([new G(e, t || e)], 0) } function bi(e) { return e.text ? F(e.from.line + e.text.length - 1, z(e.text).length + (1 == e.text.length ? e.from.ch : 0)) : e.to } function wi(e, t) { if (P(e, t.from) < 0) return e; if (P(e, t.to) <= 0) return bi(t); var n = e.line + t.text.length - (t.to.line - t.from.line) - 1, r = e.ch; return e.line == t.to.line && (r += bi(t).ch - t.to.ch), F(n, r) } function xi(e, t) { for (var n = [], r = 0; r < e.sel.ranges.length; r++) { var i = e.sel.ranges[r]; n.push(new G(wi(i.anchor, t), wi(i.head, t))) } return vi(e.cm, n, e.sel.primIndex) } function Ci(e, t, n) { return e.line == t.line ? F(n.line, e.ch - t.ch + n.ch) : F(n.line + (e.line - t.line), e.ch) } function Si(e) { e.doc.mode = ct(e.options, e.doc.modeOption), Li(e) } function Li(e) { e.doc.iter(function (e) { e.stateAfter && (e.stateAfter = null), e.styles && (e.styles = null) }), e.doc.modeFrontier = e.doc.highlightFrontier = e.doc.first, Qr(e, 100), e.state.modeGen++, e.curOp && R(e) } function ki(e, t) { return 0 == t.from.ch && 0 == t.to.ch && "" == z(t.text) && (!e.cm || e.cm.options.wholeLineUpdateBefore) } function Ti(e, o, t, l) { function i(e) { return t ? t[e] : null } function n(e, t, n) { var r, i; t = t, n = n, i = l, (r = e).text = t, r.stateAfter && (r.stateAfter = null), r.styles && (r.styles = null), null != r.order && (r.order = null), Xt(r), Yt(r, n), (t = i ? i(r) : 1) != r.height && yt(r, t), b(e, "change", e, o) } function r(e, t) { for (var n = [], r = e; r < t; ++r)n.push(new un(c[r], i(r), l)); return n } var s, a = o.from, u = o.to, c = o.text, h = W(e, a.line), d = W(e, u.line), f = z(c), p = i(c.length - 1), g = u.line - a.line; o.full ? (e.insert(0, r(0, c.length)), e.remove(c.length, e.size - c.length)) : ki(e, o) ? (s = r(0, c.length - 1), n(d, d.text, p), g && e.remove(a.line, g), s.length && e.insert(a.line, s)) : h == d ? 1 == c.length ? n(h, h.text.slice(0, a.ch) + f + h.text.slice(u.ch), p) : ((s = r(1, c.length - 1)).push(new un(f + h.text.slice(u.ch), p, l)), n(h, h.text.slice(0, a.ch) + c[0], i(0)), e.insert(a.line + 1, s)) : 1 == c.length ? (n(h, h.text.slice(0, a.ch) + c[0] + d.text.slice(u.ch), i(0)), e.remove(a.line + 1, g)) : (n(h, h.text.slice(0, a.ch) + c[0], i(0)), n(d, f + d.text.slice(u.ch), p), s = r(1, c.length - 1), 1 < g && e.remove(a.line + 1, g - 1), e.insert(a.line + 1, s)), b(e, "change", e, o) } function Mi(e, s, a) { !function e(t, n, r) { if (t.linked) for (var i = 0; i < t.linked.length; ++i) { var o, l = t.linked[i]; l.doc != n && (o = r && l.sharedHist, a && !o || (s(l.doc, o), e(l.doc, t, o))) } }(e, null, !0) } function Ni(e, t) { if (t.cm) throw new Error("This document is already in use."); pr((e.doc = t).cm = e), Si(e), Oi(e), e.options.direction = t.direction, e.options.lineWrapping || an(e), e.options.mode = t.modeOption, R(e) } function Oi(e) { ("rtl" == e.doc.direction ? ie : ee)(e.display.lineDiv, "CodeMirror-rtl") } function Ai(e) { this.done = [], this.undone = [], this.undoDepth = e ? e.undoDepth : 1 / 0, this.lastModTime = this.lastSelTime = 0, this.lastOp = this.lastSelOp = null, this.lastOrigin = this.lastSelOrigin = null, this.generation = this.maxGeneration = e ? e.maxGeneration : 1 } function Di(e, t) { var n = { from: St(t.from), to: bi(t), text: mt(e, t.from, t.to) }; return Ei(e, n, t.from.line, t.to.line + 1), Mi(e, function (e) { return Ei(e, n, t.from.line, t.to.line + 1) }, !0), n } function Wi(e) { for (; e.length;) { if (!z(e).ranges) break; e.pop() } } function Hi(e, t, n, r) { var i, o, l = e.history, s = (l.undone.length = 0, +new Date); if ((l.lastOp == r || l.lastOrigin == t.origin && t.origin && ("+" == t.origin.charAt(0) && l.lastModTime > s - (e.cm ? e.cm.options.historyEventDelay : 500) || "*" == t.origin.charAt(0))) && (o = (o = l).lastOp == r ? (Wi(o.done), z(o.done)) : o.done.length && !z(o.done).ranges ? z(o.done) : 1 < o.done.length && !o.done[o.done.length - 2].ranges ? (o.done.pop(), z(o.done)) : void 0)) i = z(o.changes), 0 == P(t.from, t.to) && 0 == P(t.from, i.to) ? i.to = bi(t) : o.changes.push(Di(e, t)); else { var a = z(l.done); for (a && a.ranges || Pi(e.sel, l.done), o = { changes: [Di(e, t)], generation: l.generation }, l.done.push(o); l.done.length > l.undoDepth;)l.done.shift(), l.done[0].ranges || l.done.shift() } l.done.push(n), l.generation = ++l.maxGeneration, l.lastModTime = l.lastSelTime = s, l.lastOp = l.lastSelOp = r, l.lastOrigin = l.lastSelOrigin = t.origin, i || O(e, "historyAdded") } function Fi(e, t, n, r) { var i, o, l, s = e.history, a = r && r.origin; n == s.lastSelOp || a && s.lastSelOrigin == a && (s.lastModTime == s.lastSelTime && s.lastOrigin == a || (e = e, i = a, o = z(s.done), l = t, "*" == (i = i.charAt(0)) || "+" == i && o.ranges.length == l.ranges.length && o.somethingSelected() == l.somethingSelected() && new Date - e.history.lastSelTime <= (e.cm ? e.cm.options.historyEventDelay : 500))) ? s.done[s.done.length - 1] = t : Pi(t, s.done), s.lastSelTime = +new Date, s.lastSelOrigin = a, s.lastSelOp = n, r && !1 !== r.clearRedo && Wi(s.undone) } function Pi(e, t) { var n = z(t); n && n.ranges && n.equals(e) || t.push(e) } function Ei(t, n, e, r) { var i = n["spans_" + t.id], o = 0; t.iter(Math.max(t.first, e), Math.min(t.first + t.size, r), function (e) { e.markedSpans && ((i = i || (n["spans_" + t.id] = {}))[o] = e.markedSpans), ++o }) } function Ri(e, t) { var n = t["spans_" + e.id]; if (!n) return null; for (var r = [], i = 0; i < t.text.length; ++i)r.push(function (e) { if (!e) return null; for (var t, n = 0; n < e.length; ++n)e[n].marker.explicitlyCleared ? t = t || e.slice(0, n) : t && t.push(e[n]); return t ? t.length ? t : null : e }(n[i])); return r } function zi(e, t) { var n = Ri(e, t), r = Kt(e, t); if (!n) return r; if (!r) return n; for (var i = 0; i < n.length; ++i) { var o = n[i], l = r[i]; if (o && l) e: for (var s = 0; s < l.length; ++s) { for (var a = l[s], u = 0; u < o.length; ++u)if (o[u].marker == a.marker) continue e; o.push(a) } else l && (n[i] = l) } return n } function Ii(e, t, n) { for (var r = [], i = 0; i < e.length; ++i) { var o = e[i]; if (o.ranges) r.push(n ? B.prototype.deepCopy.call(o) : o); else { var l = o.changes, s = []; r.push({ changes: s }); for (var a = 0; a < l.length; ++a) { var u, c = l[a]; if (s.push({ from: c.from, to: c.to, text: c.text }), t) for (var h in c) (u = h.match(/^spans_(\d+)$/)) && -1 < L(t, Number(u[1])) && (z(s)[h] = c[h], delete c[h]) } } } return r } function Bi(e, t, n, r) { return r ? (r = e.anchor, n && ((e = P(t, r) < 0) != P(n, r) < 0 ? (r = t, t = n) : e != P(t, n) < 0 && (t = n)), new G(r, t)) : new G(n || t, t) } function Gi(e, t, n, r, i) { null == i && (i = e.cm && (e.cm.display.shift || e.extend)), U(e, new B([Bi(e.sel.primary(), t, n, i)], 0), r) } function Ui(e, t, n) { for (var r = [], i = e.cm && (e.cm.display.shift || e.extend), o = 0; o < e.sel.ranges.length; o++)r[o] = Bi(e.sel.ranges[o], t[o], null, i); U(e, vi(e.cm, r, e.sel.primIndex), n) } function Vi(e, t, n, r) { var i = e.sel.ranges.slice(0); i[t] = n, U(e, vi(e.cm, i, e.sel.primIndex), r) } function Ki(e, t, n, r) { U(e, yi(t, n), r) } function ji(e, t, n) { var r = e.history.done, i = z(r); i && i.ranges ? Xi(e, r[r.length - 1] = t, n) : U(e, t, n) } function U(e, t, n) { Xi(e, t, n), Fi(e, e.sel, e.cm ? e.cm.curOp.id : NaN, n) } function Xi(e, t, n) { (Ye(e, "beforeSelectionChange") || e.cm && Ye(e.cm, "beforeSelectionChange")) && (r = e, o = n, o = { ranges: (i = t).ranges, update: function (e) { this.ranges = []; for (var t = 0; t < e.length; t++)this.ranges[t] = new G(E(r, e[t].anchor), E(r, e[t].head)) }, origin: o && o.origin }, O(r, "beforeSelectionChange", r, o), r.cm && O(r.cm, "beforeSelectionChange", r.cm, o), t = o.ranges != i.ranges ? vi(r.cm, o.ranges, o.ranges.length - 1) : i); var r, i, o = n && n.bias || (P(t.primary().head, e.sel.primary().head) < 0 ? -1 : 1); Yi(e, _i(e, t, o, !0)), n && !1 === n.scroll || !e.cm || "nocursor" == e.cm.getOption("readOnly") || Pr(e.cm) } function Yi(e, t) { t.equals(e.sel) || (e.sel = t, e.cm && (e.cm.curOp.updateInput = 1, e.cm.curOp.selectionChanged = !0, Xe(e.cm)), b(e, "cursorActivity", e)) } function $i(e) { Yi(e, _i(e, e.sel, null, !1)) } function _i(e, t, n, r) { for (var i, o = 0; o < t.ranges.length; o++) { var l = t.ranges[o], s = t.ranges.length == e.sel.ranges.length && e.sel.ranges[o], a = Zi(e, l.anchor, s && s.anchor, n, r), s = l.head == l.anchor ? a : Zi(e, l.head, s && s.head, n, r); !i && a == l.anchor && s == l.head || ((i = i || t.ranges.slice(0, o))[o] = new G(a, s)) } return i ? vi(e.cm, i, t.primIndex) : t } function qi(e, t, n, r, i) { var o = W(e, t.line); if (o.markedSpans) for (var l = 0; l < o.markedSpans.length; ++l) { var s = o.markedSpans[l], a = s.marker, u = "selectLeft" in a ? !a.selectLeft : a.inclusiveLeft, c = "selectRight" in a ? !a.selectRight : a.inclusiveRight; if ((null == s.from || (u ? s.from <= t.ch : s.from < t.ch)) && (null == s.to || (c ? s.to >= t.ch : s.to > t.ch))) { if (i && (O(a, "beforeCursorEnter"), a.explicitlyCleared)) { if (o.markedSpans) { --l; continue } break } if (a.atomic) { if (n) { var s = a.find(r < 0 ? 1 : -1), h = void 0; if ((s = (r < 0 ? c : u) ? Qi(e, s, -r, s && s.line == t.line ? o : null) : s) && s.line == t.line && (h = P(s, n)) && (r < 0 ? h < 0 : 0 < h)) return qi(e, s, t, r, i) } h = a.find(r < 0 ? -1 : 1); return (h = (r < 0 ? u : c) ? Qi(e, h, r, h.line == t.line ? o : null) : h) ? qi(e, h, t, r, i) : null } } } return t } function Zi(e, t, n, r, i) { r = r || 1, i = qi(e, t, n, r, i) || !i && qi(e, t, n, r, !0) || qi(e, t, n, -r, i) || !i && qi(e, t, n, -r, !0); return i || (e.cantEdit = !0, F(e.first, 0)) } function Qi(e, t, n, r) { return n < 0 && 0 == t.ch ? t.line > e.first ? E(e, F(t.line - 1)) : null : 0 < n && t.ch == (r || W(e, t.line)).text.length ? t.line < e.first + e.size - 1 ? F(t.line + 1, 0) : null : new F(t.line, t.ch + n) } function Ji(e) { e.setSelection(F(e.firstLine(), 0), F(e.lastLine()), ve) } function eo(i, e, t) { var o = { canceled: !1, from: e.from, to: e.to, text: e.text, origin: e.origin, cancel: function () { return o.canceled = !0 } }; return t && (o.update = function (e, t, n, r) { e && (o.from = E(i, e)), t && (o.to = E(i, t)), n && (o.text = n), void 0 !== r && (o.origin = r) }), O(i, "beforeChange", i, o), i.cm && O(i.cm, "beforeChange", i.cm, o), o.canceled ? (i.cm && (i.cm.curOp.updateInput = 2), null) : { from: o.from, to: o.to, text: o.text, origin: o.origin } } function to(e, t, n) { if (e.cm) { if (!e.cm.curOp) return I(e.cm, to)(e, t, n); if (e.cm.state.suppressEdits) return } if (!(Ye(e, "beforeChange") || e.cm && Ye(e.cm, "beforeChange")) || (t = eo(e, t, !0))) { var r = Bt && !n && function (e, t, n) { var r = null; if (e.iter(t.line, n.line + 1, function (e) { if (e.markedSpans) for (var t = 0; t < e.markedSpans.length; ++t) { var n = e.markedSpans[t].marker; !n.readOnly || r && -1 != L(r, n) || (r = r || []).push(n) } }), !r) return null; for (var i = [{ from: t, to: n }], o = 0; o < r.length; ++o)for (var l = r[o], s = l.find(0), a = 0; a < i.length; ++a) { var u, c, h, d = i[a]; P(d.to, s.from) < 0 || 0 < P(d.from, s.to) || (u = [a, 1], c = P(d.from, s.from), h = P(d.to, s.to), (c < 0 || !l.inclusiveLeft && !c) && u.push({ from: d.from, to: s.from }), (0 < h || !l.inclusiveRight && !h) && u.push({ from: s.to, to: d.to }), i.splice.apply(i, u), a += u.length - 3) } return i }(e, t.from, t.to); if (r) for (var i = r.length - 1; 0 <= i; --i)no(e, { from: r[i].from, to: r[i].to, text: i ? [""] : t.text, origin: t.origin }); else no(e, t) } } function no(e, n) { var t, r; 1 == n.text.length && "" == n.text[0] && 0 == P(n.from, n.to) || (t = xi(e, n), Hi(e, n, t, e.cm ? e.cm.curOp.id : NaN), oo(e, n, t, Kt(e, n)), r = [], Mi(e, function (e, t) { t || -1 != L(r, e.history) || (uo(e.history, n), r.push(e.history)), oo(e, n, null, Kt(e, n)) })) } function ro(i, o, e) { var t = i.cm && i.cm.state.suppressEdits; if (!t || e) { for (var l, n = i.history, r = i.sel, s = "undo" == o ? n.done : n.undone, a = "undo" == o ? n.undone : n.done, u = 0; u < s.length && (l = s[u], e ? !l.ranges || l.equals(i.sel) : l.ranges); u++); if (u != s.length) { for (n.lastOrigin = n.lastSelOrigin = null; ;) { if (!(l = s.pop()).ranges) { if (t) return void s.push(l); break } if (Pi(l, a), e && !l.equals(i.sel)) return void U(i, l, { clearRedo: !1 }); r = l } for (var c = [], h = (Pi(r, a), a.push({ changes: c, generation: n.generation }), n.generation = l.generation || ++n.maxGeneration, Ye(i, "beforeChange") || i.cm && Ye(i.cm, "beforeChange")), d = l.changes.length - 1; 0 <= d; --d) { var f = function (e) { var n = l.changes[e]; if (n.origin = o, h && !eo(i, n, !1)) return s.length = 0, {}; c.push(Di(i, n)); var t = e ? xi(i, n) : z(s), r = (oo(i, n, t, zi(i, n)), !e && i.cm && i.cm.scrollIntoView({ from: n.from, to: bi(n) }), []); Mi(i, function (e, t) { t || -1 != L(r, e.history) || (uo(e.history, n), r.push(e.history)), oo(e, n, null, zi(e, n)) }) }(d); if (f) return f.v } } } } function io(e, t) { if (0 != t && (e.first += t, e.sel = new B(Se(e.sel.ranges, function (e) { return new G(F(e.anchor.line + t, e.anchor.ch), F(e.head.line + t, e.head.ch)) }), e.sel.primIndex), e.cm)) { R(e.cm, e.first, e.first - t, t); for (var n = e.cm.display, r = n.viewFrom; r < n.viewTo; r++)vr(e.cm, r, "gutter") } } function oo(e, t, n, r) { if (e.cm && !e.cm.curOp) return I(e.cm, oo)(e, t, n, r); if (t.to.line < e.first) io(e, t.text.length - 1 - (t.to.line - t.from.line)); else if (!(t.from.line > e.lastLine())) { t.from.line < e.first && (io(e, i = t.text.length - 1 - (e.first - t.from.line)), t = { from: F(e.first, 0), to: F(t.to.line + i, t.to.ch), text: [z(t.text)], origin: t.origin }); var i = e.lastLine(); if ((t = t.to.line > i ? { from: t.from, to: F(i, W(e, i).text.length), text: [t.text[0]], origin: t.origin } : t).removed = mt(e, t.from, t.to), n = n || xi(e, t), e.cm) { var i = e.cm, o = t, l = r, s = i.doc, a = i.display, u = o.from, c = o.to, h = !1, d = u.line, f = (i.options.lineWrapping || (d = H(tn(W(s, u.line))), s.iter(d, c.line + 1, function (e) { if (e == a.maxLine) return h = !0 })), -1 < s.sel.contains(o.from, o.to) && Xe(i), Ti(s, o, l, fr(i)), i.options.lineWrapping || (s.iter(d, u.line + o.text.length, function (e) { var t = sn(e); t > a.maxLineLength && (a.maxLine = e, a.maxLineLength = t, a.maxLineChanged = !0, h = !1) }), h && (i.curOp.updateMaxLine = !0)), s), p = u.line; if (f.modeFrontier = Math.min(f.modeFrontier, p), !(f.highlightFrontier < p - 10)) { for (var g = f.first, m = p - 1; g < m; m--) { var v = W(f, m).stateAfter; if (v && (!(v instanceof Nt) || m + v.lookAhead < p)) { g = m + 1; break } } f.highlightFrontier = Math.min(f.highlightFrontier, g) } Qr(i, 400), l = o.text.length - (c.line - u.line) - 1, o.full ? R(i) : u.line != c.line || 1 != o.text.length || ki(i.doc, o) ? R(i, u.line, c.line + 1, l) : vr(i, u.line, "text"), d = Ye(i, "changes"), ((s = Ye(i, "change")) || d) && (l = { from: u, to: c, text: o.text, removed: o.removed, origin: o.origin }, s && b(i, "change", i, l), d && (i.curOp.changeObjs || (i.curOp.changeObjs = [])).push(l)), i.display.selForContextMenu = null } else Ti(e, t, r); Xi(e, n, ve), e.cantEdit && Zi(e, F(e.firstLine(), 0)) && (e.cantEdit = !1) } } function lo(e, t, n, r, i) { var o; P(r = r || n, n) < 0 && (n = (o = [r, n])[0], r = o[1]), "string" == typeof t && (t = e.splitLines(t)), to(e, { from: n, to: r, text: t, origin: i }) } function so(e, t, n, r) { n < e.line ? e.line += r : t < e.line && (e.line = t, e.ch = 0) } function ao(e, t, n, r) { for (var i = 0; i < e.length; ++i) { var o = e[i], l = !0; if (o.ranges) { o.copied || ((o = e[i] = o.deepCopy()).copied = !0); for (var s = 0; s < o.ranges.length; s++)so(o.ranges[s].anchor, t, n, r), so(o.ranges[s].head, t, n, r) } else { for (var a = 0; a < o.changes.length; ++a) { var u = o.changes[a]; if (n < u.from.line) u.from = F(u.from.line + r, u.from.ch), u.to = F(u.to.line + r, u.to.ch); else if (t <= u.to.line) { l = !1; break } } l || (e.splice(0, i + 1), i = 0) } } } function uo(e, t) { var n = t.from.line, r = t.to.line, t = t.text.length - (r - n) - 1; ao(e.done, n, r, t), ao(e.undone, n, r, t) } function co(e, t, n, r) { var i = t, o = t; return "number" == typeof t ? o = W(e, Tt(e, t)) : i = H(t), null == i ? null : (r(o, i) && e.cm && vr(e.cm, i, n), o) } function ho(e) { this.lines = e, this.parent = null; for (var t = 0, n = 0; n < e.length; ++n)e[n].parent = this, t += e[n].height; this.height = t } function fo(e) { this.children = e; for (var t = 0, n = 0, r = 0; r < e.length; ++r) { var i = e[r]; t += i.chunkSize(), n += i.height, i.parent = this } this.size = t, this.height = n, this.parent = null } G.prototype.from = function () { return kt(this.anchor, this.head) }, G.prototype.to = function () { return Lt(this.anchor, this.head) }, G.prototype.empty = function () { return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch }, ho.prototype = { chunkSize: function () { return this.lines.length }, removeInner: function (e, t) { for (var n, r = e, i = e + t; r < i; ++r) { var o = this.lines[r]; this.height -= o.height, (n = o).parent = null, Xt(n), b(o, "delete") } this.lines.splice(e, t) }, collapse: function (e) { e.push.apply(e, this.lines) }, insertInner: function (e, t, n) { this.height += n, this.lines = this.lines.slice(0, e).concat(t).concat(this.lines.slice(e)); for (var r = 0; r < t.length; ++r)t[r].parent = this }, iterN: function (e, t, n) { for (var r = e + t; e < r; ++e)if (n(this.lines[e])) return !0 } }, fo.prototype = { chunkSize: function () { return this.size }, removeInner: function (e, t) { this.size -= t; for (var n, r = 0; r < this.children.length; ++r) { var i = this.children[r], o = i.chunkSize(); if (e < o) { var l = Math.min(t, o - e), s = i.height; if (i.removeInner(e, l), this.height -= s - i.height, o == l && (this.children.splice(r--, 1), i.parent = null), 0 == (t -= l)) break; e = 0 } else e -= o } this.size - t < 25 && (1 < this.children.length || !(this.children[0] instanceof ho)) && (this.collapse(n = []), this.children = [new ho(n)], this.children[0].parent = this) }, collapse: function (e) { for (var t = 0; t < this.children.length; ++t)this.children[t].collapse(e) }, insertInner: function (e, t, n) { this.size += t.length, this.height += n; for (var r = 0; r < this.children.length; ++r) { var i = this.children[r], o = i.chunkSize(); if (e <= o) { if (i.insertInner(e, t, n), i.lines && 50 < i.lines.length) { for (var l = i.lines.length % 25 + 25, s = l; s < i.lines.length;) { var a = new ho(i.lines.slice(s, s += 25)); i.height -= a.height, this.children.splice(++r, 0, a), a.parent = this } i.lines = i.lines.slice(0, l), this.maybeSpill() } break } e -= o } }, maybeSpill: function () { if (!(this.children.length <= 10)) { var e = this; do { var t, n = new fo(e.children.splice(e.children.length - 5, 5)) } while (e.parent ? (e.size -= n.size, e.height -= n.height, t = L(e.parent.children, e), e.parent.children.splice(t + 1, 0, n)) : (((t = new fo(e.children)).parent = e).children = [t, n], e = t), n.parent = e.parent, 10 < e.children.length); e.parent.maybeSpill() } }, iterN: function (e, t, n) { for (var r = 0; r < this.children.length; ++r) { var i = this.children[r], o = i.chunkSize(); if (e < o) { var l = Math.min(t, o - e); if (i.iterN(e, l, n)) return !0; if (0 == (t -= l)) break; e = 0 } else e -= o } } }; function po(e, t, n) { if (n) for (var r in n) n.hasOwnProperty(r) && (this[r] = n[r]); this.doc = e, this.node = t } function go(e, t, n) { ln(t) < (e.curOp && e.curOp.scrollTop || e.doc.scrollTop) && Fr(e, n) } po.prototype.clear = function () { var e = this.doc.cm, t = this.line.widgets, n = this.line, r = H(n); if (null != r && t) { for (var i = 0; i < t.length; ++i)t[i] == this && t.splice(i--, 1); t.length || (n.widgets = null); var o = On(this); yt(n, Math.max(0, n.height - o)), e && (h(e, function () { go(e, n, -o), vr(e, r, "widget") }), b(e, "lineWidgetCleared", e, this, r)) } }, po.prototype.changed = function () { var e = this, t = this.height, n = this.doc.cm, r = this.line, i = (this.height = null, On(this) - t); i && (on(this.doc, r) || yt(r, r.height + i), n && h(n, function () { n.curOp.forceUpdate = !0, go(n, r, i), b(n, "lineWidgetChanged", n, e, H(r)) })) }, $e(po); function mo(e, t) { this.lines = [], this.type = t, this.doc = e, this.id = ++vo } var vo = 0; function yo(r, i, o, e, t) { if (e && e.shared) return f = r, n = i, l = o, a = t, (s = fe(s = e)).shared = !1, u = [yo(f, n, l, s, a)], c = u[0], h = s.widgetNode, Mi(f, function (e) { h && (s.widgetNode = h.cloneNode(!0)), u.push(yo(e, E(e, n), E(e, l), s, a)); for (var t = 0; t < e.linked.length; ++t)if (e.linked[t].isParent) return; c = z(u) }), new bo(u, c); var n, l, s, a, u, c, h; if (r.cm && !r.cm.curOp) return I(r.cm, yo)(r, i, o, e, t); var d = new mo(r, t), f = P(i, o); if (e && fe(e, d, !1), 0 < f || 0 == f && !1 !== d.clearWhenEmpty) return d; if (d.replacedWith && (d.collapsed = !0, d.widgetNode = ne("span", [d.replacedWith], "CodeMirror-widget"), e.handleMouseEvents || d.widgetNode.setAttribute("cm-ignore-events", "true"), e.insertLeft && (d.widgetNode.insertLeft = !0)), d.collapsed) { if (en(r, i.line, i, o, d) || i.line != o.line && en(r, o.line, i, o, d)) throw new Error("Inserting collapsed marker partially overlapping an existing one"); Gt = !0 } d.addToHistory && Hi(r, { from: i, to: o, origin: "markText" }, r.sel, NaN); var p, g = i.line, m = r.cm; if (r.iter(g, o.line + 1, function (e) { var t, n; m && d.collapsed && !m.options.lineWrapping && tn(e) == m.display.maxLine && (p = !0), d.collapsed && g != i.line && yt(e, 0), e = e, t = new Ut(d, g == i.line ? i.ch : null, g == o.line ? o.ch : null), (n = (n = r.cm && r.cm.curOp) && window.WeakSet && (n.markedSpans || (n.markedSpans = new WeakSet))) && e.markedSpans && n.has(e.markedSpans) ? e.markedSpans.push(t) : (e.markedSpans = e.markedSpans ? e.markedSpans.concat([t]) : [t], n && n.add(e.markedSpans)), t.marker.attachLine(e), ++g }), d.collapsed && r.iter(i.line, o.line + 1, function (e) { on(r, e) && yt(e, 0) }), d.clearOnEnter && k(d, "beforeCursorEnter", function () { return d.clear() }), d.readOnly && (Bt = !0, (r.history.done.length || r.history.undone.length) && r.clearHistory()), d.collapsed && (d.id = ++vo, d.atomic = !0), m) { if (p && (m.curOp.updateMaxLine = !0), d.collapsed) R(m, i.line, o.line + 1); else if (d.className || d.startStyle || d.endStyle || d.css || d.attributes || d.title) for (var v = i.line; v <= o.line; v++)vr(m, v, "text"); d.atomic && $i(m.doc), b(m, "markerAdded", m, d) } return d } mo.prototype.clear = function () { if (!this.explicitlyCleared) { for (var e, t = this.doc.cm, n = t && !t.curOp, r = (n && qr(t), !Ye(this, "clear") || (e = this.find()) && b(this, "clear", e.from, e.to), null), i = null, o = 0; o < this.lines.length; ++o) { var l = this.lines[o], s = Vt(l.markedSpans, this); t && !this.collapsed ? vr(t, H(l), "text") : t && (null != s.to && (i = H(l)), null != s.from && (r = H(l))), l.markedSpans = function (e, t) { for (var n, r = 0; r < e.length; ++r)e[r] != t && (n = n || []).push(e[r]); return n }(l.markedSpans, s), null == s.from && this.collapsed && !on(this.doc, l) && t && yt(l, ur(t.display)) } if (t && this.collapsed && !t.options.lineWrapping) for (var a = 0; a < this.lines.length; ++a) { var u = tn(this.lines[a]), c = sn(u); c > t.display.maxLineLength && (t.display.maxLine = u, t.display.maxLineLength = c, t.display.maxLineChanged = !0) } null != r && t && this.collapsed && R(t, r, i + 1), this.lines.length = 0, this.explicitlyCleared = !0, this.atomic && this.doc.cantEdit && (this.doc.cantEdit = !1, t && $i(t.doc)), t && b(t, "markerCleared", t, this, r, i), n && Zr(t), this.parent && this.parent.clear() } }, mo.prototype.find = function (e, t) { var n, r; null == e && "bookmark" == this.type && (e = 1); for (var i = 0; i < this.lines.length; ++i) { var o = this.lines[i], l = Vt(o.markedSpans, this); if (null != l.from && (n = F(t ? o : H(o), l.from), -1 == e)) return n; if (null != l.to && (r = F(t ? o : H(o), l.to), 1 == e)) return r } return n && { from: n, to: r } }, mo.prototype.changed = function () { var n = this, r = this.find(-1, !0), i = this, o = this.doc.cm; r && o && h(o, function () { var e = r.line, t = H(r.line), t = In(o, t); t && (jn(t), o.curOp.selectionChanged = o.curOp.forceUpdate = !0), o.curOp.updateMaxLine = !0, on(i.doc, e) || null == i.height || (t = i.height, i.height = null, (t = On(i) - t) && yt(e, e.height + t)), b(o, "markerChanged", o, n) }) }, mo.prototype.attachLine = function (e) { var t; this.lines.length || !this.doc.cm || (t = this.doc.cm.curOp).maybeHiddenMarkers && -1 != L(t.maybeHiddenMarkers, this) || (t.maybeUnhiddenMarkers || (t.maybeUnhiddenMarkers = [])).push(this), this.lines.push(e) }, mo.prototype.detachLine = function (e) { this.lines.splice(L(this.lines, e), 1), !this.lines.length && this.doc.cm && ((e = this.doc.cm.curOp).maybeHiddenMarkers || (e.maybeHiddenMarkers = [])).push(this) }, $e(mo); var bo = function (e, t) { this.markers = e, this.primary = t; for (var n = 0; n < e.length; ++n)e[n].parent = this }; function wo(e) { return e.findMarks(F(e.first, 0), e.clipPos(F(e.lastLine())), function (e) { return e.parent }) } function xo(o) { for (var e = 0; e < o.length; e++)!function (e) { var t = o[e], n = [t.primary.doc]; Mi(t.primary.doc, function (e) { return n.push(e) }); for (var r = 0; r < t.markers.length; r++) { var i = t.markers[r]; -1 == L(n, i.doc) && (i.parent = null, t.markers.splice(r--, 1)) } }(e) } bo.prototype.clear = function () { if (!this.explicitlyCleared) { this.explicitlyCleared = !0; for (var e = 0; e < this.markers.length; ++e)this.markers[e].clear(); b(this, "clear") } }, bo.prototype.find = function (e, t) { return this.primary.find(e, t) }, $e(bo); function f(e, t, n, r, i) { if (!(this instanceof f)) return new f(e, t, n, r, i); null == n && (n = 0), fo.call(this, [new ho([new un("", null)])]), this.first = n, this.scrollTop = this.scrollLeft = 0, this.cantEdit = !1, this.cleanGeneration = 1, n = F(this.modeFrontier = this.highlightFrontier = n, 0), this.sel = yi(n), this.history = new Ai(null), this.id = ++Co, this.modeOption = t, this.lineSep = r, this.direction = "rtl" == i ? "rtl" : "ltr", this.extend = !1, "string" == typeof e && (e = this.splitLines(e)), Ti(this, { from: n, to: n, text: e }), U(this, yi(n), ve) } var Co = 0, So = ((f.prototype = ke(fo.prototype, { constructor: f, iter: function (e, t, n) { n ? this.iterN(e - this.first, t - e, n) : this.iterN(this.first, this.first + this.size, e) }, insert: function (e, t) { for (var n = 0, r = 0; r < t.length; ++r)n += t[r].height; this.insertInner(e - this.first, t, n) }, remove: function (e, t) { this.removeInner(e - this.first, t) }, getValue: function (e) { var t = vt(this, this.first, this.first + this.size); return !1 === e ? t : t.join(e || this.lineSeparator()) }, setValue: n(function (e) { var t = F(this.first, 0), n = this.first + this.size - 1; to(this, { from: t, to: F(n, W(this, n).text.length), text: this.splitLines(e), origin: "setValue", full: !0 }, !0), this.cm && Er(this.cm, 0, 0), U(this, yi(t), ve) }), replaceRange: function (e, t, n, r) { lo(this, e, t = E(this, t), n = n ? E(this, n) : t, r) }, getRange: function (e, t, n) { e = mt(this, E(this, e), E(this, t)); return !1 === n ? e : "" === n ? e.join("") : e.join(n || this.lineSeparator()) }, getLine: function (e) { e = this.getLineHandle(e); return e && e.text }, getLineHandle: function (e) { if (wt(this, e)) return W(this, e) }, getLineNumber: H, getLineHandleVisualStart: function (e) { return tn(e = "number" == typeof e ? W(this, e) : e) }, lineCount: function () { return this.size }, firstLine: function () { return this.first }, lastLine: function () { return this.first + this.size - 1 }, clipPos: function (e) { return E(this, e) }, getCursor: function (e) { var t = this.sel.primary(), e = null == e || "head" == e ? t.head : "anchor" == e ? t.anchor : "end" == e || "to" == e || !1 === e ? t.to() : t.from(); return e }, listSelections: function () { return this.sel.ranges }, somethingSelected: function () { return this.sel.somethingSelected() }, setCursor: n(function (e, t, n) { Ki(this, E(this, "number" == typeof e ? F(e, t || 0) : e), null, n) }), setSelection: n(function (e, t, n) { Ki(this, E(this, e), E(this, t || e), n) }), extendSelection: n(function (e, t, n) { Gi(this, E(this, e), t && E(this, t), n) }), extendSelections: n(function (e, t) { Ui(this, Mt(this, e), t) }), extendSelectionsBy: n(function (e, t) { Ui(this, Mt(this, Se(this.sel.ranges, e)), t) }), setSelections: n(function (e, t, n) { if (e.length) { for (var r = [], i = 0; i < e.length; i++)r[i] = new G(E(this, e[i].anchor), E(this, e[i].head || e[i].anchor)); null == t && (t = Math.min(e.length - 1, this.sel.primIndex)), U(this, vi(this.cm, r, t), n) } }), addSelection: n(function (e, t, n) { var r = this.sel.ranges.slice(0); r.push(new G(E(this, e), E(this, t || e))), U(this, vi(this.cm, r, r.length - 1), n) }), getSelection: function (e) { for (var t = this.sel.ranges, n = 0; n < t.length; n++)var r = mt(this, t[n].from(), t[n].to()), i = i ? i.concat(r) : r; return !1 === e ? i : i.join(e || this.lineSeparator()) }, getSelections: function (e) { for (var t = [], n = this.sel.ranges, r = 0; r < n.length; r++) { var i = mt(this, n[r].from(), n[r].to()); !1 !== e && (i = i.join(e || this.lineSeparator())), t[r] = i } return t }, replaceSelection: function (e, t, n) { for (var r = [], i = 0; i < this.sel.ranges.length; i++)r[i] = e; this.replaceSelections(r, t, n || "+input") }, replaceSelections: n(function (e, t, n) { for (var r = [], i = this.sel, o = 0; o < i.ranges.length; o++) { var l = i.ranges[o]; r[o] = { from: l.from(), to: l.to(), text: this.splitLines(e[o]), origin: n } } for (var t = t && "end" != t && function (e, t, n) { for (var r = [], i = u = F(e.first, 0), o = 0; o < t.length; o++) { var l = t[o], s = Ci(l.from, u, i), a = Ci(bi(l), u, i), u = l.to, i = a; "around" == n ? (l = P((l = e.sel.ranges[o]).head, l.anchor) < 0, r[o] = new G(l ? a : s, l ? s : a)) : r[o] = new G(s, s) } return new B(r, e.sel.primIndex) }(this, r, t), s = r.length - 1; 0 <= s; s--)to(this, r[s]); t ? ji(this, t) : this.cm && Pr(this.cm) }), undo: n(function () { ro(this, "undo") }), redo: n(function () { ro(this, "redo") }), undoSelection: n(function () { ro(this, "undo", !0) }), redoSelection: n(function () { ro(this, "redo", !0) }), setExtending: function (e) { this.extend = e }, getExtending: function () { return this.extend }, historySize: function () { for (var e = this.history, t = 0, n = 0, r = 0; r < e.done.length; r++)e.done[r].ranges || ++t; for (var i = 0; i < e.undone.length; i++)e.undone[i].ranges || ++n; return { undo: t, redo: n } }, clearHistory: function () { var t = this; this.history = new Ai(this.history), Mi(this, function (e) { return e.history = t.history }, !0) }, markClean: function () { this.cleanGeneration = this.changeGeneration(!0) }, changeGeneration: function (e) { return e && (this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null), this.history.generation }, isClean: function (e) { return this.history.generation == (e || this.cleanGeneration) }, getHistory: function () { return { done: Ii(this.history.done), undone: Ii(this.history.undone) } }, setHistory: function (e) { var t = this.history = new Ai(this.history); t.done = Ii(e.done.slice(0), null, !0), t.undone = Ii(e.undone.slice(0), null, !0) }, setGutterMarker: n(function (e, n, r) { return co(this, e, "gutter", function (e) { var t = e.gutterMarkers || (e.gutterMarkers = {}); return !(t[n] = r) && Oe(t) && (e.gutterMarkers = null), 1 }) }), clearGutter: n(function (t) { var n = this; this.iter(function (e) { e.gutterMarkers && e.gutterMarkers[t] && co(n, e, "gutter", function () { return e.gutterMarkers[t] = null, Oe(e.gutterMarkers) && (e.gutterMarkers = null), 1 }) }) }), lineInfo: function (e) { var t; if ("number" == typeof e) { if (!wt(this, e)) return null; if (!(e = W(this, t = e))) return null } else if (null == (t = H(e))) return null; return { line: t, handle: e, text: e.text, gutterMarkers: e.gutterMarkers, textClass: e.textClass, bgClass: e.bgClass, wrapClass: e.wrapClass, widgets: e.widgets } }, addLineClass: n(function (e, n, r) { return co(this, e, "gutter" == n ? "gutter" : "class", function (e) { var t = "text" == n ? "textClass" : "background" == n ? "bgClass" : "gutter" == n ? "gutterClass" : "wrapClass"; if (e[t]) { if (J(r).test(e[t])) return; e[t] += " " + r } else e[t] = r; return 1 }) }), removeLineClass: n(function (e, o, l) { return co(this, e, "gutter" == o ? "gutter" : "class", function (e) { var t = "text" == o ? "textClass" : "background" == o ? "bgClass" : "gutter" == o ? "gutterClass" : "wrapClass", n = e[t]; if (n) { if (null == l) e[t] = null; else { var r = n.match(J(l)); if (!r) return; var i = r.index + r[0].length; e[t] = n.slice(0, r.index) + (r.index && i != n.length ? " " : "") + n.slice(i) || null } return 1 } }) }), addLineWidget: n(function (e, t, n) { return e = e, i = new po(r = this, t, n), (o = r.cm) && i.noHScroll && (o.display.alignWidgets = !0), co(r, e, "widget", function (e) { var t = e.widgets || (e.widgets = []); return null == i.insertAt ? t.push(i) : t.splice(Math.min(t.length, Math.max(0, i.insertAt)), 0, i), i.line = e, o && !on(r, e) && (t = ln(e) < r.scrollTop, yt(e, e.height + On(i)), t && Fr(o, i.height), o.curOp.forceUpdate = !0), 1 }), o && b(o, "lineWidgetAdded", o, i, "number" == typeof e ? e : H(e)), i; var r, i, o }), removeLineWidget: function (e) { e.clear() }, markText: function (e, t, n) { return yo(this, E(this, e), E(this, t), n, n && n.type || "range") }, setBookmark: function (e, t) { t = { replacedWith: t && (null == t.nodeType ? t.widget : t), insertLeft: t && t.insertLeft, clearWhenEmpty: !1, shared: t && t.shared, handleMouseEvents: t && t.handleMouseEvents }; return yo(this, e = E(this, e), e, t, "bookmark") }, findMarksAt: function (e) { var t = [], n = W(this, (e = E(this, e)).line).markedSpans; if (n) for (var r = 0; r < n.length; ++r) { var i = n[r]; (null == i.from || i.from <= e.ch) && (null == i.to || i.to >= e.ch) && t.push(i.marker.parent || i.marker) } return t }, findMarks: function (i, o, l) { i = E(this, i), o = E(this, o); var s = [], a = i.line; return this.iter(i.line, o.line + 1, function (e) { var t = e.markedSpans; if (t) for (var n = 0; n < t.length; n++) { var r = t[n]; null != r.to && a == i.line && i.ch >= r.to || null == r.from && a != i.line || null != r.from && a == o.line && r.from >= o.ch || l && !l(r.marker) || s.push(r.marker.parent || r.marker) } ++a }), s }, getAllMarks: function () { var r = []; return this.iter(function (e) { var t = e.markedSpans; if (t) for (var n = 0; n < t.length; ++n)null != t[n].from && r.push(t[n].marker) }), r }, posFromIndex: function (t) { var n, r = this.first, i = this.lineSeparator().length; return this.iter(function (e) { e = e.text.length + i; if (t < e) return n = t, !0; t -= e, ++r }), E(this, F(r, n)) }, indexFromPos: function (e) { var t = (e = E(this, e)).ch; if (e.line < this.first || e.ch < 0) return 0; var n = this.lineSeparator().length; return this.iter(this.first, e.line, function (e) { t += e.text.length + n }), t }, copy: function (e) { var t = new f(vt(this, this.first, this.first + this.size), this.modeOption, this.first, this.lineSep, this.direction); return t.scrollTop = this.scrollTop, t.scrollLeft = this.scrollLeft, t.sel = this.sel, t.extend = !1, e && (t.history.undoDepth = this.history.undoDepth, t.setHistory(this.getHistory())), t }, linkedDoc: function (e) { for (var t = this.first, n = this.first + this.size, n = (null != (e = e || {}).from && e.from > t && (t = e.from), null != e.to && e.to < n && (n = e.to), new f(vt(this, t, n), e.mode || this.modeOption, t, this.lineSep, this.direction)), r = (e.sharedHist && (n.history = this.history), (this.linked || (this.linked = [])).push({ doc: n, sharedHist: e.sharedHist }), n.linked = [{ doc: this, isParent: !0, sharedHist: e.sharedHist }], n), i = wo(this), o = 0; o < i.length; o++) { var l = i[o], s = l.find(), a = r.clipPos(s.from), s = r.clipPos(s.to); P(a, s) && (a = yo(r, a, s, l.primary, l.primary.type), l.markers.push(a), a.parent = l) } return n }, unlinkDoc: function (e) { if (e instanceof p && (e = e.doc), this.linked) for (var t = 0; t < this.linked.length; ++t) { var n = this.linked[t]; if (n.doc == e) { this.linked.splice(t, 1), e.unlinkDoc(this), xo(wo(this)); break } } var r; e.history == this.history && (r = [e.id], Mi(e, function (e) { return r.push(e.id) }, !0), e.history = new Ai(null), e.history.done = Ii(this.history.done, r), e.history.undone = Ii(this.history.undone, r)) }, iterLinkedDocs: function (e) { Mi(this, e) }, getMode: function () { return this.mode }, getEditor: function () { return this.cm }, splitLines: function (e) { return this.lineSep ? e.split(this.lineSep) : rt(e) }, lineSeparator: function () { return this.lineSep || "\n" }, setDirection: n(function (e) { var t; (e = "rtl" != e ? "ltr" : e) != this.direction && (this.direction = e, this.iter(function (e) { return e.order = null }), this.cm && h(t = this.cm, function () { Oi(t), R(t) })) }) })).eachLine = f.prototype.iter, 0); function Lo(e) { var r = this; if (ko(r), !A(r, e) && !An(r.display, e)) { D(e), w && (So = +new Date); var t = gr(r, e, !0), n = e.dataTransfer.files; if (t && !r.isReadOnly()) if (n && n.length && window.FileReader && window.File) for (var i = n.length, o = Array(i), l = 0, s = function () { ++l == i && I(r, function () { var e = { from: t = E(r.doc, t), to: t, text: r.doc.splitLines(o.filter(function (e) { return null != e }).join(r.doc.lineSeparator())), origin: "paste" }; to(r.doc, e), ji(r.doc, yi(E(r.doc, t), E(r.doc, bi(e)))) })() }, a = 0; a < n.length; a++)!function (e, t) { var n; r.options.allowDropFileTypes && -1 == L(r.options.allowDropFileTypes, e.type) ? s() : ((n = new FileReader).onerror = function () { return s() }, n.onload = function () { var e = n.result; /[\x00-\x08\x0e-\x1f]{2}/.test(e) || (o[t] = e), s() }, n.readAsText(e)) }(n[a], a); else { if (r.state.draggingText && -1 < r.doc.sel.contains(t)) return r.state.draggingText(e), void setTimeout(function () { return r.display.input.focus() }, 20); try { var u, c = e.dataTransfer.getData("Text"); if (c) { if (r.state.draggingText && !r.state.draggingText.copy && (u = r.listSelections()), Xi(r.doc, yi(t, t)), u) for (var h = 0; h < u.length; ++h)lo(r.doc, "", u[h].anchor, u[h].head, "drag"); r.replaceSelection(c, "around", "paste"), r.display.input.focus() } } catch (e) { } } } } function ko(e) { e.display.dragCursor && (e.display.lineSpace.removeChild(e.display.dragCursor), e.display.dragCursor = null) } function To(t) { if (document.getElementsByClassName) { for (var e = document.getElementsByClassName("CodeMirror"), n = [], r = 0; r < e.length; r++) { var i = e[r].CodeMirror; i && n.push(i) } n.length && n[0].operation(function () { for (var e = 0; e < n.length; e++)t(n[e]) }) } } var Mo = !1; function No() { var e; Mo || (k(window, "resize", function () { null == e && (e = setTimeout(function () { e = null, To(Oo) }, 100)) }), k(window, "blur", function () { return To(Or) }), Mo = !0) } function Oo(e) { var t = e.display; t.cachedCharWidth = t.cachedTextHeight = t.cachedPaddingH = null, t.scrollbarsClipped = !1, e.setSize() } for (var Ao = { 3: "Pause", 8: "Backspace", 9: "Tab", 13: "Enter", 16: "Shift", 17: "Ctrl", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Esc", 32: "Space", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "Left", 38: "Up", 39: "Right", 40: "Down", 44: "PrintScrn", 45: "Insert", 46: "Delete", 59: ";", 61: "=", 91: "Mod", 92: "Mod", 93: "Mod", 106: "*", 107: "=", 109: "-", 110: ".", 111: "/", 145: "ScrollLock", 173: "-", 186: ";", 187: "=", 188: ",", 189: "-", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\", 221: "]", 222: "'", 224: "Mod", 63232: "Up", 63233: "Down", 63234: "Left", 63235: "Right", 63272: "Delete", 63273: "Home", 63275: "End", 63276: "PageUp", 63277: "PageDown", 63302: "Insert" }, Do = 0; Do < 10; Do++)Ao[Do + 48] = Ao[Do + 96] = String(Do); for (var Wo = 65; Wo <= 90; Wo++)Ao[Wo] = String.fromCharCode(Wo); for (var Ho = 1; Ho <= 12; Ho++)Ao[Ho + 111] = Ao[Ho + 63235] = "F" + Ho; var Fo = {}; function Po(e) { var t, n, r, i, o = e.split(/-(?!$)/); e = o[o.length - 1]; for (var l = 0; l < o.length - 1; l++) { var s = o[l]; if (/^(cmd|meta|m)$/i.test(s)) i = !0; else if (/^a(lt)?$/i.test(s)) t = !0; else if (/^(c|ctrl|control)$/i.test(s)) n = !0; else { if (!/^s(hift)?$/i.test(s)) throw new Error("Unrecognized modifier name: " + s); r = !0 } } return t && (e = "Alt-" + e), n && (e = "Ctrl-" + e), i && (e = "Cmd-" + e), e = r ? "Shift-" + e : e } function Eo(e) { var t, n, r = {}; for (t in e) if (e.hasOwnProperty(t)) { var i = e[t]; if (!/^(name|fallthrough|(de|at)tach)$/.test(t)) if ("..." == i) delete e[t]; else { for (var o = Se(t.split(" "), Po), l = 0; l < o.length; l++) { var s = void 0, a = void 0, s = l == o.length - 1 ? (a = o.join(" "), i) : (a = o.slice(0, l + 1).join(" "), "..."), u = r[a]; if (u) { if (u != s) throw new Error("Inconsistent bindings for " + a) } else r[a] = s } delete e[t] } } for (n in r) e[n] = r[n]; return e } function Ro(e, t, n, r) { var i = (t = Go(t)).call ? t.call(e, r) : t[e]; if (!1 === i) return "nothing"; if ("..." === i) return "multi"; if (null != i && n(i)) return "handled"; if (t.fallthrough) { if ("[object Array]" != Object.prototype.toString.call(t.fallthrough)) return Ro(e, t.fallthrough, n, r); for (var o = 0; o < t.fallthrough.length; o++) { var l = Ro(e, t.fallthrough[o], n, r); if (l) return l } } } function zo(e) { e = "string" == typeof e ? e : Ao[e.keyCode]; return "Ctrl" == e || "Alt" == e || "Shift" == e || "Mod" == e } function Io(e, t, n) { var r = e; return t.altKey && "Alt" != r && (e = "Alt-" + e), (Z ? t.metaKey : t.ctrlKey) && "Ctrl" != r && (e = "Ctrl-" + e), (Z ? t.ctrlKey : t.metaKey) && "Mod" != r && (e = "Cmd-" + e), e = !n && t.shiftKey && "Shift" != r ? "Shift-" + e : e } function Bo(e, t) { if (K && 34 == e.keyCode && e.char) return !1; var n = Ao[e.keyCode]; return null != n && !e.altGraphKey && Io(n = 3 == e.keyCode && e.code ? e.code : n, e, t) } function Go(e) { return "string" == typeof e ? Fo[e] : e } function Uo(t, e) { for (var n = t.doc.sel.ranges, r = [], i = 0; i < n.length; i++) { for (var o = e(n[i]); r.length && P(o.from, z(r).to) <= 0;) { var l = r.pop(); if (P(l.from, o.from) < 0) { o.from = l.from; break } } r.push(o) } h(t, function () { for (var e = r.length - 1; 0 <= e; e--)lo(t.doc, "", r[e].from, r[e].to, "+delete"); Pr(t) }) } function Vo(e, t, n) { t = We(e.text, t + n, n); return t < 0 || t > e.text.length ? null : t } function Ko(e, t, n) { e = Vo(e, t.ch, n); return null == e ? null : new F(t.line, e, n < 0 ? "after" : "before") } function jo(e, t, n, r, i) { if (e) { "rtl" == t.doc.direction && (i = -i); var o, l, s, a, e = Ve(n, t.doc.direction); if (e) return o = i < 0 == (1 == (e = i < 0 ? z(e) : e[0]).level) ? "after" : "before", 0 < e.level || "rtl" == t.doc.direction ? (l = Bn(t, n), s = i < 0 ? n.text.length - 1 : 0, a = Gn(t, l, s).top, s = He(function (e) { return Gn(t, l, e).top == a }, i < 0 == (1 == e.level) ? e.from : e.to - 1, s), "before" == o && (s = Vo(n, s, 1))) : s = i < 0 ? e.to : e.from, new F(r, s, o) } return new F(r, i < 0 ? n.text.length : 0, i < 0 ? "before" : "after") } function Xo(t, n, s, e) { var a = Ve(n, t.doc.direction); if (!a) return Ko(n, s, e); s.ch >= n.text.length ? (s.ch = n.text.length, s.sticky = "before") : s.ch <= 0 && (s.ch = 0, s.sticky = "after"); var r = Pe(a, s.ch, s.sticky), i = a[r]; if ("ltr" == t.doc.direction && i.level % 2 == 0 && (0 < e ? i.to > s.ch : i.from < s.ch)) return Ko(n, s, e); function u(e, t) { return Vo(n, e instanceof F ? e.ch : e, t) } function o(e) { return t.options.lineWrapping ? (l = l || Bn(t, n), or(t, n, l, e)) : { begin: 0, end: n.text.length } } var l, c = o("before" == s.sticky ? u(s, -1) : s.ch); if ("rtl" == t.doc.direction || 1 == i.level) { var h = 1 == i.level == e < 0, d = u(s, h ? 1 : -1); if (null != d && (h ? d <= i.to && d <= c.end : d >= i.from && d >= c.begin)) return new F(s.line, d, h ? "before" : "after") } function f(e, t, n) { for (var r = function (e, t) { return t ? new F(s.line, u(e, 1), "before") : new F(s.line, e, "after") }; 0 <= e && e < a.length; e += t) { var i = a[e], o = 0 < t == (1 != i.level), l = o ? n.begin : u(n.end, -1); if (i.from <= l && l < i.to) return r(l, o); if (l = o ? i.from : u(i.to, -1), n.begin <= l && l < n.end) return r(l, o) } } i = f(r + e, e, c); if (i) return i; d = 0 < e ? c.end : u(c.begin, -1); return null == d || 0 < e && d == n.text.length || !(i = f(0 < e ? 0 : a.length - 1, e, o(d))) ? null : i } Fo.basic = { Left: "goCharLeft", Right: "goCharRight", Up: "goLineUp", Down: "goLineDown", End: "goLineEnd", Home: "goLineStartSmart", PageUp: "goPageUp", PageDown: "goPageDown", Delete: "delCharAfter", Backspace: "delCharBefore", "Shift-Backspace": "delCharBefore", Tab: "defaultTab", "Shift-Tab": "indentAuto", Enter: "newlineAndIndent", Insert: "toggleOverwrite", Esc: "singleSelection" }, Fo.pcDefault = { "Ctrl-A": "selectAll", "Ctrl-D": "deleteLine", "Ctrl-Z": "undo", "Shift-Ctrl-Z": "redo", "Ctrl-Y": "redo", "Ctrl-Home": "goDocStart", "Ctrl-End": "goDocEnd", "Ctrl-Up": "goLineUp", "Ctrl-Down": "goLineDown", "Ctrl-Left": "goGroupLeft", "Ctrl-Right": "goGroupRight", "Alt-Left": "goLineStart", "Alt-Right": "goLineEnd", "Ctrl-Backspace": "delGroupBefore", "Ctrl-Delete": "delGroupAfter", "Ctrl-S": "save", "Ctrl-F": "find", "Ctrl-G": "findNext", "Shift-Ctrl-G": "findPrev", "Shift-Ctrl-F": "replace", "Shift-Ctrl-R": "replaceAll", "Ctrl-[": "indentLess", "Ctrl-]": "indentMore", "Ctrl-U": "undoSelection", "Shift-Ctrl-U": "redoSelection", "Alt-U": "redoSelection", fallthrough: "basic" }, Fo.emacsy = { "Ctrl-F": "goCharRight", "Ctrl-B": "goCharLeft", "Ctrl-P": "goLineUp", "Ctrl-N": "goLineDown", "Ctrl-A": "goLineStart", "Ctrl-E": "goLineEnd", "Ctrl-V": "goPageDown", "Shift-Ctrl-V": "goPageUp", "Ctrl-D": "delCharAfter", "Ctrl-H": "delCharBefore", "Alt-Backspace": "delWordBefore", "Ctrl-K": "killLine", "Ctrl-T": "transposeChars", "Ctrl-O": "openLine" }, Fo.macDefault = { "Cmd-A": "selectAll", "Cmd-D": "deleteLine", "Cmd-Z": "undo", "Shift-Cmd-Z": "redo", "Cmd-Y": "redo", "Cmd-Home": "goDocStart", "Cmd-Up": "goDocStart", "Cmd-End": "goDocEnd", "Cmd-Down": "goDocEnd", "Alt-Left": "goGroupLeft", "Alt-Right": "goGroupRight", "Cmd-Left": "goLineLeft", "Cmd-Right": "goLineRight", "Alt-Backspace": "delGroupBefore", "Ctrl-Alt-Backspace": "delGroupAfter", "Alt-Delete": "delGroupAfter", "Cmd-S": "save", "Cmd-F": "find", "Cmd-G": "findNext", "Shift-Cmd-G": "findPrev", "Cmd-Alt-F": "replace", "Shift-Cmd-Alt-F": "replaceAll", "Cmd-[": "indentLess", "Cmd-]": "indentMore", "Cmd-Backspace": "delWrappedLineLeft", "Cmd-Delete": "delWrappedLineRight", "Cmd-U": "undoSelection", "Shift-Cmd-U": "redoSelection", "Ctrl-Up": "goDocStart", "Ctrl-Down": "goDocEnd", fallthrough: ["basic", "emacsy"] }, Fo.default = C ? Fo.macDefault : Fo.pcDefault; var Yo = { selectAll: Ji, singleSelection: function (e) { return e.setSelection(e.getCursor("anchor"), e.getCursor("head"), ve) }, killLine: function (n) { return Uo(n, function (e) { var t; return e.empty() ? (t = W(n.doc, e.head.line).text.length, e.head.ch == t && e.head.line < n.lastLine() ? { from: e.head, to: F(e.head.line + 1, 0) } : { from: e.head, to: F(e.head.line, t) }) : { from: e.from(), to: e.to() } }) }, deleteLine: function (t) { return Uo(t, function (e) { return { from: F(e.from().line, 0), to: E(t.doc, F(e.to().line + 1, 0)) } }) }, delLineLeft: function (e) { return Uo(e, function (e) { return { from: F(e.from().line, 0), to: e.from() } }) }, delWrappedLineLeft: function (n) { return Uo(n, function (e) { var t = n.charCoords(e.head, "div").top + 5; return { from: n.coordsChar({ left: 0, top: t }, "div"), to: e.from() } }) }, delWrappedLineRight: function (n) { return Uo(n, function (e) { var t = n.charCoords(e.head, "div").top + 5, t = n.coordsChar({ left: n.display.lineDiv.offsetWidth + 100, top: t }, "div"); return { from: e.from(), to: t } }) }, undo: function (e) { return e.undo() }, redo: function (e) { return e.redo() }, undoSelection: function (e) { return e.undoSelection() }, redoSelection: function (e) { return e.redoSelection() }, goDocStart: function (e) { return e.extendSelection(F(e.firstLine(), 0)) }, goDocEnd: function (e) { return e.extendSelection(F(e.lastLine())) }, goLineStart: function (t) { return t.extendSelectionsBy(function (e) { return $o(t, e.head.line) }, { origin: "+move", bias: 1 }) }, goLineStartSmart: function (t) { return t.extendSelectionsBy(function (e) { return _o(t, e.head) }, { origin: "+move", bias: 1 }) }, goLineEnd: function (i) { return i.extendSelectionsBy(function (e) { var t = i, e = e.head.line, n = W(t.doc, e), r = function (e) { for (var t; t = Jt(e);)e = t.find(1, !0).line; return e }(n); return r != n && (e = H(r)), jo(!0, t, n, e, -1) }, { origin: "+move", bias: -1 }) }, goLineRight: function (t) { return t.extendSelectionsBy(function (e) { e = t.cursorCoords(e.head, "div").top + 5; return t.coordsChar({ left: t.display.lineDiv.offsetWidth + 100, top: e }, "div") }, be) }, goLineLeft: function (t) { return t.extendSelectionsBy(function (e) { e = t.cursorCoords(e.head, "div").top + 5; return t.coordsChar({ left: 0, top: e }, "div") }, be) }, goLineLeftSmart: function (n) { return n.extendSelectionsBy(function (e) { var t = n.cursorCoords(e.head, "div").top + 5, t = n.coordsChar({ left: 0, top: t }, "div"); return t.ch < n.getLine(t.line).search(/\S/) ? _o(n, e.head) : t }, be) }, goLineUp: function (e) { return e.moveV(-1, "line") }, goLineDown: function (e) { return e.moveV(1, "line") }, goPageUp: function (e) { return e.moveV(-1, "page") }, goPageDown: function (e) { return e.moveV(1, "page") }, goCharLeft: function (e) { return e.moveH(-1, "char") }, goCharRight: function (e) { return e.moveH(1, "char") }, goColumnLeft: function (e) { return e.moveH(-1, "column") }, goColumnRight: function (e) { return e.moveH(1, "column") }, goWordLeft: function (e) { return e.moveH(-1, "word") }, goGroupRight: function (e) { return e.moveH(1, "group") }, goGroupLeft: function (e) { return e.moveH(-1, "group") }, goWordRight: function (e) { return e.moveH(1, "word") }, delCharBefore: function (e) { return e.deleteH(-1, "codepoint") }, delCharAfter: function (e) { return e.deleteH(1, "char") }, delWordBefore: function (e) { return e.deleteH(-1, "word") }, delWordAfter: function (e) { return e.deleteH(1, "word") }, delGroupBefore: function (e) { return e.deleteH(-1, "group") }, delGroupAfter: function (e) { return e.deleteH(1, "group") }, indentAuto: function (e) { return e.indentSelection("smart") }, indentMore: function (e) { return e.indentSelection("add") }, indentLess: function (e) { return e.indentSelection("subtract") }, insertTab: function (e) { return e.replaceSelection("\t") }, insertSoftTab: function (e) { for (var t = [], n = e.listSelections(), r = e.options.tabSize, i = 0; i < n.length; i++) { var o = n[i].from(), o = S(e.getLine(o.line), o.ch, r); t.push(Ce(r - o % r)) } e.replaceSelections(t) }, defaultTab: function (e) { e.somethingSelected() ? e.indentSelection("add") : e.execCommand("insertTab") }, transposeChars: function (l) { return h(l, function () { for (var e, t, n, r = l.listSelections(), i = [], o = 0; o < r.length; o++)r[o].empty() && (e = r[o].head, (t = W(l.doc, e.line).text) && (0 < (e = e.ch == t.length ? new F(e.line, e.ch - 1) : e).ch ? (e = new F(e.line, e.ch + 1), l.replaceRange(t.charAt(e.ch - 1) + t.charAt(e.ch - 2), F(e.line, e.ch - 2), e, "+transpose")) : e.line > l.doc.first && ((n = W(l.doc, e.line - 1).text) && (e = new F(e.line, 1), l.replaceRange(t.charAt(0) + l.doc.lineSeparator() + n.charAt(n.length - 1), F(e.line - 1, n.length - 1), e, "+transpose")))), i.push(new G(e, e))); l.setSelections(i) }) }, newlineAndIndent: function (r) { return h(r, function () { for (var e = (t = r.listSelections()).length - 1; 0 <= e; e--)r.replaceRange(r.doc.lineSeparator(), t[e].anchor, t[e].head, "+input"); for (var t = r.listSelections(), n = 0; n < t.length; n++)r.indentLine(t[n].from().line, null, !0); Pr(r) }) }, openLine: function (e) { return e.replaceSelection("\n", "start") }, toggleOverwrite: function (e) { return e.toggleOverwrite() } }; function $o(e, t) { var n = W(e.doc, t), r = tn(n); return jo(!0, e, r, t = r != n ? H(r) : t, 1) } function _o(e, t) { var n = $o(e, t.line), r = W(e.doc, n.line), e = Ve(r, e.doc.direction); return e && 0 != e[0].level ? n : (e = Math.max(n.ch, r.text.search(/\S/)), r = t.line == n.line && t.ch <= e && t.ch, F(n.line, r ? 0 : e, n.sticky)) } function qo(e, t, n) { if ("string" == typeof t && !(t = Yo[t])) return !1; e.display.input.ensurePolled(); var r = e.display.shift, i = !1; try { e.isReadOnly() && (e.state.suppressEdits = !0), n && (e.display.shift = !1), i = t(e) != me } finally { e.display.shift = r, e.state.suppressEdits = !1 } return i } var Zo = new pe; function Qo(e, t, n, r) { var i = e.state.keySeq; if (i) { if (zo(t)) return "handled"; if (/\'$/.test(t) ? e.state.keySeq = null : Zo.set(50, function () { e.state.keySeq == i && (e.state.keySeq = null, e.display.input.reset()) }), Jo(e, i + " " + t, n, r)) return !0 } return Jo(e, t, n, r) } function Jo(e, t, n, r) { r = function (e, t, n) { for (var r = 0; r < e.state.keyMaps.length; r++) { var i = Ro(t, e.state.keyMaps[r], n, e); if (i) return i } return e.options.extraKeys && Ro(t, e.options.extraKeys, n, e) || Ro(t, e.options.keyMap, n, e) }(e, t, r); return "multi" == r && (e.state.keySeq = t), "handled" == r && b(e, "keyHandled", e, t, n), "handled" != r && "multi" != r || (D(n), kr(e)), !!r } function el(t, e) { var n = Bo(e, !0); return !!n && (e.shiftKey && !t.state.keySeq ? Qo(t, "Shift-" + n, e, function (e) { return qo(t, e, !0) }) || Qo(t, n, e, function (e) { if ("string" == typeof e ? /^go[A-Z]/.test(e) : e.motion) return qo(t, e) }) : Qo(t, n, e, function (e) { return qo(t, e) })) } var tl = null; function nl(e) { var t, n, r, i = this; function o(e) { 18 != e.keyCode && e.altKey || (ee(r, "CodeMirror-crosshair"), T(document, "keyup", o), T(document, "mouseover", o)) } e.target && e.target != i.display.input.getField() || (i.curOp.focus = N(ue(i)), A(i, e) || (w && v < 11 && 27 == e.keyCode && (e.returnValue = !1), t = e.keyCode, i.display.shift = 16 == t || e.shiftKey, n = el(i, e), K && (tl = n ? t : null, !n && 88 == t && !ot && (C ? e.metaKey : e.ctrlKey) && i.replaceSelection("", null, "cut")), d && !C && !n && 46 == t && e.shiftKey && !e.ctrlKey && document.execCommand && document.execCommand("cut"), 18 != t || /\bCodeMirror-crosshair\b/.test(i.display.lineDiv.className) || (ie(r = i.display.lineDiv, "CodeMirror-crosshair"), k(document, "keyup", o), k(document, "mouseover", o)))) } function rl(e) { 16 == e.keyCode && (this.doc.sel.shift = !1), A(this, e) } function il(e) { var t = this; if (!(e.target && e.target != t.display.input.getField() || An(t.display, e) || A(t, e) || e.ctrlKey && !e.altKey || C && e.metaKey)) { var n, r = e.keyCode, i = e.charCode; if (K && r == tl) return tl = null, void D(e); K && (!e.which || e.which < 10) && el(t, e) || ("\b" == (r = String.fromCharCode(null == i ? r : i)) || Qo(n = t, "'" + r + "'", e, function (e) { return qo(n, e, !0) }) || t.display.input.onKeyPress(e)) } } function ol(e, t, n) { this.time = e, this.pos = t, this.button = n } var ll, sl; function al(e) { var t, n, r, i, o, l, s, a, u, c = this, h = c.display; A(c, e) || h.activeTouch && h.input.supportsTouch() || (h.input.ensurePolled(), h.shift = e.shiftKey, An(h, e) ? x || (h.scroller.draggable = !1, setTimeout(function () { return h.scroller.draggable = !0 }, 100)) : hl(c, e) || (t = gr(c, e), n = Je(e), r = t ? (i = t, o = n, r = +new Date, sl && sl.compare(r, i, o) ? (ll = sl = null, "triple") : ll && ll.compare(r, i, o) ? (sl = new ol(r, i, o), ll = null, "double") : (ll = new ol(r, i, o), sl = null, "single")) : "single", he(c).focus(), 1 == n && c.state.selectingText && c.state.selectingText(e), t && function (n, e, r, t, i) { var o = "Click"; "double" == t ? o = "Double" + o : "triple" == t && (o = "Triple" + o); return Qo(n, Io(o = (1 == e ? "Left" : 2 == e ? "Middle" : "Right") + o, i), i, function (e) { if (!(e = "string" == typeof e ? Yo[e] : e)) return !1; var t = !1; try { n.isReadOnly() && (n.state.suppressEdits = !0), t = e(n, r) != me } finally { n.state.suppressEdits = !1 } return t }) }(c, n, t, r, e) || (1 == n ? t ? (i = c, o = t, l = r, s = e, w ? setTimeout(de(Tr, i), 0) : i.curOp.focus = N(ue(i)), a = function (e, t, n) { var r = e.getOption("configureMouse"), r = r ? r(e, t, n) : {}; { var i; null == r.unit && (i = q ? n.shiftKey && n.metaKey : n.altKey, r.unit = i ? "rectangle" : "single" == t ? "char" : "double" == t ? "word" : "line") } null != r.extend && !e.doc.extend || (r.extend = e.doc.extend || n.shiftKey); null == r.addNew && (r.addNew = C ? n.metaKey : n.ctrlKey); null == r.moveOnDrag && (r.moveOnDrag = !(C ? n.altKey : n.ctrlKey)); return r }(i, l, s), u = i.doc.sel, (i.options.dragDrop && nt && !i.isReadOnly() && "single" == l && -1 < (l = u.contains(o)) && (P((l = u.ranges[l]).from(), o) < 0 || 0 < o.xRel) && (0 < P(l.to(), o) || o.xRel < 0) ? function (t, n, r, i) { var o = t.display, l = !1, s = I(t, function (e) { x && (o.scroller.draggable = !1), t.state.draggingText = !1, t.state.delayingBlurEvent && (t.hasFocus() ? t.state.delayingBlurEvent = !1 : Mr(t)), T(o.wrapper.ownerDocument, "mouseup", s), T(o.wrapper.ownerDocument, "mousemove", a), T(o.scroller, "dragstart", u), T(o.scroller, "drop", s), l || (D(e), i.addNew || Gi(t.doc, r, null, null, i.extend), x && !j || w && 9 == v ? setTimeout(function () { o.wrapper.ownerDocument.body.focus({ preventScroll: !0 }), o.input.focus() }, 20) : o.input.focus()) }), a = function (e) { l = l || 10 <= Math.abs(n.clientX - e.clientX) + Math.abs(n.clientY - e.clientY) }, u = function () { return l = !0 }; x && (o.scroller.draggable = !0); (t.state.draggingText = s).copy = !i.moveOnDrag, k(o.wrapper.ownerDocument, "mouseup", s), k(o.wrapper.ownerDocument, "mousemove", a), k(o.scroller, "dragstart", u), k(o.scroller, "drop", s), t.state.delayingBlurEvent = !0, setTimeout(function () { return o.input.focus() }, 20), o.scroller.dragDrop && o.scroller.dragDrop() } : function (d, e, f, p) { w && Mr(d); var l = d.display, g = d.doc; D(e); var m, v, y = g.sel, t = y.ranges; p.addNew && !p.extend ? (v = g.sel.contains(f), m = -1 < v ? t[v] : new G(f, f)) : (m = g.sel.primary(), v = g.sel.primIndex); "rectangle" == p.unit ? (p.addNew || (m = new G(f, f)), f = gr(d, e, !0, !0), v = -1) : (e = ul(d, f, p.unit), m = p.extend ? Bi(m, e.anchor, e.head, p.extend) : e); p.addNew ? -1 == v ? (v = t.length, U(g, vi(d, t.concat([m]), v), { scroll: !1, origin: "*mouse" })) : 1 < t.length && t[v].empty() && "char" == p.unit && !p.extend ? (U(g, vi(d, t.slice(0, v).concat(t.slice(v + 1)), 0), { scroll: !1, origin: "*mouse" }), y = g.sel) : Vi(g, v, m, ye) : (U(g, new B([m], v = 0), ye), y = g.sel); var b = f; function s(e) { if (0 != P(b, e)) if (b = e, "rectangle" == p.unit) { for (var t = [], n = d.options.tabSize, r = S(W(g, f.line).text, f.ch, n), i = S(W(g, e.line).text, e.ch, n), o = Math.min(r, i), l = Math.max(r, i), s = Math.min(f.line, e.line), a = Math.min(d.lastLine(), Math.max(f.line, e.line)); s <= a; s++) { var u = W(g, s).text, c = we(u, o, n); o == l ? t.push(new G(F(s, c), F(s, c))) : u.length > c && t.push(new G(F(s, c), F(s, we(u, l, n)))) } t.length || t.push(new G(f, f)), U(g, vi(d, y.ranges.slice(0, v).concat(t), v), { origin: "*mouse", scroll: !1 }), d.scrollIntoView(e) } else { var h, r = m, i = ul(d, e, p.unit), e = r.anchor, e = 0 < P(i.anchor, e) ? (h = i.head, kt(r.from(), i.anchor)) : (h = i.anchor, Lt(r.to(), i.head)), r = y.ranges.slice(0); r[v] = function (e, t) { var n = t.anchor, r = t.head, i = W(e.doc, n.line); if (0 == P(n, r) && n.sticky == r.sticky) return t; i = Ve(i); if (!i) return t; var o = Pe(i, n.ch, n.sticky), l = i[o]; if (l.from != n.ch && l.to != n.ch) return t; var s = o + (l.from == n.ch == (1 != l.level) ? 0 : 1); if (0 == s || s == i.length) return t; l = r.line != n.line ? 0 < (r.line - n.line) * ("ltr" == e.doc.direction ? 1 : -1) : (e = Pe(i, r.ch, r.sticky), o = e - o || (r.ch - n.ch) * (1 == l.level ? -1 : 1), e == s - 1 || e == s ? o < 0 : 0 < o); e = i[s + (l ? -1 : 0)], o = l == (1 == e.level), i = o ? e.from : e.to, s = o ? "after" : "before"; return n.ch == i && n.sticky == s ? t : new G(new F(n.line, i, s), r) }(d, new G(E(g, e), h)), U(g, vi(d, r, v), ye) } } var a = l.wrapper.getBoundingClientRect(), u = 0; function n(e) { d.state.selectingText = !1, u = 1 / 0, e && (D(e), l.input.focus()), T(l.wrapper.ownerDocument, "mousemove", r), T(l.wrapper.ownerDocument, "mouseup", i), g.history.lastSelOrigin = null } var r = I(d, function (e) { (0 !== e.buttons && Je(e) ? function e(t) { var n, r, i = ++u, o = gr(d, t, !0, "rectangle" == p.unit); o && (0 != P(o, b) ? (d.curOp.focus = N(ue(d)), s(o), n = Wr(l, g), (o.line >= n.to || o.line < n.from) && setTimeout(I(d, function () { u == i && e(t) }), 150)) : (r = t.clientY < a.top ? -20 : t.clientY > a.bottom ? 20 : 0) && setTimeout(I(d, function () { u == i && (l.scroller.scrollTop += r, e(t)) }), 50)) } : n)(e) }), i = I(d, n); d.state.selectingText = i, k(l.wrapper.ownerDocument, "mousemove", r), k(l.wrapper.ownerDocument, "mouseup", i) })(i, s, o, a)) : Qe(e) == h.scroller && D(e) : 2 == n ? (t && Gi(c.doc, t), setTimeout(function () { return h.input.focus() }, 20)) : 3 == n && (Q ? c.display.input.onContextMenu(e) : Mr(c))))) } function ul(e, t, n) { if ("char" == n) return new G(t, t); if ("word" == n) return e.findWordAt(t); if ("line" == n) return new G(F(t.line, 0), E(e.doc, F(t.line + 1, 0))); n = n(e, t); return new G(n.from, n.to) } function cl(e, t, n, r) { var i, o; if (t.touches) i = t.touches[0].clientX, o = t.touches[0].clientY; else try { i = t.clientX, o = t.clientY } catch (e) { return !1 } if (i >= Math.floor(e.display.gutters.getBoundingClientRect().right)) return !1; r && D(t); var l = e.display, r = l.lineDiv.getBoundingClientRect(); if (o > r.bottom || !Ye(e, n)) return qe(t); o -= r.top - l.viewOffset; for (var s = 0; s < e.display.gutterSpecs.length; ++s) { var a = l.gutters.childNodes[s]; if (a && a.getBoundingClientRect().right >= i) return O(e, n, e, bt(e.doc, o), e.display.gutterSpecs[s].className, t), qe(t) } } function hl(e, t) { return cl(e, t, "gutterClick", !0) } function dl(e, t) { var n, r; An(e.display, t) || (r = t, Ye(n = e, "gutterContextMenu") && cl(n, r, "gutterContextMenu", !1)) || A(e, t, "contextmenu") || Q || e.display.input.onContextMenu(t) } function fl(e) { e.display.wrapper.className = e.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") + e.options.theme.replace(/(^|\s)\s*/g, " cm-s-"), Yn(e) } ol.prototype.compare = function (e, t, n) { return this.time + 400 > e && 0 == P(t, this.pos) && n == this.button }; var pl = { toString: function () { return "CodeMirror.Init" } }, gl = {}, ml = {}; function vl(e, t, n) { !t != !(n && n != pl) && (n = e.display.dragFunctions, (t = t ? k : T)(e.display.scroller, "dragstart", n.start), t(e.display.scroller, "dragenter", n.enter), t(e.display.scroller, "dragover", n.over), t(e.display.scroller, "dragleave", n.leave), t(e.display.scroller, "drop", n.drop)) } function yl(e) { e.options.lineWrapping ? (ie(e.display.wrapper, "CodeMirror-wrap"), e.display.sizer.style.minWidth = "", e.display.sizerWidth = null) : (ee(e.display.wrapper, "CodeMirror-wrap"), an(e)), pr(e), R(e), Yn(e), setTimeout(function () { return jr(e) }, 100) } function p(e, t) { var n = this; if (!(this instanceof p)) return new p(e, t); this.options = t = t ? fe(t) : {}, fe(gl, t, !1); var r, i = t.value, o = ("string" == typeof i ? i = new f(i, t.mode, null, t.lineSeparator, t.direction) : t.mode && (i.modeOption = t.mode), this.doc = i, new p.inputStyles[t.inputStyle](this)), e = this.display = new hi(e, i, o, t), l = (fl(e.wrapper.CodeMirror = this), t.lineWrapping && (this.display.wrapper.className += " CodeMirror-wrap"), $r(this), this.state = { keyMaps: [], overlays: [], modeGen: 0, overwrite: !1, delayingBlurEvent: !1, focused: !1, suppressEdits: !1, pasteIncoming: -1, cutIncoming: -1, selectingText: !1, draggingText: !1, highlight: new pe, keySeq: null, specialChars: null }, t.autofocus && !_ && e.input.focus(), w && v < 11 && setTimeout(function () { return n.display.input.reset(!0) }, 20), this), s = l.display; k(s.scroller, "mousedown", I(l, al)), k(s.scroller, "dblclick", w && v < 11 ? I(l, function (e) { var t; A(l, e) || (!(t = gr(l, e)) || hl(l, e) || An(l.display, e) || (D(e), e = l.findWordAt(t), Gi(l.doc, e.anchor, e.head))) }) : function (e) { return A(l, e) || D(e) }), k(s.scroller, "contextmenu", function (e) { return dl(l, e) }), k(s.input.getField(), "contextmenu", function (e) { s.scroller.contains(e.target) || dl(l, e) }); var a, u = { end: 0 }; function c() { s.activeTouch && (a = setTimeout(function () { return s.activeTouch = null }, 1e3), (u = s.activeTouch).end = +new Date) } function h(e, t) { if (null == t.left) return 1; var n = t.left - e.left, t = t.top - e.top; return 400 < n * n + t * t } k(s.scroller, "touchstart", function (e) { var t; A(l, e) || function (e) { if (1 == e.touches.length) return (e = e.touches[0]).radiusX <= 1 && e.radiusY <= 1 }(e) || hl(l, e) || (s.input.ensurePolled(), clearTimeout(a), t = +new Date, s.activeTouch = { start: t, moved: !1, prev: t - u.end <= 300 ? u : null }, 1 == e.touches.length && (s.activeTouch.left = e.touches[0].pageX, s.activeTouch.top = e.touches[0].pageY)) }), k(s.scroller, "touchmove", function () { s.activeTouch && (s.activeTouch.moved = !0) }), k(s.scroller, "touchend", function (e) { var t, n = s.activeTouch; n && !An(s, e) && null != n.left && !n.moved && new Date - n.start < 300 && (t = l.coordsChar(s.activeTouch, "page"), n = !n.prev || h(n, n.prev) ? new G(t, t) : !n.prev.prev || h(n, n.prev.prev) ? l.findWordAt(t) : new G(F(t.line, 0), E(l.doc, F(t.line + 1, 0))), l.setSelection(n.anchor, n.head), l.focus(), D(e)), c() }), k(s.scroller, "touchcancel", c), k(s.scroller, "scroll", function () { s.scroller.clientHeight && (Ir(l, s.scroller.scrollTop), Gr(l, s.scroller.scrollLeft, !0), O(l, "scroll", l)) }), k(s.scroller, "mousewheel", function (e) { return mi(l, e) }), k(s.scroller, "DOMMouseScroll", function (e) { return mi(l, e) }), k(s.wrapper, "scroll", function () { return s.wrapper.scrollTop = s.wrapper.scrollLeft = 0 }), s.dragFunctions = { enter: function (e) { A(l, e) || Ze(e) }, over: function (e) { var t, n; A(l, e) || ((n = gr(t = l, n = e)) && (Sr(t, n, n = document.createDocumentFragment()), t.display.dragCursor || (t.display.dragCursor = M("div", null, "CodeMirror-cursors CodeMirror-dragcursors"), t.display.lineSpace.insertBefore(t.display.dragCursor, t.display.cursorDiv)), y(t.display.dragCursor, n)), Ze(e)) }, start: function (e) { var t, n; t = l, e = e, w && (!t.state.draggingText || +new Date - So < 100) ? Ze(e) : A(t, e) || An(t.display, e) || (e.dataTransfer.setData("Text", t.getSelection()), e.dataTransfer.effectAllowed = "copyMove", e.dataTransfer.setDragImage && !j && ((n = M("img", null, null, "position: fixed; left: 0; top: 0;")).src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==", K && (n.width = n.height = 1, t.display.wrapper.appendChild(n), n._top = n.offsetTop), e.dataTransfer.setDragImage(n, 0, 0), K && n.parentNode.removeChild(n))) }, drop: I(l, Lo), leave: function (e) { A(l, e) || ko(l) } }; o = s.input.getField(); for (r in k(o, "keyup", function (e) { return rl.call(l, e) }), k(o, "keydown", I(l, nl)), k(o, "keypress", I(l, il)), k(o, "focus", function (e) { return Nr(l, e) }), k(o, "blur", function (e) { return Or(l, e) }), No(), qr(this), this.curOp.forceUpdate = !0, Ni(this, i), t.autofocus && !_ || this.hasFocus() ? setTimeout(function () { n.hasFocus() && !n.state.focused && Nr(n) }, 20) : Or(this), ml) ml.hasOwnProperty(r) && ml[r](this, t[r], pl); si(this), t.finishInit && t.finishInit(this); for (var d = 0; d < bl.length; ++d)bl[d](this); Zr(this), x && t.lineWrapping && "optimizelegibility" == getComputedStyle(e.lineDiv).textRendering && (e.lineDiv.style.textRendering = "auto") } p.defaults = gl, p.optionHandlers = ml; var bl = []; function wl(e, t, n, r) { var i, o = e.doc, l = ("smart" == (n = null == n ? "add" : n) && (o.mode.indent ? i = Wt(e, t).state : n = "prev"), e.options.tabSize), s = W(o, t), a = S(s.text, null, l), u = (s.stateAfter && (s.stateAfter = null), s.text.match(/^\s*/)[0]); if (r || /\S/.test(s.text)) { if ("smart" == n && ((c = o.mode.indent(i, s.text.slice(u.length), s.text)) == me || 150 < c)) { if (!r) return; n = "prev" } } else c = 0, n = "not"; "prev" == n ? c = t > o.first ? S(W(o, t - 1).text, null, l) : 0 : "add" == n ? c = a + e.options.indentUnit : "subtract" == n ? c = a - e.options.indentUnit : "number" == typeof n && (c = a + n); var c = Math.max(0, c), h = "", d = 0; if (e.options.indentWithTabs) for (var f = Math.floor(c / l); f; --f)d += l, h += "\t"; if (d < c && (h += Ce(c - d)), h != u) return lo(o, h, F(t, 0), F(t, u.length), "+input"), !(s.stateAfter = null); for (var p = 0; p < o.sel.ranges.length; p++) { var g = o.sel.ranges[p]; if (g.head.line == t && g.head.ch < u.length) { g = F(t, u.length); Vi(o, p, new G(g, g)); break } } } p.defineInitHook = function (e) { return bl.push(e) }; var xl = null; function Cl(e) { xl = e } function Sl(e, t, n, r, i) { var o = e.doc, l = (e.display.shift = !1, r = r || o.sel, +new Date - 200), s = "paste" == i || e.state.pasteIncoming > l, a = rt(t), u = null; if (s && 1 < r.ranges.length) if (xl && xl.text.join("\n") == t) { if (r.ranges.length % xl.text.length == 0) for (var u = [], c = 0; c < xl.text.length; c++)u.push(o.splitLines(xl.text[c])) } else a.length == r.ranges.length && e.options.pasteLinesPerSelection && (u = Se(a, function (e) { return [e] })); for (var h = e.curOp.updateInput, d = r.ranges.length - 1; 0 <= d; d--) { var f = r.ranges[d], p = f.from(), g = f.to(), f = (f.empty() && (n && 0 < n ? p = F(p.line, p.ch - n) : e.state.overwrite && !s ? g = F(g.line, Math.min(W(o, g.line).text.length, g.ch + z(a).length)) : s && xl && xl.lineWise && xl.text.join("\n") == a.join("\n") && (p = g = F(p.line, 0))), { from: p, to: g, text: u ? u[d % u.length] : a, origin: i || (s ? "paste" : e.state.cutIncoming > l ? "cut" : "+input") }); to(e.doc, f), b(e, "inputRead", e, f) } t && !s && kl(e, t), Pr(e), e.curOp.updateInput < 2 && (e.curOp.updateInput = h), e.curOp.typing = !0, e.state.pasteIncoming = e.state.cutIncoming = -1 } function Ll(e, t) { var n = e.clipboardData && e.clipboardData.getData("Text"); return n && (e.preventDefault(), t.isReadOnly() || t.options.disableInput || !t.hasFocus() || h(t, function () { return Sl(t, n, 0, null, "paste") }), 1) } function kl(e, t) { if (e.options.electricChars && e.options.smartIndent) for (var n = e.doc.sel, r = n.ranges.length - 1; 0 <= r; r--) { var i = n.ranges[r]; if (!(100 < i.head.ch || r && n.ranges[r - 1].head.line == i.head.line)) { var o = e.getModeAt(i.head), l = !1; if (o.electricChars) { for (var s = 0; s < o.electricChars.length; s++)if (-1 < t.indexOf(o.electricChars.charAt(s))) { l = wl(e, i.head.line, "smart"); break } } else o.electricInput && o.electricInput.test(W(e.doc, i.head.line).text.slice(0, i.head.ch)) && (l = wl(e, i.head.line, "smart")); l && b(e, "electricInput", e, i.head.line) } } } function Tl(e) { for (var t = [], n = [], r = 0; r < e.doc.sel.ranges.length; r++) { var i = e.doc.sel.ranges[r].head.line, i = { anchor: F(i, 0), head: F(i + 1, 0) }; n.push(i), t.push(e.getRange(i.anchor, i.head)) } return { text: t, ranges: n } } function Ml(e, t, n, r) { e.setAttribute("autocorrect", n ? "on" : "off"), e.setAttribute("autocapitalize", r ? "on" : "off"), e.setAttribute("spellcheck", !!t) } function Nl() { var e = M("textarea", null, null, "position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; min-height: 1em; outline: none"), t = M("div", [e], null, "overflow: hidden; position: relative; width: 3px; height: 0px;"); return x ? e.style.width = "1000px" : e.setAttribute("wrap", "off"), Y && (e.style.border = "1px solid black"), t } function Ol(n, r, i, o, l) { var e = r, t = i, s = W(n, r.line), a = l && "rtl" == n.direction ? -i : i; function u(e) { var t; if (null == (t = "codepoint" == o ? (t = s.text.charCodeAt(r.ch + (0 < i ? 0 : -1)), isNaN(t) ? null : (t = 0 < i ? 55296 <= t && t < 56320 : 56320 <= t && t < 57343, new F(r.line, Math.max(0, Math.min(s.text.length, r.ch + i * (t ? 2 : 1))), -i))) : l ? Xo(n.cm, s, r, i) : Ko(s, r, i))) { if (e || (e = r.line + a) < n.first || e >= n.first + n.size || (r = new F(e, r.ch, r.sticky), !(s = W(n, e)))) return; r = jo(l, n.cm, s, r.line, a) } else r = t; return 1 } if ("char" == o || "codepoint" == o) u(); else if ("column" == o) u(!0); else if ("word" == o || "group" == o) for (var c = null, h = "group" == o, d = n.cm && n.cm.getHelper(r, "wordChars"), f = !0; !(i < 0) || u(!f); f = !1) { var p = s.text.charAt(r.ch) || "\n", p = Ne(p, d) ? "w" : h && "\n" == p ? "n" : !h || /\s/.test(p) ? null : "p"; if (!h || f || p || (p = "s"), c && c != p) { i < 0 && (i = 1, u(), r.sticky = "after"); break } if (p && (c = p), 0 < i && !u(!f)) break } t = Zi(n, r, e, t, !0); return Ct(e, t) && (t.hitSide = !0), t } function Al(e, t, n, r) { var i, o, l, s = e.doc, a = t.left; for ("page" == r ? (i = Math.min(e.display.wrapper.clientHeight, he(e).innerHeight || s(e).documentElement.clientHeight), i = Math.max(i - .5 * ur(e.display), 3), o = (0 < n ? t.bottom : t.top) + n * i) : "line" == r && (o = 0 < n ? t.bottom + 3 : t.top - 3); (l = rr(e, a, o)).outside;) { if (n < 0 ? o <= 0 : o >= s.height) { l.hitSide = !0; break } o += 5 * n } return l } function r(e) { this.cm = e, this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null, this.polling = new pe, this.composing = null, this.gracePeriod = !1, this.readDOMTimeout = null } function Dl(e, t) { var n = In(e, t.line); if (!n || n.hidden) return null; var r = W(e.doc, t.line), n = Rn(n, r, t.line), r = Ve(r, e.doc.direction), e = "left", r = (r && (e = Pe(r, t.ch) % 2 ? "right" : "left"), Kn(n.map, t.ch, e)); return r.offset = "right" == r.collapse ? r.end : r.start, r } function Wl(e, t) { return t && (e.bad = !0), e } function Hl(e, t, n) { var r; if (t == e.display.lineDiv) { if (!(r = e.display.lineDiv.childNodes[n])) return Wl(e.clipPos(F(e.display.viewTo - 1)), !0); t = null, n = 0 } else for (r = t; ; r = r.parentNode) { if (!r || r == e.display.lineDiv) return null; if (r.parentNode && r.parentNode == e.display.lineDiv) break } for (var i = 0; i < e.display.view.length; i++) { var o = e.display.view[i]; if (o.node == r) { var u = o, o = t, l = n, s = u.text.firstChild, a = !1; if (!o || !re(s, o)) return Wl(F(H(u.line), 0), !0); if (o == s) if (a = !0, o = s.childNodes[l], l = 0, !o) return Wl(F(H(c = u.rest ? z(u.rest) : u.line), c.text.length), a); var c = 3 == o.nodeType ? o : null, h = o; for (c || 1 != o.childNodes.length || 3 != o.firstChild.nodeType || (c = o.firstChild, l = l && c.nodeValue.length); h.parentNode != s;)h = h.parentNode; var d = u.measure, f = d.maps; function p(e, t, n) { for (var r = -1; r < (f ? f.length : 0); r++)for (var i = r < 0 ? d.map : f[r], o = 0; o < i.length; o += 3) { var l, s, a = i[o + 2]; if (a == e || a == t) return l = H(r < 0 ? u.line : u.rest[r]), s = i[o] + n, F(l, s = n < 0 || a != e ? i[o + (n ? 1 : 0)] : s) } } var g = p(c, h, l); if (g) return Wl(g, a); for (var m = h.nextSibling, v = c ? c.nodeValue.length - l : 0; m; m = m.nextSibling) { if (g = p(m, m.firstChild, 0)) return Wl(F(g.line, g.ch - v), a); v += m.textContent.length } for (var y = h.previousSibling, b = l; y; y = y.previousSibling) { if (g = p(y, y.firstChild, -1)) return Wl(F(g.line, g.ch + b), a); b += y.textContent.length } return } } } r.prototype.init = function (e) { var t = this, o = this, l = o.cm, s = o.div = e.lineDiv; function a(e) { for (var t = e.target; t; t = t.parentNode) { if (t == s) return 1; if (/\bCodeMirror-(?:line)?widget\b/.test(t.className)) break } } function n(e) { if (a(e) && !A(l, e)) { if (l.somethingSelected()) Cl({ lineWise: !1, text: l.getSelections() }), "cut" == e.type && l.replaceSelection("", null, "cut"); else { if (!l.options.lineWiseCopyCut) return; var t = Tl(l); Cl({ lineWise: !0, text: t.text }), "cut" == e.type && l.operation(function () { l.setSelections(t.ranges, 0, ve), l.replaceSelection("", null, "cut") }) } if (e.clipboardData) { e.clipboardData.clearData(); var n = xl.text.join("\n"); if (e.clipboardData.setData("Text", n), e.clipboardData.getData("Text") == n) return void e.preventDefault() } var r = Nl(), n = r.firstChild, i = (Ml(n), l.display.lineSpace.insertBefore(r, l.display.lineSpace.firstChild), n.value = xl.text.join("\n"), N(ce(s))); se(n), setTimeout(function () { l.display.lineSpace.removeChild(r), i.focus(), i == s && o.showPrimarySelection() }, 50) } } s.contentEditable = !0, Ml(s, l.options.spellcheck, l.options.autocorrect, l.options.autocapitalize), k(s, "paste", function (e) { !a(e) || A(l, e) || Ll(e, l) || v <= 11 && setTimeout(I(l, function () { return t.updateFromDOM() }), 20) }), k(s, "compositionstart", function (e) { t.composing = { data: e.data, done: !1 } }), k(s, "compositionupdate", function (e) { t.composing || (t.composing = { data: e.data, done: !1 }) }), k(s, "compositionend", function (e) { t.composing && (e.data != t.composing.data && t.readFromDOMSoon(), t.composing.done = !0) }), k(s, "touchstart", function () { return o.forceCompositionEnd() }), k(s, "input", function () { t.composing || t.readFromDOMSoon() }), k(s, "copy", n), k(s, "cut", n) }, r.prototype.screenReaderLabelChanged = function (e) { e ? this.div.setAttribute("aria-label", e) : this.div.removeAttribute("aria-label") }, r.prototype.prepareSelection = function () { var e = Cr(this.cm, !1); return e.focus = N(ce(this.div)) == this.div, e }, r.prototype.showSelection = function (e, t) { e && this.cm.display.view.length && ((e.focus || t) && this.showPrimarySelection(), this.showMultipleSelections(e)) }, r.prototype.getSelection = function () { return this.cm.display.wrapper.ownerDocument.getSelection() }, r.prototype.showPrimarySelection = function () { var e = this.getSelection(), t = this.cm, n = t.doc.sel.primary(), r = n.from(), n = n.to(); if (t.display.viewTo == t.display.viewFrom || r.line >= t.display.viewTo || n.line < t.display.viewFrom) e.removeAllRanges(); else { var i = Hl(t, e.anchorNode, e.anchorOffset), o = Hl(t, e.focusNode, e.focusOffset); if (!i || i.bad || !o || o.bad || 0 != P(kt(i, o), r) || 0 != P(Lt(i, o), n)) { var i = t.display.view, o = r.line >= t.display.viewFrom && Dl(t, r) || { node: i[0].measure.map[2], offset: 0 }, r = n.line < t.display.viewTo && Dl(t, n); if (r || (r = { node: (i = (n = i[i.length - 1].measure).maps ? n.maps[n.maps.length - 1] : n.map)[i.length - 1], offset: i[i.length - 2] - i[i.length - 3] }), o && r) { var l, n = e.rangeCount && e.getRangeAt(0); try { l = le(o.node, o.offset, r.offset, r.node) } catch (e) { } l && (!d && t.state.focused ? (e.collapse(o.node, o.offset), l.collapsed || (e.removeAllRanges(), e.addRange(l))) : (e.removeAllRanges(), e.addRange(l)), n && null == e.anchorNode ? e.addRange(n) : d && this.startGracePeriod()), this.rememberSelection() } else e.removeAllRanges() } } }, r.prototype.startGracePeriod = function () { var e = this; clearTimeout(this.gracePeriod), this.gracePeriod = setTimeout(function () { e.gracePeriod = !1, e.selectionChanged() && e.cm.operation(function () { return e.cm.curOp.selectionChanged = !0 }) }, 20) }, r.prototype.showMultipleSelections = function (e) { y(this.cm.display.cursorDiv, e.cursors), y(this.cm.display.selectionDiv, e.selection) }, r.prototype.rememberSelection = function () { var e = this.getSelection(); this.lastAnchorNode = e.anchorNode, this.lastAnchorOffset = e.anchorOffset, this.lastFocusNode = e.focusNode, this.lastFocusOffset = e.focusOffset }, r.prototype.selectionInEditor = function () { var e = this.getSelection(); if (!e.rangeCount) return !1; e = e.getRangeAt(0).commonAncestorContainer; return re(this.div, e) }, r.prototype.focus = function () { "nocursor" != this.cm.options.readOnly && (this.selectionInEditor() && N(ce(this.div)) == this.div || this.showSelection(this.prepareSelection(), !0), this.div.focus()) }, r.prototype.blur = function () { this.div.blur() }, r.prototype.getField = function () { return this.div }, r.prototype.supportsTouch = function () { return !0 }, r.prototype.receivedFocus = function () { var e = this, t = this; this.selectionInEditor() ? setTimeout(function () { return e.pollSelection() }, 20) : h(this.cm, function () { return t.cm.curOp.selectionChanged = !0 }), this.polling.set(this.cm.options.pollInterval, function e() { t.cm.state.focused && (t.pollSelection(), t.polling.set(t.cm.options.pollInterval, e)) }) }, r.prototype.selectionChanged = function () { var e = this.getSelection(); return e.anchorNode != this.lastAnchorNode || e.anchorOffset != this.lastAnchorOffset || e.focusNode != this.lastFocusNode || e.focusOffset != this.lastFocusOffset }, r.prototype.pollSelection = function () { if (null == this.readDOMTimeout && !this.gracePeriod && this.selectionChanged()) { var e, t, n = this.getSelection(), r = this.cm; if ($ && m && this.cm.display.gutterSpecs.length && function (e) { for (var t = e; t; t = t.parentNode)if (/CodeMirror-gutter-wrapper/.test(t.className)) return 1; return }(n.anchorNode)) return this.cm.triggerOnKeyDown({ type: "keydown", keyCode: 8, preventDefault: Math.abs }), this.blur(), void this.focus(); this.composing || (this.rememberSelection(), e = Hl(r, n.anchorNode, n.anchorOffset), t = Hl(r, n.focusNode, n.focusOffset), e && t && h(r, function () { U(r.doc, yi(e, t), ve), (e.bad || t.bad) && (r.curOp.selectionChanged = !0) })) } }, r.prototype.pollContent = function () { null != this.readDOMTimeout && (clearTimeout(this.readDOMTimeout), this.readDOMTimeout = null); var e, t = this.cm, n = t.display, r = t.doc.sel.primary(), i = r.from(), r = r.to(); if (0 == i.ch && i.line > t.firstLine() && (i = F(i.line - 1, W(t.doc, i.line - 1).length)), r.ch == W(t.doc, r.line).text.length && r.line < t.lastLine() && (r = F(r.line + 1, 0)), i.line < n.viewFrom || r.line > n.viewTo - 1) return !1; var o, l = i.line == n.viewFrom || 0 == (l = mr(t, i.line)) ? (e = H(n.view[0].line), n.view[0].node) : (e = H(n.view[l].line), n.view[l - 1].node.nextSibling), r = mr(t, r.line), n = r == n.view.length - 1 ? (o = n.viewTo - 1, n.lineDiv.lastChild) : (o = H(n.view[r + 1].line) - 1, n.view[r + 1].node.previousSibling); if (!l) return !1; for (var s = t.doc.splitLines(function (o, e, t, l, s) { var n = "", a = !1, u = o.doc.lineSeparator(), c = !1; function h() { a && (n += u, c && (n += u), a = c = !1) } function d(e) { e && (h(), n += e) } for (; !function e(t) { if (1 == t.nodeType) { var n = t.getAttribute("cm-text"); if (n) d(n); else if (n = t.getAttribute("cm-marker")) (n = o.findMarks(F(l, 0), F(s + 1, 0), (i = +n, function (e) { return e.id == i }))).length && (n = n[0].find(0)) && d(mt(o.doc, n.from, n.to).join(u)); else if ("false" != t.getAttribute("contenteditable") && (n = /^(pre|div|p|li|table|br)$/i.test(t.nodeName), /^br$/i.test(t.nodeName) || 0 != t.textContent.length)) { n && h(); for (var r = 0; r < t.childNodes.length; r++)e(t.childNodes[r]); /^(pre|p)$/i.test(t.nodeName) && (c = !0), n && (a = !0) } } else 3 == t.nodeType && d(t.nodeValue.replace(/\u200b/g, "").replace(/\u00a0/g, " ")); var i }(e), e != t;)e = e.nextSibling, c = !1; return n }(t, l, n, e, o)), a = mt(t.doc, F(e, 0), F(o, W(t.doc, o).text.length)); 1 < s.length && 1 < a.length;)if (z(s) == z(a)) s.pop(), a.pop(), o--; else { if (s[0] != a[0]) break; s.shift(), a.shift(), e++ } for (var u = 0, c = 0, h = s[0], d = a[0], f = Math.min(h.length, d.length); u < f && h.charCodeAt(u) == d.charCodeAt(u);)++u; for (var p = z(s), g = z(a), m = Math.min(p.length - (1 == s.length ? u : 0), g.length - (1 == a.length ? u : 0)); c < m && p.charCodeAt(p.length - c - 1) == g.charCodeAt(g.length - c - 1);)++c; if (1 == s.length && 1 == a.length && e == i.line) for (; u && u > i.ch && p.charCodeAt(p.length - c - 1) == g.charCodeAt(g.length - c - 1);)u--, c++; s[s.length - 1] = p.slice(0, p.length - c).replace(/^\u200b+/, ""), s[0] = s[0].slice(u).replace(/\u200b+$/, ""); r = F(e, u), l = F(o, a.length ? z(a).length - c : 0); return 1 < s.length || s[0] || P(r, l) ? (lo(t.doc, s, r, l, "+input"), !0) : void 0 }, r.prototype.ensurePolled = function () { this.forceCompositionEnd() }, r.prototype.reset = function () { this.forceCompositionEnd() }, r.prototype.forceCompositionEnd = function () { this.composing && (clearTimeout(this.readDOMTimeout), this.composing = null, this.updateFromDOM(), this.div.blur(), this.div.focus()) }, r.prototype.readFromDOMSoon = function () { var e = this; null == this.readDOMTimeout && (this.readDOMTimeout = setTimeout(function () { if (e.readDOMTimeout = null, e.composing) { if (!e.composing.done) return; e.composing = null } e.updateFromDOM() }, 80)) }, r.prototype.updateFromDOM = function () { var e = this; !this.cm.isReadOnly() && this.pollContent() || h(this.cm, function () { return R(e.cm) }) }, r.prototype.setUneditable = function (e) { e.contentEditable = "false" }, r.prototype.onKeyPress = function (e) { 0 == e.charCode || this.composing || (e.preventDefault(), this.cm.isReadOnly() || I(this.cm, Sl)(this.cm, String.fromCharCode(null == e.charCode ? e.keyCode : e.charCode), 0)) }, r.prototype.readOnlyChanged = function (e) { this.div.contentEditable = String("nocursor" != e) }, r.prototype.onContextMenu = function () { }, r.prototype.resetPosition = function () { }, r.prototype.needsContentAttribute = !0; function i(e) { this.cm = e, this.prevInput = "", this.pollingFast = !1, this.polling = new pe, this.hasSelection = !1, this.composing = null, this.resetting = !1 } var Fl, Pl, El, Rl, zl; function o(e, t, r, n) { Fl.defaults[e] = t, r && (Pl[e] = n ? function (e, t, n) { n != pl && r(e, t, n) } : r) } i.prototype.init = function (n) { var e = this, r = this, i = this.cm, o = (this.createField(n), this.textarea); function t(e) { if (!A(i, e)) { if (i.somethingSelected()) Cl({ lineWise: !1, text: i.getSelections() }); else { if (!i.options.lineWiseCopyCut) return; var t = Tl(i); Cl({ lineWise: !0, text: t.text }), "cut" == e.type ? i.setSelections(t.ranges, null, ve) : (r.prevInput = "", o.value = t.text.join("\n"), se(o)) } "cut" == e.type && (i.state.cutIncoming = +new Date) } } n.wrapper.insertBefore(this.wrapper, n.wrapper.firstChild), Y && (o.style.width = "0px"), k(o, "input", function () { w && 9 <= v && e.hasSelection && (e.hasSelection = null), r.poll() }), k(o, "paste", function (e) { A(i, e) || Ll(e, i) || (i.state.pasteIncoming = +new Date, r.fastPoll()) }), k(o, "cut", t), k(o, "copy", t), k(n.scroller, "paste", function (e) { if (!An(n, e) && !A(i, e)) { if (!o.dispatchEvent) return i.state.pasteIncoming = +new Date, void r.focus(); var t = new Event("paste"); t.clipboardData = e.clipboardData, o.dispatchEvent(t) } }), k(n.lineSpace, "selectstart", function (e) { An(n, e) || D(e) }), k(o, "compositionstart", function () { var e = i.getCursor("from"); r.composing && r.composing.range.clear(), r.composing = { start: e, range: i.markText(e, i.getCursor("to"), { className: "CodeMirror-composing" }) } }), k(o, "compositionend", function () { r.composing && (r.poll(), r.composing.range.clear(), r.composing = null) }) }, i.prototype.createField = function (e) { this.wrapper = Nl(), this.textarea = this.wrapper.firstChild; var t = this.cm.options; Ml(this.textarea, t.spellcheck, t.autocorrect, t.autocapitalize) }, i.prototype.screenReaderLabelChanged = function (e) { e ? this.textarea.setAttribute("aria-label", e) : this.textarea.removeAttribute("aria-label") }, i.prototype.prepareSelection = function () { var e, t = this.cm, n = t.display, r = t.doc, i = Cr(t); return t.options.moveInputWithCursor && (t = er(t, r.sel.primary().head, "div"), r = n.wrapper.getBoundingClientRect(), e = n.lineDiv.getBoundingClientRect(), i.teTop = Math.max(0, Math.min(n.wrapper.clientHeight - 10, t.top + e.top - r.top)), i.teLeft = Math.max(0, Math.min(n.wrapper.clientWidth - 10, t.left + e.left - r.left))), i }, i.prototype.showSelection = function (e) { var t = this.cm.display; y(t.cursorDiv, e.cursors), y(t.selectionDiv, e.selection), null != e.teTop && (this.wrapper.style.top = e.teTop + "px", this.wrapper.style.left = e.teLeft + "px") }, i.prototype.reset = function (e) { var t, n; this.contextMenuPending || this.composing && e || (t = this.cm, this.resetting = !0, t.somethingSelected() ? (this.prevInput = "", n = t.getSelection(), this.textarea.value = n, t.state.focused && se(this.textarea), w && 9 <= v && (this.hasSelection = n)) : e || (this.prevInput = this.textarea.value = "", w && 9 <= v && (this.hasSelection = null)), this.resetting = !1) }, i.prototype.getField = function () { return this.textarea }, i.prototype.supportsTouch = function () { return !1 }, i.prototype.focus = function () { if ("nocursor" != this.cm.options.readOnly && (!_ || N(ce(this.textarea)) != this.textarea)) try { this.textarea.focus() } catch (e) { } }, i.prototype.blur = function () { this.textarea.blur() }, i.prototype.resetPosition = function () { this.wrapper.style.top = this.wrapper.style.left = 0 }, i.prototype.receivedFocus = function () { this.slowPoll() }, i.prototype.slowPoll = function () { var e = this; this.pollingFast || this.polling.set(this.cm.options.pollInterval, function () { e.poll(), e.cm.state.focused && e.slowPoll() }) }, i.prototype.fastPoll = function () { var t = !1, n = this; n.pollingFast = !0, n.polling.set(20, function e() { n.poll() || t ? (n.pollingFast = !1, n.slowPoll()) : (t = !0, n.polling.set(60, e)) }) }, i.prototype.poll = function () { var e = this, t = this.cm, n = this.textarea, r = this.prevInput; if (this.contextMenuPending || this.resetting || !t.state.focused || it(n) && !r && !this.composing || t.isReadOnly() || t.options.disableInput || t.state.keySeq) return !1; var i = n.value; if (i == r && !t.somethingSelected()) return !1; if (w && 9 <= v && this.hasSelection === i || C && /[\uf700-\uf7ff]/.test(i)) return t.display.input.reset(), !1; if (t.doc.sel == t.display.selForContextMenu) { var o = i.charCodeAt(0); if (8203 != o || r || (r = "​"), 8666 == o) return this.reset(), this.cm.execCommand("undo") } for (var l = 0, s = Math.min(r.length, i.length); l < s && r.charCodeAt(l) == i.charCodeAt(l);)++l; return h(t, function () { Sl(t, i.slice(l), r.length - l, null, e.composing ? "*compose" : null), 1e3 < i.length || -1 < i.indexOf("\n") ? n.value = e.prevInput = "" : e.prevInput = i, e.composing && (e.composing.range.clear(), e.composing.range = t.markText(e.composing.start, t.getCursor("to"), { className: "CodeMirror-composing" })) }), !0 }, i.prototype.ensurePolled = function () { this.pollingFast && this.poll() && (this.pollingFast = !1) }, i.prototype.onKeyPress = function () { w && 9 <= v && (this.hasSelection = null), this.fastPoll() }, i.prototype.onContextMenu = function (e) { var n, r, t, i, o = this, l = o.cm, s = l.display, a = o.textarea, u = (o.contextMenuPending && o.contextMenuPending(), gr(l, e)), c = s.scroller.scrollTop; function h() { var e, t; null != a.selectionStart && (t = "​" + ((e = l.somethingSelected()) ? a.value : ""), a.value = "⇚", a.value = t, o.prevInput = e ? "" : "​", a.selectionStart = 1, a.selectionEnd = t.length, s.selForContextMenu = l.doc.sel) } function d() { var e, t; o.contextMenuPending == d && (o.contextMenuPending = !1, o.wrapper.style.cssText = r, a.style.cssText = n, w && v < 9 && s.scrollbars.setScrollTop(s.scroller.scrollTop = c), null != a.selectionStart && ((!w || v < 9) && h(), e = 0, t = function () { s.selForContextMenu == l.doc.sel && 0 == a.selectionStart && 0 < a.selectionEnd && "​" == o.prevInput ? I(l, Ji)(l) : e++ < 10 ? s.detectingSelectAll = setTimeout(t, 500) : (s.selForContextMenu = null, s.input.reset()) }, s.detectingSelectAll = setTimeout(t, 200))) } u && !K && (l.options.resetSelectionOnContextMenu && -1 == l.doc.sel.contains(u) && I(l, U)(l.doc, yi(u), ve), n = a.style.cssText, r = o.wrapper.style.cssText, u = o.wrapper.offsetParent.getBoundingClientRect(), o.wrapper.style.cssText = "position: static", a.style.cssText = "position: absolute; width: 30px; height: 30px;\n      top: " + (e.clientY - u.top - 5) + "px; left: " + (e.clientX - u.left - 5) + "px;\n      z-index: 1000; background: " + (w ? "rgba(255, 255, 255, .05)" : "transparent") + ";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);", x && (t = a.ownerDocument.defaultView.scrollY), s.input.focus(), x && a.ownerDocument.defaultView.scrollTo(null, t), s.input.reset(), l.somethingSelected() || (a.value = o.prevInput = " "), o.contextMenuPending = d, s.selForContextMenu = l.doc.sel, clearTimeout(s.detectingSelectAll), w && 9 <= v && h(), Q ? (Ze(e), i = function () { T(window, "mouseup", i), setTimeout(d, 20) }, k(window, "mouseup", i)) : setTimeout(d, 50)) }, i.prototype.readOnlyChanged = function (e) { e || this.reset(), this.textarea.disabled = "nocursor" == e, this.textarea.readOnly = !!e }, i.prototype.setUneditable = function () { }, i.prototype.needsContentAttribute = !1, Pl = (Fl = p).optionHandlers, Fl.defineOption = o, Fl.Init = pl, o("value", "", function (e, t) { return e.setValue(t) }, !0), o("mode", null, function (e, t) { e.doc.modeOption = t, Si(e) }, !0), o("indentUnit", 2, Si, !0), o("indentWithTabs", !1), o("smartIndent", !0), o("tabSize", 4, function (e) { Li(e), Yn(e), R(e) }, !0), o("lineSeparator", null, function (e, r) { if (e.doc.lineSep = r) { var i = [], o = e.doc.first; e.doc.iter(function (e) { for (var t = 0; ;) { var n = e.text.indexOf(r, t); if (-1 == n) break; t = n + r.length, i.push(F(o, n)) } o++ }); for (var t = i.length - 1; 0 <= t; t--)lo(e.doc, r, i[t], F(i[t].line, i[t].ch + r.length)) } }), o("specialChars", /[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b\u200e\u200f\u2028\u2029\u202d\u202e\u2066\u2067\u2069\ufeff\ufff9-\ufffc]/g, function (e, t, n) { e.state.specialChars = new RegExp(t.source + (t.test("\t") ? "" : "|\t"), "g"), n != pl && e.refresh() }), o("specialCharPlaceholder", pn, function (e) { return e.refresh() }, !0), o("electricChars", !0), o("inputStyle", _ ? "contenteditable" : "textarea", function () { throw new Error("inputStyle can not (yet) be changed in a running editor") }, !0), o("spellcheck", !1, function (e, t) { return e.getInputField().spellcheck = t }, !0), o("autocorrect", !1, function (e, t) { return e.getInputField().autocorrect = t }, !0), o("autocapitalize", !1, function (e, t) { return e.getInputField().autocapitalize = t }, !0), o("rtlMoveVisually", !a), o("wholeLineUpdateBefore", !0), o("theme", "default", function (e) { fl(e), ci(e) }, !0), o("keyMap", "default", function (e, t, n) { t = Go(t), n = n != pl && Go(n); n && n.detach && n.detach(e, t), t.attach && t.attach(e, n || null) }), o("extraKeys", null), o("configureMouse", null), o("lineWrapping", !1, yl, !0), o("gutters", [], function (e, t) { e.display.gutterSpecs = ai(t, e.options.lineNumbers), ci(e) }, !0), o("fixedGutter", !0, function (e, t) { e.display.gutters.style.left = t ? dr(e.display) + "px" : "0", e.refresh() }, !0), o("coverGutterNextToScrollbar", !1, function (e) { return jr(e) }, !0), o("scrollbarStyle", "native", function (e) { $r(e), jr(e), e.display.scrollbars.setScrollTop(e.doc.scrollTop), e.display.scrollbars.setScrollLeft(e.doc.scrollLeft) }, !0), o("lineNumbers", !1, function (e, t) { e.display.gutterSpecs = ai(e.options.gutters, t), ci(e) }, !0), o("firstLineNumber", 1, ci, !0), o("lineNumberFormatter", function (e) { return e }, ci, !0), o("showCursorWhenSelecting", !1, xr, !0), o("resetSelectionOnContextMenu", !0), o("lineWiseCopyCut", !0), o("pasteLinesPerSelection", !0), o("selectionsMayTouch", !1), o("readOnly", !1, function (e, t) { "nocursor" == t && (Or(e), e.display.input.blur()), e.display.input.readOnlyChanged(t) }), o("screenReaderLabel", null, function (e, t) { e.display.input.screenReaderLabelChanged(t = "" === t ? null : t) }), o("disableInput", !1, function (e, t) { t || e.display.input.reset() }, !0), o("dragDrop", !0, vl), o("allowDropFileTypes", null), o("cursorBlinkRate", 530), o("cursorScrollMargin", 0), o("cursorHeight", 1, xr, !0), o("singleCursorHeightPerLine", !0, xr, !0), o("workTime", 100), o("workDelay", 100), o("flattenSpans", !0, Li, !0), o("addModeClass", !1, Li, !0), o("pollInterval", 100), o("undoDepth", 200, function (e, t) { return e.doc.history.undoDepth = t }), o("historyEventDelay", 1250), o("viewportMargin", 10, function (e) { return e.refresh() }, !0), o("maxHighlightLength", 1e4, Li, !0), o("moveInputWithCursor", !0, function (e, t) { t || e.display.input.resetPosition() }), o("tabindex", null, function (e, t) { return e.display.input.getField().tabIndex = t || "" }), o("autofocus", null), o("direction", "ltr", function (e, t) { return e.doc.setDirection(t) }, !0), o("phrases", null), Rl = (El = p).optionHandlers, zl = El.helpers = {}, El.prototype = { constructor: El, focus: function () { he(this).focus(), this.display.input.focus() }, setOption: function (e, t) { var n = this.options, r = n[e]; n[e] == t && "mode" != e || (n[e] = t, Rl.hasOwnProperty(e) && I(this, Rl[e])(this, t, r), O(this, "optionChange", this, e)) }, getOption: function (e) { return this.options[e] }, getDoc: function () { return this.doc }, addKeyMap: function (e, t) { this.state.keyMaps[t ? "push" : "unshift"](Go(e)) }, removeKeyMap: function (e) { for (var t = this.state.keyMaps, n = 0; n < t.length; ++n)if (t[n] == e || t[n].name == e) return t.splice(n, 1), !0 }, addOverlay: t(function (e, t) { var n = e.token ? e : El.getMode(this.options, e); if (n.startState) throw new Error("Overlays may not be stateful."); for (var r = this.state.overlays, n = { mode: n, modeSpec: e, opaque: t && t.opaque, priority: t && t.priority || 0 }, i = function (e) { return e.priority }, o = 0, l = i(n); o < r.length && i(r[o]) <= l;)o++; r.splice(o, 0, n), this.state.modeGen++, R(this) }), removeOverlay: t(function (e) { for (var t = this.state.overlays, n = 0; n < t.length; ++n) { var r = t[n].modeSpec; if (r == e || "string" == typeof e && r.name == e) return t.splice(n, 1), this.state.modeGen++, void R(this) } }), indentLine: t(function (e, t, n) { "string" != typeof t && "number" != typeof t && (t = null == t ? this.options.smartIndent ? "smart" : "prev" : t ? "add" : "subtract"), wt(this.doc, e) && wl(this, e, t, n) }), indentSelection: t(function (e) { for (var t = this.doc.sel.ranges, n = -1, r = 0; r < t.length; r++) { var i = t[r]; if (i.empty()) i.head.line > n && (wl(this, i.head.line, e, !0), n = i.head.line, r == this.doc.sel.primIndex && Pr(this)); else { for (var o = i.from(), i = i.to(), l = Math.max(n, o.line), n = Math.min(this.lastLine(), i.line - (i.ch ? 0 : 1)) + 1, s = l; s < n; ++s)wl(this, s, e); i = this.doc.sel.ranges; 0 == o.ch && t.length == i.length && 0 < i[r].from().ch && Vi(this.doc, r, new G(o, i[r].to()), ve) } } }), getTokenAt: function (e, t) { return Rt(this, e, t) }, getLineTokens: function (e, t) { return Rt(this, F(e), t, !0) }, getTokenTypeAt: function (e) { e = E(this.doc, e); var t, n = Dt(this, W(this.doc, e.line)), r = 0, i = (n.length - 1) / 2, o = e.ch; if (0 == o) t = n[2]; else for (; ;) { var l = r + i >> 1; if ((l ? n[2 * l - 1] : 0) >= o) i = l; else { if (!(n[2 * l + 1] < o)) { t = n[2 * l + 2]; break } r = 1 + l } } e = t ? t.indexOf("overlay ") : -1; return e < 0 ? t : 0 == e ? null : t.slice(0, e - 1) }, getModeAt: function (e) { var t = this.doc.mode; return t.innerMode ? El.innerMode(t, this.getTokenAt(e).state).mode : t }, getHelper: function (e, t) { return this.getHelpers(e, t)[0] }, getHelpers: function (e, t) { var n = []; if (!zl.hasOwnProperty(t)) return n; var r = zl[t], i = this.getModeAt(e); if ("string" == typeof i[t]) r[i[t]] && n.push(r[i[t]]); else if (i[t]) for (var o = 0; o < i[t].length; o++) { var l = r[i[t][o]]; l && n.push(l) } else i.helperType && r[i.helperType] ? n.push(r[i.helperType]) : r[i.name] && n.push(r[i.name]); for (var s = 0; s < r._global.length; s++) { var a = r._global[s]; a.pred(i, this) && -1 == L(n, a.val) && n.push(a.val) } return n }, getStateAfter: function (e, t) { var n = this.doc; return Wt(this, (e = Tt(n, null == e ? n.first + n.size - 1 : e)) + 1, t).state }, cursorCoords: function (e, t) { var n = this.doc.sel.primary(), e = null == e ? n.head : "object" == typeof e ? E(this.doc, e) : e ? n.from() : n.to(); return er(this, e, t || "page") }, charCoords: function (e, t) { return Jn(this, E(this.doc, e), t || "page") }, coordsChar: function (e, t) { return rr(this, (e = Qn(this, e, t || "page")).left, e.top) }, lineAtHeight: function (e, t) { return e = Qn(this, { top: e, left: 0 }, t || "page").top, bt(this.doc, e + this.display.viewOffset) }, heightAtLine: function (e, t, n) { var r = !1, i = "number" == typeof e ? (i = this.doc.first + this.doc.size - 1, e < this.doc.first ? e = this.doc.first : i < e && (e = i, r = !0), W(this.doc, e)) : e; return Zn(this, i, { top: 0, left: 0 }, t || "page", n || r).top + (r ? this.doc.height - ln(i) : 0) }, defaultTextHeight: function () { return ur(this.display) }, defaultCharWidth: function () { return cr(this.display) }, getViewport: function () { return { from: this.display.viewFrom, to: this.display.viewTo } }, addWidget: function (e, t, n, r, i) { var o, l, s = this.display, a = (e = er(this, E(this.doc, e))).bottom, u = e.left; t.style.position = "absolute", t.setAttribute("cm-ignore-events", "true"), this.display.input.setUneditable(t), s.sizer.appendChild(t), "over" == r ? a = e.top : "above" != r && "near" != r || (l = Math.max(s.wrapper.clientHeight, this.doc.height), o = Math.max(s.sizer.clientWidth, s.lineSpace.clientWidth), ("above" == r || e.bottom + t.offsetHeight > l) && e.top > t.offsetHeight ? a = e.top - t.offsetHeight : e.bottom + t.offsetHeight <= l && (a = e.bottom), u + t.offsetWidth > o && (u = o - t.offsetWidth)), t.style.top = a + "px", t.style.left = t.style.right = "", "right" == i ? (u = s.sizer.clientWidth - t.offsetWidth, t.style.right = "0px") : ("left" == i ? u = 0 : "middle" == i && (u = (s.sizer.clientWidth - t.offsetWidth) / 2), t.style.left = u + "px"), n && (r = this, l = { left: u, top: a, right: u + t.offsetWidth, bottom: a + t.offsetHeight }, null != (l = Hr(r, l)).scrollTop && Ir(r, l.scrollTop), null != l.scrollLeft && Gr(r, l.scrollLeft)) }, triggerOnKeyDown: t(nl), triggerOnKeyPress: t(il), triggerOnKeyUp: rl, triggerOnMouseDown: t(al), execCommand: function (e) { if (Yo.hasOwnProperty(e)) return Yo[e].call(null, this) }, triggerElectric: t(function (e) { kl(this, e) }), findPosH: function (e, t, n, r) { for (var i = 1, o = (t < 0 && (i = -1, t = -t), E(this.doc, e)), l = 0; l < t && !(o = Ol(this.doc, o, i, n, r)).hitSide; ++l); return o }, moveH: t(function (t, n) { var r = this; this.extendSelectionsBy(function (e) { return r.display.shift || r.doc.extend || e.empty() ? Ol(r.doc, e.head, t, n, r.options.rtlMoveVisually) : t < 0 ? e.from() : e.to() }, be) }), deleteH: t(function (n, r) { var e = this.doc.sel, i = this.doc; e.somethingSelected() ? i.replaceSelection("", null, "+delete") : Uo(this, function (e) { var t = Ol(i, e.head, n, r, !1); return n < 0 ? { from: t, to: e.head } : { from: e.head, to: t } }) }), findPosV: function (e, t, n, r) { for (var i = 1, o = r, l = (t < 0 && (i = -1, t = -t), E(this.doc, e)), s = 0; s < t; ++s) { var a = er(this, l, "div"); if (null == o ? o = a.left : a.left = o, (l = Al(this, a, i, n)).hitSide) break } return l }, moveV: t(function (r, i) { var o = this, l = this.doc, s = [], a = !this.display.shift && !l.extend && l.sel.somethingSelected(); if (l.extendSelectionsBy(function (e) { if (a) return r < 0 ? e.from() : e.to(); var t = er(o, e.head, "div"), n = (null != e.goalColumn && (t.left = e.goalColumn), s.push(t.left), Al(o, t, r, i)); return "page" == i && e == l.sel.primary() && Fr(o, Jn(o, n, "div").top - t.top), n }, be), s.length) for (var e = 0; e < l.sel.ranges.length; e++)l.sel.ranges[e].goalColumn = s[e] }), findWordAt: function (e) { var t = W(this.doc, e.line).text, n = e.ch, r = e.ch; if (t) { for (var i = this.getHelper(e, "wordChars"), o = ("before" != e.sticky && r != t.length || !n ? ++r : --n, t.charAt(n)), l = Ne(o, i) ? function (e) { return Ne(e, i) } : /\s/.test(o) ? function (e) { return /\s/.test(e) } : function (e) { return !/\s/.test(e) && !Ne(e) }; 0 < n && l(t.charAt(n - 1));)--n; for (; r < t.length && l(t.charAt(r));)++r } return new G(F(e.line, n), F(e.line, r)) }, toggleOverwrite: function (e) { null != e && e == this.state.overwrite || (((this.state.overwrite = !this.state.overwrite) ? ie : ee)(this.display.cursorDiv, "CodeMirror-overwrite"), O(this, "overwriteToggle", this, this.state.overwrite)) }, hasFocus: function () { return this.display.input.getField() == N(ue(this)) }, isReadOnly: function () { return !(!this.options.readOnly && !this.doc.cantEdit) }, scrollTo: t(function (e, t) { Er(this, e, t) }), getScrollInfo: function () { var e = this.display.scroller; return { left: e.scrollLeft, top: e.scrollTop, height: e.scrollHeight - Fn(this) - this.display.barHeight, width: e.scrollWidth - Fn(this) - this.display.barWidth, clientHeight: En(this), clientWidth: Pn(this) } }, scrollIntoView: t(function (e, t) { var n; null == e ? (e = { from: this.doc.sel.primary().head, to: null }, null == t && (t = this.options.cursorScrollMargin)) : "number" == typeof e ? e = { from: F(e, 0), to: null } : null == e.from && (e = { from: e, to: null }), e.to || (e.to = e.from), e.margin = t || 0, null != e.from.line ? (t = e, Rr(n = this), n.curOp.scrollToPos = t) : zr(this, e.from, e.to, e.margin) }), setSize: t(function (e, t) { function n(e) { return "number" == typeof e || /^\d+$/.test(String(e)) ? e + "px" : e } var r = this, i = (null != e && (this.display.wrapper.style.width = n(e)), null != t && (this.display.wrapper.style.height = n(t)), this.options.lineWrapping && Xn(this), this.display.viewFrom); this.doc.iter(i, this.display.viewTo, function (e) { if (e.widgets) for (var t = 0; t < e.widgets.length; t++)if (e.widgets[t].noHScroll) { vr(r, i, "widget"); break } ++i }), this.curOp.forceUpdate = !0, O(this, "refresh", this) }), operation: function (e) { return h(this, e) }, startOperation: function () { return qr(this) }, endOperation: function () { return Zr(this) }, refresh: t(function () { var e = this.display.cachedTextHeight; R(this), this.curOp.forceUpdate = !0, Yn(this), Er(this, this.doc.scrollLeft, this.doc.scrollTop), ii(this.display), (null == e || .5 < Math.abs(e - ur(this.display)) || this.options.lineWrapping) && pr(this), O(this, "refresh", this) }), swapDoc: t(function (e) { var t = this.doc; return t.cm = null, this.state.selectingText && this.state.selectingText(), Ni(this, e), Yn(this), this.display.input.reset(), Er(this, e.scrollLeft, e.scrollTop), this.curOp.forceScroll = !0, b(this, "swapDoc", this, t), t }), phrase: function (e) { var t = this.options.phrases; return t && Object.prototype.hasOwnProperty.call(t, e) ? t[e] : e }, getInputField: function () { return this.display.input.getField() }, getWrapperElement: function () { return this.display.wrapper }, getScrollerElement: function () { return this.display.scroller }, getGutterElement: function () { return this.display.gutters } }, $e(El), El.registerHelper = function (e, t, n) { zl.hasOwnProperty(e) || (zl[e] = El[e] = { _global: [] }), zl[e][t] = n }, El.registerGlobalHelper = function (e, t, n, r) { El.registerHelper(e, t, r), zl[e]._global.push({ pred: n, val: r }) }; var Il, Bl = "iter insert remove copy getEditor constructor".split(" "); for (Il in f.prototype) f.prototype.hasOwnProperty(Il) && L(Bl, Il) < 0 && (p.prototype[Il] = function (e) { return function () { return e.apply(this.doc, arguments) } }(f.prototype[Il])); return $e(f), p.inputStyles = { textarea: i, contenteditable: r }, p.defineMode = function (e) { p.defaults.mode || "null" == e || (p.defaults.mode = e), function (e, t) { 2 < arguments.length && (t.dependencies = Array.prototype.slice.call(arguments, 2)), st[e] = t }.apply(this, arguments) }, p.defineMIME = function (e, t) { at[e] = t }, p.defineMode("null", function () { return { token: function (e) { return e.skipToEnd() } } }), p.defineMIME("text/plain", "null"), p.defineExtension = function (e, t) { p.prototype[e] = t }, p.defineDocExtension = function (e, t) { f.prototype[e] = t }, p.fromTextArea = function (t, n) { var e; function r() { t.value = s.getValue() } if ((n = n ? fe(n) : {}).value = t.value, !n.tabindex && t.tabIndex && (n.tabindex = t.tabIndex), !n.placeholder && t.placeholder && (n.placeholder = t.placeholder), null == n.autofocus && (e = N(ce(t)), n.autofocus = e == t || null != t.getAttribute("autofocus") && e == document.body), t.form && (k(t.form, "submit", r), !n.leaveSubmitMethodAlone)) { var i = t.form, o = i.submit; try { var l = i.submit = function () { r(), i.submit = o, i.submit(), i.submit = l } } catch (e) { } } n.finishInit = function (e) { e.save = r, e.getTextArea = function () { return t }, e.toTextArea = function () { e.toTextArea = isNaN, r(), t.parentNode.removeChild(e.getWrapperElement()), t.style.display = "", t.form && (T(t.form, "submit", r), n.leaveSubmitMethodAlone || "function" != typeof t.form.submit || (t.form.submit = o)) } }, t.style.display = "none"; var s = p(function (e) { return t.parentNode.insertBefore(e, t.nextSibling) }, n); return s }, (e = p).off = T, e.on = k, e.wheelEventPixels = gi, e.Doc = f, e.splitLines = rt, e.countColumn = S, e.findColumn = we, e.isWordChar = Me, e.Pass = me, e.signal = O, e.Line = un, e.changeEnd = bi, e.scrollbarModel = Yr, e.Pos = F, e.cmpPos = P, e.modes = st, e.mimeModes = at, e.resolveMode = ut, e.getMode = ct, e.modeExtensions = ht, e.extendMode = dt, e.copyState = ft, e.startState = gt, e.innerMode = pt, e.commands = Yo, e.keyMap = Fo, e.keyName = Bo, e.isModifierKey = zo, e.lookupKey = Ro, e.normalizeKeyMap = Eo, e.StringStream = g, e.SharedTextMarker = bo, e.TextMarker = mo, e.LineWidget = po, e.e_preventDefault = D, e.e_stopPropagation = _e, e.e_stop = Ze, e.addClass = ie, e.contains = re, e.rmClass = ee, e.keyNames = Ao, p.version = "5.65.16", p }); !function (e) { "object" == typeof exports && "object" == typeof module ? e(require("../../lib/codemirror")) : "function" == typeof define && define.amd ? define(["../../lib/codemirror"], e) : e(CodeMirror) }(function (rt) { "use strict"; rt.defineMode("javascript", function (e, l) { var t, r, O, P, f = e.indentUnit, N = l.statementIndent, U = l.jsonld, o = l.json || U, W = !1 !== l.trackScope, u = l.typescript, B = l.wordCharacters || /[\w$\xa1-\uffff]/, F = (e = n("keyword a"), t = n("keyword b"), r = n("keyword c"), O = n("keyword d"), P = n("operator"), { if: n("if"), while: e, with: e, else: t, do: t, try: t, finally: t, return: O, break: O, continue: O, new: n("new"), delete: r, void: r, throw: r, debugger: n("debugger"), var: n("var"), const: n("var"), let: n("var"), function: n("function"), catch: n("catch"), for: n("for"), switch: n("switch"), case: n("case"), default: n("default"), in: P, typeof: P, instanceof: P, true: e = { type: "atom", style: "atom" }, false: e, null: e, undefined: e, NaN: e, Infinity: e, this: n("this"), class: n("class"), super: n("atom"), yield: r, export: n("export"), import: n("import"), extends: r, await: r }); function n(e) { return { type: e, style: "keyword" } } var H, D, G = /[+\-*&%=<>!?|~^@]/, J = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)"/; function i(e, t, r) { return H = e, D = r, t } function d(e, t) { var a, r = e.next(); if ('"' == r || "'" == r) return t.tokenize = (a = r, function (e, t) { var r, n = !1; if (U && "@" == e.peek() && e.match(J)) return t.tokenize = d, i("jsonld-keyword", "meta"); for (; null != (r = e.next()) && (r != a || n);)n = !n && "\\" == r; return n || (t.tokenize = d), i("string", "string") }), t.tokenize(e, t); if ("." == r && e.match(/^\d[\d_]*(?:[eE][+\-]?[\d_]+)?/)) return i("number", "number"); if ("." == r && e.match("..")) return i("spread", "meta"); if (/[\[\]{}\(\),;\:\.]/.test(r)) return i(r); if ("=" == r && e.eat(">")) return i("=>", "operator"); if ("0" == r && e.match(/^(?:x[\dA-Fa-f_]+|o[0-7_]+|b[01_]+)n?/)) return i("number", "number"); if (/\d/.test(r)) return e.match(/^[\d_]*(?:n|(?:\.[\d_]*)?(?:[eE][+\-]?[\d_]+)?)?/), i("number", "number"); if ("/" == r) return e.eat("*") ? (t.tokenize = K)(e, t) : e.eat("/") ? (e.skipToEnd(), i("comment", "comment")) : tt(e, t, 1) ? (function (e) { for (var t, r = !1, n = !1; null != (t = e.next());) { if (!r) { if ("/" == t && !n) return; "[" == t ? n = !0 : n && "]" == t && (n = !1) } r = !r && "\\" == t } }(e), e.match(/^\b(([gimyus])(?![gimyus]*\2))+\b/), i("regexp", "string-2")) : (e.eat("="), i("operator", "operator", e.current())); if ("`" == r) return (t.tokenize = L)(e, t); if ("#" == r && "!" == e.peek()) return e.skipToEnd(), i("meta", "meta"); if ("#" == r && e.eatWhile(B)) return i("variable", "property"); if ("<" == r && e.match("!--") || "-" == r && e.match("->") && !/\S/.test(e.string.slice(0, e.start))) return e.skipToEnd(), i("comment", "comment"); if (G.test(r)) return ">" == r && t.lexical && ">" == t.lexical.type || (e.eat("=") ? "!" != r && "=" != r || e.eat("=") : /[<>*+\-|&?]/.test(r) && (e.eat(r), ">" == r && e.eat(r))), "?" == r && e.eat(".") ? i(".") : i("operator", "operator", e.current()); if (B.test(r)) { e.eatWhile(B); r = e.current(); if ("." != t.lastType) { if (F.propertyIsEnumerable(r)) return i((t = F[r]).type, t.style, r); if ("async" == r && e.match(/^(\s|\/\*([^*]|\*(?!\/))*?\*\/)*[\[\(\w]/, !1)) return i("async", "keyword", r) } return i("variable", "variable", r) } } function K(e, t) { for (var r, n = !1; r = e.next();) { if ("/" == r && n) { t.tokenize = d; break } n = "*" == r } return i("comment", "comment") } function L(e, t) { for (var r, n = !1; null != (r = e.next());) { if (!n && ("`" == r || "$" == r && e.eat("{"))) { t.tokenize = d; break } n = !n && "\\" == r } return i("quasi", "string-2", e.current()) } function Q(e, t) { t.fatArrowAt && (t.fatArrowAt = null); var r = e.string.indexOf("=>", e.start); if (!(r < 0)) { !u || (n = /:\s*(?:\w+(?:<[^>]*>|\[\])?|\{[^}]*\})\s*$/.exec(e.string.slice(e.start, r))) && (r = n.index); for (var n, a = 0, i = !1, o = r - 1; 0 <= o; --o) { var c = e.string.charAt(o), s = "([{}])".indexOf(c); if (0 <= s && s < 3) { if (!a) { ++o; break } if (0 == --a) { "(" == c && (i = !0); break } } else if (3 <= s && s < 6) ++a; else if (B.test(c)) i = !0; else if (/["'\/`]/.test(c)) for (; ; --o) { if (0 == o) return; if (e.string.charAt(o - 1) == c && "\\" != e.string.charAt(o - 2)) { o--; break } } else if (i && !a) { ++o; break } } i && !a && (t.fatArrowAt = o) } } var R = { atom: !0, number: !0, variable: !0, string: !0, regexp: !0, this: !0, import: !0, "jsonld-keyword": !0 }; function X(e, t, r, n, a, i) { this.indented = e, this.column = t, this.type = r, this.prev = a, this.info = i, null != n && (this.align = n) } function Y(e, t, r, n, a) { var i = e.cc; for (c.state = e, c.stream = a, c.marked = null, c.cc = i, c.style = t, e.lexical.hasOwnProperty("align") || (e.lexical.align = !0); ;)if ((i.length ? i.pop() : o ? x : b)(r, n)) { for (; i.length && i[i.length - 1].lex;)i.pop()(); return c.marked ? c.marked : "variable" == r && function (e, t) { if (W) { for (var r = e.localVars; r; r = r.next)if (r.name == t) return 1; for (var n = e.context; n; n = n.prev)for (r = n.vars; r; r = r.next)if (r.name == t) return 1 } }(e, n) ? "variable-2" : t } } var c = { state: null, column: null, marked: null, cc: null }; function s() { for (var e = arguments.length - 1; 0 <= e; e--)c.cc.push(arguments[e]) } function p() { return s.apply(null, arguments), !0 } function Z(e, t) { for (var r = t; r; r = r.next)if (r.name == e) return 1 } function a(e) { var t = c.state; if (c.marked = "def", W) { if (t.context) if ("var" == t.lexical.info && t.context && t.context.block) { var r = function e(t, r) { { var n; return r ? r.block ? (n = e(t, r.prev)) ? n == r.prev ? r : new te(n, r.vars, !0) : null : Z(t, r.vars) ? r : new te(r.prev, new re(t, r.vars), !1) : null } }(e, t.context); if (null != r) return void (t.context = r) } else if (!Z(e, t.localVars)) return void (t.localVars = new re(e, t.localVars)); l.globalVars && !Z(e, t.globalVars) && (t.globalVars = new re(e, t.globalVars)) } } function ee(e) { return "public" == e || "private" == e || "protected" == e || "abstract" == e || "readonly" == e } function te(e, t, r) { this.prev = e, this.vars = t, this.block = r } function re(e, t) { this.name = e, this.next = t } var ne = new re("this", new re("arguments", null)); function m() { c.state.context = new te(c.state.context, c.state.localVars, !1), c.state.localVars = ne } function ae() { c.state.context = new te(c.state.context, c.state.localVars, !0), c.state.localVars = null } function k() { c.state.localVars = c.state.context.vars, c.state.context = c.state.context.prev } function v(n, a) { function e() { var e = c.state, t = e.indented; if ("stat" == e.lexical.type) t = e.lexical.indented; else for (var r = e.lexical; r && ")" == r.type && r.align; r = r.prev)t = r.indented; e.lexical = new X(t, c.stream.column(), n, null, e.lexical, a) } return e.lex = !0, e } function y() { var e = c.state; e.lexical.prev && (")" == e.lexical.type && (e.indented = e.lexical.indented), e.lexical = e.lexical.prev) } function w(r) { return function e(t) { return t == r ? p() : ";" == r || "}" == t || ")" == t || "]" == t ? s() : p(e) } } function b(e, t) { return "var" == e ? p(v("vardef", t), qe, w(";"), y) : "keyword a" == e ? p(v("form"), oe, b, y) : "keyword b" == e ? p(v("form"), b, y) : "keyword d" == e ? c.stream.match(/^\s*$/, !1) ? p() : p(v("stat"), g, w(";"), y) : "debugger" == e ? p(w(";")) : "{" == e ? p(v("}"), ae, be, y, k) : ";" == e ? p() : "if" == e ? ("else" == c.state.lexical.info && c.state.cc[c.state.cc.length - 1] == y && c.state.cc.pop()(), p(v("form"), oe, b, y, Oe)) : "function" == e ? p(q) : "for" == e ? p(v("form"), ae, Pe, b, k, y) : "class" == e || u && "interface" == t ? (c.marked = "keyword", p(v("form", "class" == e ? e : t), Fe, y)) : "variable" == e ? u && "declare" == t ? (c.marked = "keyword", p(b)) : u && ("module" == t || "enum" == t || "type" == t) && c.stream.match(/^\s*\w/, !1) ? (c.marked = "keyword", "enum" == t ? p(Ze) : "type" == t ? p(We, w("operator"), z, w(";")) : p(v("form"), T, w("{"), v("}"), be, y, y)) : u && "namespace" == t ? (c.marked = "keyword", p(v("form"), x, b, y)) : u && "abstract" == t ? (c.marked = "keyword", p(b)) : p(v("stat"), me) : "switch" == e ? p(v("form"), oe, w("{"), v("}", "switch"), ae, be, y, y, k) : "case" == e ? p(x, w(":")) : "default" == e ? p(w(":")) : "catch" == e ? p(v("form"), m, ie, b, y, k) : "export" == e ? p(v("stat"), Ge, y) : "import" == e ? p(v("stat"), Ke, y) : "async" == e ? p(b) : "@" == t ? p(x, b) : s(v("stat"), x, w(";"), y) } function ie(e) { if ("(" == e) return p(S, w(")")) } function x(e, t) { return ce(e, t, !1) } function h(e, t) { return ce(e, t, !0) } function oe(e) { return "(" != e ? s() : p(v(")"), g, w(")"), y) } function ce(e, t, r) { if (c.state.fatArrowAt == c.stream.start) { var n = r ? fe : le; if ("(" == e) return p(m, v(")"), V(S, ")"), y, w("=>"), n, k); if ("variable" == e) return s(m, T, w("=>"), n, k) } var a, n = r ? M : j; return R.hasOwnProperty(e) ? p(n) : "function" == e ? p(q, n) : "class" == e || u && "interface" == t ? (c.marked = "keyword", p(v("form"), Be, y)) : "keyword c" == e || "async" == e ? p(r ? h : x) : "(" == e ? p(v(")"), g, w(")"), y, n) : "operator" == e || "spread" == e ? p(r ? h : x) : "[" == e ? p(v("]"), Ye, y, n) : "{" == e ? we(ve, "}", null, n) : "quasi" == e ? s(se, n) : "new" == e ? p((a = r, function (e) { return "." == e ? p(a ? pe : de) : "variable" == e && u ? p(Ie, a ? M : j) : s(a ? h : x) })) : p() } function g(e) { return e.match(/[;\}\)\],]/) ? s() : s(x) } function j(e, t) { return "," == e ? p(g) : M(e, t, !1) } function M(e, t, r) { var n = 0 == r ? j : M, a = 0 == r ? x : h; return "=>" == e ? p(m, r ? fe : le, k) : "operator" == e ? /\+\+|--/.test(t) || u && "!" == t ? p(n) : u && "<" == t && c.stream.match(/^([^<>]|<[^<>]*>)*>\s*\(/, !1) ? p(v(">"), V(z, ">"), y, n) : "?" == t ? p(x, w(":"), a) : p(a) : "quasi" == e ? s(se, n) : ";" != e ? "(" == e ? we(h, ")", "call", n) : "." == e ? p(ke, n) : "[" == e ? p(v("]"), g, w("]"), y, n) : u && "as" == t ? (c.marked = "keyword", p(z, n)) : "regexp" == e ? (c.state.lastType = c.marked = "operator", c.stream.backUp(c.stream.pos - c.stream.start - 1), p(a)) : void 0 : void 0 } function se(e, t) { return "quasi" != e ? s() : "${" != t.slice(t.length - 2) ? p(se) : p(g, ue) } function ue(e) { if ("}" == e) return c.marked = "string-2", c.state.tokenize = L, p(se) } function le(e) { return Q(c.stream, c.state), s("{" == e ? b : x) } function fe(e) { return Q(c.stream, c.state), s("{" == e ? b : h) } function de(e, t) { if ("target" == t) return c.marked = "keyword", p(j) } function pe(e, t) { if ("target" == t) return c.marked = "keyword", p(M) } function me(e) { return ":" == e ? p(y, b) : s(j, w(";"), y) } function ke(e) { if ("variable" == e) return c.marked = "property", p() } function ve(e, t) { return "async" == e ? (c.marked = "property", p(ve)) : "variable" != e && "keyword" != c.style ? "number" == e || "string" == e ? (c.marked = U ? "property" : c.style + " property", p(A)) : "jsonld-keyword" == e ? p(A) : u && ee(t) ? (c.marked = "keyword", p(ve)) : "[" == e ? p(x, E, w("]"), A) : "spread" == e ? p(h, A) : "*" == t ? (c.marked = "keyword", p(ve)) : ":" == e ? s(A) : void 0 : (c.marked = "property", "get" == t || "set" == t ? p(ye) : (u && c.state.fatArrowAt == c.stream.start && (e = c.stream.match(/^\s*:\s*/, !1)) && (c.state.fatArrowAt = c.stream.pos + e[0].length), p(A))) } function ye(e) { return "variable" != e ? s(A) : (c.marked = "property", p(q)) } function A(e) { return ":" == e ? p(h) : "(" == e ? s(q) : void 0 } function V(n, a, i) { function o(e, t) { var r; return (i ? -1 < i.indexOf(e) : "," == e) ? ("call" == (r = c.state.lexical).info && (r.pos = (r.pos || 0) + 1), p(function (e, t) { return e == a || t == a ? s() : s(n) }, o)) : e == a || t == a ? p() : i && -1 < i.indexOf(";") ? s(n) : p(w(a)) } return function (e, t) { return e == a || t == a ? p() : s(n, o) } } function we(e, t, r) { for (var n = 3; n < arguments.length; n++)c.cc.push(arguments[n]); return p(v(t, r), V(e, t), y) } function be(e) { return "}" == e ? p() : s(b, be) } function E(e, t) { if (u) return ":" == e ? p(z) : "?" == t ? p(E) : void 0 } function xe(e, t) { if (u && (":" == e || "in" == t)) return p(z) } function he(e) { if (u && ":" == e) return c.stream.match(/^\s*\w+\s+is\b/, !1) ? p(x, ge, z) : p(z) } function ge(e, t) { if ("is" == t) return c.marked = "keyword", p() } function z(e, t) { return "keyof" == t || "typeof" == t || "infer" == t || "readonly" == t ? (c.marked = "keyword", p("typeof" == t ? h : z)) : "variable" == e || "void" == t ? (c.marked = "type", p(I)) : "|" == t || "&" == t ? p(z) : "string" == e || "number" == e || "atom" == e ? p(I) : "[" == e ? p(v("]"), V(z, "]", ","), y, I) : "{" == e ? p(v("}"), Me, y, I) : "(" == e ? p(V(ze, ")"), je, I) : "<" == e ? p(V(z, ">"), z) : "quasi" == e ? s(Ve, I) : void 0 } function je(e) { if ("=>" == e) return p(z) } function Me(e) { return e.match(/[\}\)\]]/) ? p() : "," == e || ";" == e ? p(Me) : s(Ae, Me) } function Ae(e, t) { return "variable" == e || "keyword" == c.style ? (c.marked = "property", p(Ae)) : "?" == t || "number" == e || "string" == e ? p(Ae) : ":" == e ? p(z) : "[" == e ? p(w("variable"), xe, w("]"), Ae) : "(" == e ? s(C, Ae) : e.match(/[;\}\)\],]/) ? void 0 : p() } function Ve(e, t) { return "quasi" != e ? s() : "${" != t.slice(t.length - 2) ? p(Ve) : p(z, Ee) } function Ee(e) { if ("}" == e) return c.marked = "string-2", c.state.tokenize = L, p(Ve) } function ze(e, t) { return "variable" == e && c.stream.match(/^\s*[?:]/, !1) || "?" == t ? p(ze) : ":" == e ? p(z) : "spread" == e ? p(ze) : s(z) } function I(e, t) { return "<" == t ? p(v(">"), V(z, ">"), y, I) : "|" == t || "." == e || "&" == t ? p(z) : "[" == e ? p(z, w("]"), I) : "extends" == t || "implements" == t ? (c.marked = "keyword", p(z)) : "?" == t ? p(z, w(":"), z) : void 0 } function Ie(e, t) { if ("<" == t) return p(v(">"), V(z, ">"), y, I) } function Te() { return s(z, $e) } function $e(e, t) { if ("=" == t) return p(z) } function qe(e, t) { return "enum" == t ? (c.marked = "keyword", p(Ze)) : s(T, E, $, _e) } function T(e, t) { return u && ee(t) ? (c.marked = "keyword", p(T)) : "variable" == e ? (a(t), p()) : "spread" == e ? p(T) : "[" == e ? we(Se, "]") : "{" == e ? we(Ce, "}") : void 0 } function Ce(e, t) { return "variable" != e || c.stream.match(/^\s*:/, !1) ? ("variable" == e && (c.marked = "property"), "spread" == e ? p(T) : "}" == e ? s() : "[" == e ? p(x, w("]"), w(":"), Ce) : p(w(":"), T, $)) : (a(t), p($)) } function Se() { return s(T, $) } function $(e, t) { if ("=" == t) return p(h) } function _e(e) { if ("," == e) return p(qe) } function Oe(e, t) { if ("keyword b" == e && "else" == t) return p(v("form", "else"), b, y) } function Pe(e, t) { return "await" == t ? p(Pe) : "(" == e ? p(v(")"), Ne, y) : void 0 } function Ne(e) { return "var" == e ? p(qe, Ue) : ("variable" == e ? p : s)(Ue) } function Ue(e, t) { return ")" == e ? p() : ";" == e ? p(Ue) : "in" == t || "of" == t ? (c.marked = "keyword", p(x, Ue)) : s(x, Ue) } function q(e, t) { return "*" == t ? (c.marked = "keyword", p(q)) : "variable" == e ? (a(t), p(q)) : "(" == e ? p(m, v(")"), V(S, ")"), y, he, b, k) : u && "<" == t ? p(v(">"), V(Te, ">"), y, q) : void 0 } function C(e, t) { return "*" == t ? (c.marked = "keyword", p(C)) : "variable" == e ? (a(t), p(C)) : "(" == e ? p(m, v(")"), V(S, ")"), y, he, k) : u && "<" == t ? p(v(">"), V(Te, ">"), y, C) : void 0 } function We(e, t) { return "keyword" == e || "variable" == e ? (c.marked = "type", p(We)) : "<" == t ? p(v(">"), V(Te, ">"), y) : void 0 } function S(e, t) { return "@" == t && p(x, S), "spread" == e ? p(S) : u && ee(t) ? (c.marked = "keyword", p(S)) : u && "this" == e ? p(E, $) : s(T, E, $) } function Be(e, t) { return ("variable" == e ? Fe : He)(e, t) } function Fe(e, t) { if ("variable" == e) return a(t), p(He) } function He(e, t) { return "<" == t ? p(v(">"), V(Te, ">"), y, He) : "extends" == t || "implements" == t || u && "," == e ? ("implements" == t && (c.marked = "keyword"), p(u ? z : x, He)) : "{" == e ? p(v("}"), _, y) : void 0 } function _(e, t) { return "async" == e || "variable" == e && ("static" == t || "get" == t || "set" == t || u && ee(t)) && c.stream.match(/^\s+#?[\w$\xa1-\uffff]/, !1) ? (c.marked = "keyword", p(_)) : "variable" == e || "keyword" == c.style ? (c.marked = "property", p(De, _)) : "number" == e || "string" == e ? p(De, _) : "[" == e ? p(x, E, w("]"), De, _) : "*" == t ? (c.marked = "keyword", p(_)) : u && "(" == e ? s(C, _) : ";" == e || "," == e ? p(_) : "}" == e ? p() : "@" == t ? p(x, _) : void 0 } function De(e, t) { if ("!" == t) return p(De); if ("?" == t) return p(De); if (":" == e) return p(z, $); if ("=" == t) return p(h); e = c.state.lexical.prev; return s(e && "interface" == e.info ? C : q) } function Ge(e, t) { return "*" == t ? (c.marked = "keyword", p(Xe, w(";"))) : "default" == t ? (c.marked = "keyword", p(x, w(";"))) : "{" == e ? p(V(Je, "}"), Xe, w(";")) : s(b) } function Je(e, t) { return "as" == t ? (c.marked = "keyword", p(w("variable"))) : "variable" == e ? s(h, Je) : void 0 } function Ke(e) { return "string" == e ? p() : "(" == e ? s(x) : "." == e ? s(j) : s(Le, Qe, Xe) } function Le(e, t) { return "{" == e ? we(Le, "}") : ("variable" == e && a(t), "*" == t && (c.marked = "keyword"), p(Re)) } function Qe(e) { if ("," == e) return p(Le, Qe) } function Re(e, t) { if ("as" == t) return c.marked = "keyword", p(Le) } function Xe(e, t) { if ("from" == t) return c.marked = "keyword", p(x) } function Ye(e) { return "]" == e ? p() : s(V(h, "]")) } function Ze() { return s(v("form"), T, w("{"), v("}"), V(et, "}"), y, y) } function et() { return s(T, $) } function tt(e, t, r) { return t.tokenize == d && /^(?:operator|sof|keyword [bcd]|case|new|export|default|spread|[\[{}\(,;:]|=>)$/.test(t.lastType) || "quasi" == t.lastType && /\{\s*$/.test(e.string.slice(0, e.pos - (r || 0))) } return m.lex = ae.lex = !0, y.lex = k.lex = !0, { startState: function (e) { e = { tokenize: d, lastType: "sof", cc: [], lexical: new X((e || 0) - f, 0, "block", !1), localVars: l.localVars, context: l.localVars && new te(null, null, !1), indented: e || 0 }; return l.globalVars && "object" == typeof l.globalVars && (e.globalVars = l.globalVars), e }, token: function (e, t) { if (e.sol() && (t.lexical.hasOwnProperty("align") || (t.lexical.align = !1), t.indented = e.indentation(), Q(e, t)), t.tokenize != K && e.eatSpace()) return null; var r = t.tokenize(e, t); return "comment" == H ? r : (t.lastType = "operator" != H || "++" != D && "--" != D ? H : "incdec", Y(t, r, H, D, e)) }, indent: function (e, t) { if (e.tokenize == K || e.tokenize == L) return rt.Pass; if (e.tokenize != d) return 0; var r, n = t && t.charAt(0), a = e.lexical; if (!/^\s*else\b/.test(t)) for (var i = e.cc.length - 1; 0 <= i; --i) { var o = e.cc[i]; if (o == y) a = a.prev; else if (o != Oe && o != k) break } for (; ("stat" == a.type || "form" == a.type) && ("}" == n || (r = e.cc[e.cc.length - 1]) && (r == j || r == M) && !/^[,\.=+\-*:?[\(]/.test(t));)a = a.prev; var c, s = (a = N && ")" == a.type && "stat" == a.prev.type ? a.prev : a).type, u = n == s; return "vardef" == s ? a.indented + ("operator" == e.lastType || "," == e.lastType ? a.info.length + 1 : 0) : "form" == s && "{" == n ? a.indented : "form" == s ? a.indented + f : "stat" == s ? a.indented + (s = t, "operator" == (c = e).lastType || "," == c.lastType || G.test(s.charAt(0)) || /[,.]/.test(s.charAt(0)) ? N || f : 0) : "switch" != a.info || u || 0 == l.doubleIndentSwitch ? a.align ? a.column + (u ? 0 : 1) : a.indented + (u ? 0 : f) : a.indented + (/^(?:case|default)\b/.test(t) ? f : 2 * f) }, electricInput: /^\s*(?:case .*?:|default:|\{|\})$/, blockCommentStart: o ? null : "/*", blockCommentEnd: o ? null : "*/", blockCommentContinue: o ? null : " * ", lineComment: o ? null : "//", fold: "brace", closeBrackets: "()[]{}''\"\"``", helperType: o ? "json" : "javascript", jsonldMode: U, jsonMode: o, expressionAllowed: tt, skipExpression: function (e) { Y(e, "atom", "atom", "true", new rt.StringStream("", 2, null)) } } }), rt.registerHelper("wordChars", "javascript", /[\w$]/), rt.defineMIME("text/javascript", "javascript"), rt.defineMIME("text/ecmascript", "javascript"), rt.defineMIME("application/javascript", "javascript"), rt.defineMIME("application/x-javascript", "javascript"), rt.defineMIME("application/ecmascript", "javascript"), rt.defineMIME("application/json", { name: "javascript", json: !0 }), rt.defineMIME("application/x-json", { name: "javascript", json: !0 }), rt.defineMIME("application/manifest+json", { name: "javascript", json: !0 }), rt.defineMIME("application/ld+json", { name: "javascript", jsonld: !0 }), rt.defineMIME("text/typescript", { name: "javascript", typescript: !0 }), rt.defineMIME("application/typescript", { name: "javascript", typescript: !0 }) }); !function (t) { "object" == typeof exports && "object" == typeof module ? t(require("../../lib/codemirror")) : "function" == typeof define && define.amd ? define(["../../lib/codemirror"], t) : t(CodeMirror) }(function (y) { "use strict"; var C = { autoSelfClosers: { area: !0, base: !0, br: !0, col: !0, command: !0, embed: !0, frame: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0, menuitem: !0 }, implicitlyClosed: { dd: !0, li: !0, optgroup: !0, option: !0, p: !0, rp: !0, rt: !0, tbody: !0, td: !0, tfoot: !0, th: !0, tr: !0 }, contextGrabbers: { dd: { dd: !0, dt: !0 }, dt: { dd: !0, dt: !0 }, li: { li: !0 }, option: { option: !0, optgroup: !0 }, optgroup: { optgroup: !0 }, p: { address: !0, article: !0, aside: !0, blockquote: !0, dir: !0, div: !0, dl: !0, fieldset: !0, footer: !0, form: !0, h1: !0, h2: !0, h3: !0, h4: !0, h5: !0, h6: !0, header: !0, hgroup: !0, hr: !0, menu: !0, nav: !0, ol: !0, p: !0, pre: !0, section: !0, table: !0, ul: !0 }, rp: { rp: !0, rt: !0 }, rt: { rp: !0, rt: !0 }, tbody: { tbody: !0, tfoot: !0 }, td: { td: !0, th: !0 }, tfoot: { tbody: !0 }, th: { td: !0, th: !0 }, thead: { tbody: !0, tfoot: !0 }, tr: { tr: !0 } }, doNotIndent: { pre: !0 }, allowUnquoted: !0, allowMissing: !0, caseFold: !0 }, z = { autoSelfClosers: {}, implicitlyClosed: {}, contextGrabbers: {}, doNotIndent: {}, allowUnquoted: !1, allowMissing: !1, allowMissingTagName: !1, caseFold: !1 }; y.defineMode("xml", function (t, e) { var n, i, a, l = t.indentUnit, u = {}, r = e.htmlMode ? C : z; for (n in r) u[n] = r[n]; for (n in e) u[n] = e[n]; function c(e, n) { function t(t) { return (n.tokenize = t)(e, n) } var r = e.next(); return "<" == r ? e.eat("!") ? e.eat("[") ? e.match("CDATA[") ? t(o("atom", "]]>")) : null : e.match("--") ? t(o("comment", "--\x3e")) : e.match("DOCTYPE", !0, !0) ? (e.eatWhile(/[\w\._\-]/), t(function r(o) { return function (t, e) { for (var n; null != (n = t.next());) { if ("<" == n) return e.tokenize = r(o + 1), e.tokenize(t, e); if (">" == n) { if (1 != o) return e.tokenize = r(o - 1), e.tokenize(t, e); e.tokenize = c; break } } return "meta" } }(1))) : null : e.eat("?") ? (e.eatWhile(/[\w\._\-]/), n.tokenize = o("meta", "?>"), "meta") : (i = e.eat("/") ? "closeTag" : "openTag", n.tokenize = d, "tag bracket") : "&" == r ? (e.eat("#") ? e.eat("x") ? e.eatWhile(/[a-fA-F\d]/) && e.eat(";") : e.eatWhile(/[\d]/) && e.eat(";") : e.eatWhile(/[\w\.\-:]/) && e.eat(";")) ? "atom" : "error" : (e.eatWhile(/[^&<]/), null) } function d(t, e) { var n, r, o = t.next(); return ">" == o || "/" == o && t.eat(">") ? (e.tokenize = c, i = ">" == o ? "endTag" : "selfcloseTag", "tag bracket") : "=" == o ? (i = "equals", null) : "<" == o ? (e.tokenize = c, e.state = p, e.tagName = e.tagStart = null, (n = e.tokenize(t, e)) ? n + " tag error" : "tag error") : /[\'\"]/.test(o) ? (e.tokenize = (r = o, a.isInAttribute = !0, a), e.stringStartCol = t.column(), e.tokenize(t, e)) : (t.match(/^[^\s\u00a0=<>\"\']*[^\s\u00a0=<>\"\'\/]/), "word"); function a(t, e) { for (; !t.eol();)if (t.next() == r) { e.tokenize = d; break } return "string" } } function o(n, r) { return function (t, e) { for (; !t.eol();) { if (t.match(r)) { e.tokenize = c; break } t.next() } return n } } function s(t) { return t && t.toLowerCase() } function f(t, e, n) { this.prev = t.context, this.tagName = e || "", this.indent = t.indented, this.startOfLine = n, (u.doNotIndent.hasOwnProperty(e) || t.context && t.context.noIndent) && (this.noIndent = !0) } function m(t) { t.context && (t.context = t.context.prev) } function g(t, e) { for (var n; ;) { if (!t.context) return; if (n = t.context.tagName, !u.contextGrabbers.hasOwnProperty(s(n)) || !u.contextGrabbers[s(n)].hasOwnProperty(s(e))) return; m(t) } } function p(t, e, n) { return "openTag" == t ? (n.tagStart = e.column(), h) : "closeTag" == t ? x : p } function h(t, e, n) { return "word" == t ? (n.tagName = e.current(), a = "tag", w) : u.allowMissingTagName && "endTag" == t ? (a = "tag bracket", w(t, 0, n)) : (a = "error", h) } function x(t, e, n) { var r; return "word" == t ? (r = e.current(), n.context && n.context.tagName != r && u.implicitlyClosed.hasOwnProperty(s(n.context.tagName)) && m(n), n.context && n.context.tagName == r || !1 === u.matchClosing ? (a = "tag", b) : (a = "tag error", k)) : u.allowMissingTagName && "endTag" == t ? (a = "tag bracket", b(t, 0, n)) : (a = "error", k) } function b(t, e, n) { return "endTag" != t ? (a = "error", b) : (m(n), p) } function k(t, e, n) { return a = "error", b(t, 0, n) } function w(t, e, n) { return "word" == t ? (a = "attribute", T) : "endTag" == t || "selfcloseTag" == t ? (r = n.tagName, o = n.tagStart, n.tagName = n.tagStart = null, "selfcloseTag" == t || u.autoSelfClosers.hasOwnProperty(s(r)) ? g(n, r) : (g(n, r), n.context = new f(n, r, o == n.indented)), p) : (a = "error", w); var r, o } function T(t, e, n) { return "equals" == t ? v : (u.allowMissing || (a = "error"), w(t, 0, n)) } function v(t, e, n) { return "string" == t ? N : "word" == t && u.allowUnquoted ? (a = "string", w) : (a = "error", w(t, 0, n)) } function N(t, e, n) { return "string" == t ? N : w(t, 0, n) } return c.isInText = !0, { startState: function (t) { var e = { tokenize: c, state: p, indented: t || 0, tagName: null, tagStart: null, context: null }; return null != t && (e.baseIndent = t), e }, token: function (t, e) { if (!e.tagName && t.sol() && (e.indented = t.indentation()), t.eatSpace()) return null; i = null; var n = e.tokenize(t, e); return (n || i) && "comment" != n && (a = null, e.state = e.state(i || n, t, e), a && (n = "error" == a ? n + " error" : a)), n }, indent: function (t, e, n) { var r = t.context; if (t.tokenize.isInAttribute) return t.tagStart == t.indented ? t.stringStartCol + 1 : t.indented + l; if (r && r.noIndent) return y.Pass; if (t.tokenize != d && t.tokenize != c) return n ? n.match(/^(\s*)/)[0].length : 0; if (t.tagName) return !1 !== u.multilineTagIndentPastTag ? t.tagStart + t.tagName.length + 2 : t.tagStart + l * (u.multilineTagIndentFactor || 1); if (u.alignCDATA && /<!\[CDATA\[/.test(e)) return 0; var o = e && /^<(\/)?([\w_:\.-]*)/.exec(e); if (o && o[1]) for (; r;) { if (r.tagName == o[2]) { r = r.prev; break } if (!u.implicitlyClosed.hasOwnProperty(s(r.tagName))) break; r = r.prev } else if (o) for (; r;) { var a = u.contextGrabbers[s(r.tagName)]; if (!a || !a.hasOwnProperty(s(o[2]))) break; r = r.prev } for (; r && r.prev && !r.startOfLine;)r = r.prev; return r ? r.indent + l : t.baseIndent || 0 }, electricInput: /<\/[\s\w:]+>$/, blockCommentStart: "\x3c!--", blockCommentEnd: "--\x3e", configuration: u.htmlMode ? "html" : "xml", helperType: u.htmlMode ? "html" : "xml", skipAttribute: function (t) { t.state == v && (t.state = w) }, xmlCurrentTag: function (t) { return t.tagName ? { name: t.tagName, close: "closeTag" == t.type } : null }, xmlCurrentContext: function (t) { for (var e = [], n = t.context; n; n = n.prev)e.push(n.tagName); return e.reverse() } } }), y.defineMIME("text/xml", "xml"), y.defineMIME("application/xml", "xml"), y.mimeModes.hasOwnProperty("text/html") || y.defineMIME("text/html", { name: "xml", htmlMode: !0 }) }); !function (t) { "object" == typeof exports && "object" == typeof module ? t(require("../../lib/codemirror"), require("../xml/xml"), require("../meta")) : "function" == typeof define && define.amd ? define(["../../lib/codemirror", "../xml/xml", "../meta"], t) : t(CodeMirror) }(function (w) { "use strict"; w.defineMode("markdown", function (m, d) { var g = w.getMode(m, "text/html"), u = "null" == g.name; void 0 === d.highlightFormatting && (d.highlightFormatting = !1), void 0 === d.maxBlockquoteDepth && (d.maxBlockquoteDepth = 0), void 0 === d.taskLists && (d.taskLists = !1), void 0 === d.strikethrough && (d.strikethrough = !1), void 0 === d.emoji && (d.emoji = !1), void 0 === d.fencedCodeBlockHighlighting && (d.fencedCodeBlockHighlighting = !0), void 0 === d.fencedCodeBlockDefaultMode && (d.fencedCodeBlockDefaultMode = "text/plain"), void 0 === d.xml && (d.xml = !0), void 0 === d.tokenTypeOverrides && (d.tokenTypeOverrides = {}); var t, c = { header: "header", code: "comment", quote: "quote", list1: "variable-2", list2: "variable-3", list3: "keyword", hr: "hr", image: "image", imageAltText: "image-alt-text", imageMarker: "image-marker", formatting: "formatting", linkInline: "link", linkEmail: "link", linkText: "link", linkHref: "string", em: "em", strong: "strong", strikethrough: "strikethrough", emoji: "builtin" }; for (t in c) c.hasOwnProperty(t) && d.tokenTypeOverrides[t] && (c[t] = d.tokenTypeOverrides[t]); var f = /^([*\-_])(?:\s*\1){2,}\s*$/, k = /^(?:[*\-+]|^[0-9]+([.)]))\s+/, F = /^\[(x| )\](?=\s)/i, D = d.allowAtxHeaderWithoutSpace ? /^(#+)/ : /^(#+)(?: |$)/, p = /^ {0,3}(?:\={1,}|-{2,})\s*$/, i = /^[^#!\[\]*_\\<>` "'(~:]+/, E = /^(~~~+|```+)[ \t]*([\w\/+#-]*)[^\n`]*$/, x = /^\s*\[[^\]]+?\]:.*$/, A = /[!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E42\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC9\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDF3C-\uDF3E]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]/; function C(t, e, i) { return (e.f = e.inline = i)(t, e) } function S(t, e, i) { return (e.f = e.block = i)(t, e) } function n(t) { var e; return t.linkTitle = !1, t.linkHref = !1, t.linkText = !1, t.em = !1, t.strong = !1, t.strikethrough = !1, t.quote = 0, t.indentedCode = !1, t.f == v && (u ? u : "xml" == (e = w.innerMode(g, t.htmlState)).mode.name && null === e.state.tagStart && !e.state.context && e.state.tokenize.isInText) && (t.f = T, t.block = a, t.htmlState = null), t.trailingSpace = 0, t.trailingSpaceNewLine = !1, t.prevLine = t.thisLine, t.thisLine = { stream: null }, null } function a(t, e) { var i = t.column() === e.indentation, n = !(n = e.prevLine.stream) || !/\S/.test(n.string), u = e.indentedCode, a = e.prevLine.hr, r = !1 !== e.list, o = (e.listStack[e.listStack.length - 1] || 0) + 3, l = (e.indentedCode = !1, e.indentation); if (null === e.indentationDiff && (e.indentationDiff = e.indentation, r)) { for (e.list = null; l < e.listStack[e.listStack.length - 1];)e.listStack.pop(), e.listStack.length ? e.indentation = e.listStack[e.listStack.length - 1] : e.list = !1; !1 !== e.list && (e.indentationDiff = l - e.listStack[e.listStack.length - 1]) } var h, s = !(n || a || e.prevLine.header || r && u || e.prevLine.fencedCodeEnd), a = (!1 === e.list || a || n) && e.indentation <= o && t.match(f), g = null; return 4 <= e.indentationDiff && (u || e.prevLine.fencedCodeEnd || e.prevLine.header || n) ? (t.skipToEnd(), e.indentedCode = !0, c.code) : t.eatSpace() ? null : i && e.indentation <= o && (g = t.match(D)) && g[1].length <= 6 ? (e.quote = 0, e.header = g[1].length, e.thisLine.header = !0, d.highlightFormatting && (e.formatting = "header"), e.f = e.inline, L(e)) : e.indentation <= o && t.eat(">") ? (e.quote = i ? 1 : e.quote + 1, d.highlightFormatting && (e.formatting = "quote"), t.eatSpace(), L(e)) : !a && !e.setext && i && e.indentation <= o && (g = t.match(k)) ? (u = g[1] ? "ol" : "ul", e.indentation = l + t.current().length, e.list = !0, e.quote = 0, e.listStack.push(e.indentation), e.em = !1, e.strong = !1, e.code = !1, e.strikethrough = !1, d.taskLists && t.match(F, !1) && (e.taskList = !0), e.f = e.inline, d.highlightFormatting && (e.formatting = ["list", "list-" + u]), L(e)) : i && e.indentation <= o && (g = t.match(E, !0)) ? (e.quote = 0, e.fencedEndRE = new RegExp(g[1] + "+ *$"), e.localMode = d.fencedCodeBlockHighlighting && (n = g[2] || d.fencedCodeBlockDefaultMode, w.findModeByName && (h = w.findModeByName(n)) && (n = h.mime || h.mimes[0]), "null" == (h = w.getMode(m, n)).name ? null : h), e.localMode && (e.localState = w.startState(e.localMode)), e.f = e.block = B, d.highlightFormatting && (e.formatting = "code-block"), e.code = -1, L(e)) : e.setext || !(s && r || e.quote || !1 !== e.list || e.code || a || x.test(t.string)) && (g = t.lookAhead(1)) && (g = g.match(p)) ? (e.setext ? (e.header = e.setext, e.setext = 0, t.skipToEnd(), d.highlightFormatting && (e.formatting = "header")) : (e.header = "=" == g[0].charAt(0) ? 1 : 2, e.setext = e.header), e.thisLine.header = !0, e.f = e.inline, L(e)) : a ? (t.skipToEnd(), e.hr = !0, e.thisLine.hr = !0, c.hr) : "[" === t.peek() ? C(t, e, b) : C(t, e, e.inline) } function v(t, e) { var i, n = g.token(t, e.htmlState); return u || ("xml" == (i = w.innerMode(g, e.htmlState)).mode.name && null === i.state.tagStart && !i.state.context && i.state.tokenize.isInText || e.md_inside && -1 < t.current().indexOf(">")) && (e.f = T, e.block = a, e.htmlState = null), n } function B(t, e) { var i, n = e.listStack[e.listStack.length - 1] || 0, u = e.indentation < n; return e.fencedEndRE && e.indentation <= n + 3 && (u || t.match(e.fencedEndRE)) ? (d.highlightFormatting && (e.formatting = "code-block"), u || (i = L(e)), e.localMode = e.localState = null, e.block = a, e.f = T, e.fencedEndRE = null, e.code = 0, e.thisLine.fencedCodeEnd = !0, u ? S(t, e, e.block) : i) : e.localMode ? e.localMode.token(t, e.localState) : (t.skipToEnd(), c.code) } function L(t) { var e, i = []; if (t.formatting) { i.push(c.formatting), "string" == typeof t.formatting && (t.formatting = [t.formatting]); for (var n = 0; n < t.formatting.length; n++)i.push(c.formatting + "-" + t.formatting[n]), "header" === t.formatting[n] && i.push(c.formatting + "-" + t.formatting[n] + "-" + t.header), "quote" === t.formatting[n] && (!d.maxBlockquoteDepth || d.maxBlockquoteDepth >= t.quote ? i.push(c.formatting + "-" + t.formatting[n] + "-" + t.quote) : i.push("error")) } return t.taskOpen ? i.push("meta") : t.taskClosed ? i.push("property") : (t.linkHref ? i.push(c.linkHref, "url") : (t.strong && i.push(c.strong), t.em && i.push(c.em), t.strikethrough && i.push(c.strikethrough), t.emoji && i.push(c.emoji), t.linkText && i.push(c.linkText), t.code && i.push(c.code), t.image && i.push(c.image), t.imageAltText && i.push(c.imageAltText, "link"), t.imageMarker && i.push(c.imageMarker)), t.header && i.push(c.header, c.header + "-" + t.header), t.quote && (i.push(c.quote), !d.maxBlockquoteDepth || d.maxBlockquoteDepth >= t.quote ? i.push(c.quote + "-" + t.quote) : i.push(c.quote + "-" + d.maxBlockquoteDepth)), !1 !== t.list && ((e = (t.listStack.length - 1) % 3) ? 1 == e ? i.push(c.list2) : i.push(c.list3) : i.push(c.list1)), t.trailingSpaceNewLine ? i.push("trailing-space-new-line") : t.trailingSpace && i.push("trailing-space-" + (t.trailingSpace % 2 ? "a" : "b"))), i.length ? i.join(" ") : null } function e(t, e) { if (t.match(i, !0)) return L(e) } function T(t, e) { var i = e.text(t, e); if (void 0 !== i) return i; if (e.list) return e.list = null, L(e); if (e.taskList) return " " === t.match(F, !0)[1] ? e.taskOpen = !0 : e.taskClosed = !0, d.highlightFormatting && (e.formatting = "task"), e.taskList = !1, L(e); if (e.taskOpen = !1, e.taskClosed = !1, e.header && t.match(/^#+$/, !0)) return d.highlightFormatting && (e.formatting = "header"), L(e); var n = t.next(); if (e.linkTitle) { e.linkTitle = !1; var i = ((i = "(" === n ? ")" : n) + "").replace(/([.?*+^\[\]\\(){}|-])/g, "\\$1"); if (t.match(new RegExp("^\\s*(?:[^" + i + "\\\\]+|\\\\\\\\|\\\\.)" + i), !0)) return c.linkHref } if ("`" === n) return i = e.formatting, d.highlightFormatting && (e.formatting = "code"), t.eatWhile("`"), o = t.current().length, 0 != e.code || e.quote && 1 != o ? o == e.code ? (r = L(e), e.code = 0, r) : (e.formatting = i, L(e)) : (e.code = o, L(e)); if (e.code) return L(e); if ("\\" === n && (t.next(), d.highlightFormatting)) return a = L(e), i = c.formatting + "-escape", a ? a + " " + i : i; if ("!" === n && t.match(/\[[^\]]*\] ?(?:\(|\[)/, !1)) return e.imageMarker = !0, e.image = !0, d.highlightFormatting && (e.formatting = "image"), L(e); if ("[" === n && e.imageMarker && t.match(/[^\]]*\](\(.*?\)| ?\[.*?\])/, !1)) return e.imageMarker = !1, e.imageAltText = !0, d.highlightFormatting && (e.formatting = "image"), L(e); if ("]" === n && e.imageAltText) return d.highlightFormatting && (e.formatting = "image"), a = L(e), e.imageAltText = !1, e.image = !1, e.inline = e.f = q, a; if ("[" === n && !e.image) return e.linkText && t.match(/^.*?\]/) || (e.linkText = !0, d.highlightFormatting && (e.formatting = "link")), L(e); if ("]" === n && e.linkText) return d.highlightFormatting && (e.formatting = "link"), a = L(e), e.linkText = !1, e.inline = e.f = t.match(/\(.*?\)| ?\[.*?\]/, !1) ? q : T, a; if ("<" === n && t.match(/^(https?|ftps?):\/\/(?:[^\\>]|\\.)+>/, !1)) return e.f = e.inline = M, d.highlightFormatting && (e.formatting = "link"), (a = L(e)) ? a += " " : a = "", a + c.linkInline; if ("<" === n && t.match(/^[^> \\]+@(?:[^\\>]|\\.)+>/, !1)) return e.f = e.inline = M, d.highlightFormatting && (e.formatting = "link"), (a = L(e)) ? a += " " : a = "", a + c.linkEmail; if (d.xml && "<" === n && t.match(/^(!--|\?|!\[CDATA\[|[a-z][a-z0-9-]*(?:\s+[a-z_:.\-]+(?:\s*=\s*[^>]+)?)*\s*(?:>|$))/i, !1)) return -1 != (o = t.string.indexOf(">", t.pos)) && (i = t.string.substring(t.start, o), /markdown\s*=\s*('|"){0,1}1('|"){0,1}/.test(i) && (e.md_inside = !0)), t.backUp(1), e.htmlState = w.startState(g), S(t, e, v); if (d.xml && "<" === n && t.match(/^\/\w*?>/)) return e.md_inside = !1, "tag"; if ("*" === n || "_" === n) { for (var u = 1, a = 1 == t.pos ? " " : t.string.charAt(t.pos - 2); u < 3 && t.eat(n);)u++; var r, o = t.peek() || " ", i = !/\s/.test(o) && (!A.test(o) || /\s/.test(a) || A.test(a)), l = !/\s/.test(a) && (!A.test(a) || /\s/.test(o) || A.test(o)), h = null, s = null; if (u % 2 && (e.em || !i || "*" !== n && l && !A.test(a) ? e.em != n || !l || "*" !== n && i && !A.test(o) || (h = !1) : h = !0), 1 < u && (e.strong || !i || "*" !== n && l && !A.test(a) ? e.strong != n || !l || "*" !== n && i && !A.test(o) || (s = !1) : s = !0), null != s || null != h) return d.highlightFormatting && (e.formatting = null == h ? "strong" : null == s ? "em" : "strong em"), !0 === h && (e.em = n), !0 === s && (e.strong = n), r = L(e), !1 === h && (e.em = !1), !1 === s && (e.strong = !1), r } else if (" " === n && (t.eat("*") || t.eat("_"))) { if (" " === t.peek()) return L(e); t.backUp(1) } if (d.strikethrough) if ("~" === n && t.eatWhile(n)) { if (e.strikethrough) return d.highlightFormatting && (e.formatting = "strikethrough"), r = L(e), e.strikethrough = !1, r; if (t.match(/^[^\s]/, !1)) return e.strikethrough = !0, d.highlightFormatting && (e.formatting = "strikethrough"), L(e) } else if (" " === n && t.match("~~", !0)) { if (" " === t.peek()) return L(e); t.backUp(2) } return d.emoji && ":" === n && t.match(/^(?:[a-z_\d+][a-z_\d+-]*|\-[a-z_\d+][a-z_\d+-]*):/) ? (e.emoji = !0, d.highlightFormatting && (e.formatting = "emoji"), a = L(e), e.emoji = !1, a) : (" " === n && (t.match(/^ +$/, !1) ? e.trailingSpace++ : e.trailingSpace && (e.trailingSpaceNewLine = !0)), L(e)) } function M(t, e) { return ">" === t.next() ? (e.f = e.inline = T, d.highlightFormatting && (e.formatting = "link"), (e = L(e)) ? e += " " : e = "", e + c.linkInline) : (t.match(/^[^>]+/, !0), c.linkInline) } function q(t, e) { if (t.eatSpace()) return null; var n, t = t.next(); return "(" === t || "[" === t ? (e.f = e.inline = (n = "(" === t ? ")" : "]", function (t, e) { var i; return t.next() === n ? (e.f = e.inline = T, d.highlightFormatting && (e.formatting = "link-string"), i = L(e), e.linkHref = !1, i) : (t.match(r[n]), e.linkHref = !0, L(e)) }), d.highlightFormatting && (e.formatting = "link-string"), e.linkHref = !0, L(e)) : "error" } var r = { ")": /^(?:[^\\\(\)]|\\.|\((?:[^\\\(\)]|\\.)*\))*?(?=\))/, "]": /^(?:[^\\\[\]]|\\.|\[(?:[^\\\[\]]|\\.)*\])*?(?=\])/ }; function b(t, e) { return t.match(/^([^\]\\]|\\.)*\]:/, !1) ? (e.f = o, t.next(), d.highlightFormatting && (e.formatting = "link"), e.linkText = !0, L(e)) : C(t, e, T) } function o(t, e) { var i; return t.match("]:", !0) ? (e.f = e.inline = l, d.highlightFormatting && (e.formatting = "link"), i = L(e), e.linkText = !1, i) : (t.match(/^([^\]\\]|\\.)+/, !0), c.linkText) } function l(t, e) { return t.eatSpace() ? null : (t.match(/^[^\s]+/, !0), void 0 === t.peek() ? e.linkTitle = !0 : t.match(/^(?:\s+(?:"(?:[^"\\]|\\.)+"|'(?:[^'\\]|\\.)+'|\((?:[^)\\]|\\.)+\)))?/, !0), e.f = e.inline = T, c.linkHref + " url") } var h = { startState: function () { return { f: a, prevLine: { stream: null }, thisLine: { stream: null }, block: a, htmlState: null, indentation: 0, inline: T, text: e, formatting: !1, linkText: !1, linkHref: !1, linkTitle: !1, code: 0, em: !1, strong: !1, header: 0, setext: 0, hr: !1, taskList: !1, list: !1, listStack: [], quote: 0, trailingSpace: 0, trailingSpaceNewLine: !1, strikethrough: !1, emoji: !1, fencedEndRE: null } }, copyState: function (t) { return { f: t.f, prevLine: t.prevLine, thisLine: t.thisLine, block: t.block, htmlState: t.htmlState && w.copyState(g, t.htmlState), indentation: t.indentation, localMode: t.localMode, localState: t.localMode ? w.copyState(t.localMode, t.localState) : null, inline: t.inline, text: t.text, formatting: !1, linkText: t.linkText, linkTitle: t.linkTitle, linkHref: t.linkHref, code: t.code, em: t.em, strong: t.strong, strikethrough: t.strikethrough, emoji: t.emoji, header: t.header, setext: t.setext, hr: t.hr, taskList: t.taskList, list: t.list, listStack: t.listStack.slice(0), quote: t.quote, indentedCode: t.indentedCode, trailingSpace: t.trailingSpace, trailingSpaceNewLine: t.trailingSpaceNewLine, md_inside: t.md_inside, fencedEndRE: t.fencedEndRE } }, token: function (t, e) { if (e.formatting = !1, t != e.thisLine.stream) { if (e.header = 0, e.hr = !1, t.match(/^\s*$/, !0)) return n(e), null; if (e.prevLine = e.thisLine, e.thisLine = { stream: t }, e.taskList = !1, e.trailingSpace = 0, e.trailingSpaceNewLine = !1, !e.localState && (e.f = e.block, e.f != v)) { var i = t.match(/^\s*/, !0)[0].replace(/\t/g, "    ").length; if (e.indentation = i, e.indentationDiff = null, 0 < i) return null } } return e.f(t, e) }, innerMode: function (t) { return t.block == v ? { state: t.htmlState, mode: g } : t.localState ? { state: t.localState, mode: t.localMode } : { state: t, mode: h } }, indent: function (t, e, i) { return t.block == v && g.indent ? g.indent(t.htmlState, e, i) : t.localState && t.localMode.indent ? t.localMode.indent(t.localState, e, i) : w.Pass }, blankLine: n, getType: L, blockCommentStart: "\x3c!--", blockCommentEnd: "--\x3e", closeBrackets: "()[]{}''\"\"``", fold: "markdown" }; return h }, "xml"), w.defineMIME("text/markdown", "markdown"), w.defineMIME("text/x-markdown", "markdown") });</script>
</head>

<body>
    <!-- Navbar -->
    <nav class="navbar">
        <div class="navbar-brand">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                stroke-linejoin="round">
                <path
                    d="M15 22v-4a4.8 4.8 0 0 0-1-3.5c3 0 6-2 6-5.5.08-1.25-.27-2.48-1-3.5.28-1.15.28-2.35 0-3.5 0 0-1 0-3 1.5-2.64-.5-5.36-.5-8 0C6 2 5 2 5 2c-.3 1.15-.3 2.35 0 3.5A5.403 5.403 0 0 0 4 9c0 3.5 3 5.5 6 5.5-.39.49-.68 1.05-.85 1.65-.17.6-.22 1.23-.15 1.85v4" />
                <path d="M9 18c-4.51 2-5-2-7-2" />
            </svg>
            <span data-i18n="brand">Repo Glance</span>
        </div>
        <div class="navbar-actions">
            <select id="langSelect" class="lang-select" onchange="switchLang(this.value)">
                <option value="ja">日本語</option>
                <option value="en">English</option>
            </select>

            <div class="theme-switch-wrapper" title="Toggle Theme">
                <label class="theme-switch" for="themeCheckbox">
                    <input type="checkbox" id="themeCheckbox" onchange="toggleTheme(this.checked)" />
                    <div class="slider round"></div>
                </label>
            </div>

            <a href="https://github.com/E20C1/repo-glance" target="_blank" rel="noopener noreferrer" class="icon-btn"
                title="GitHub">
                <svg viewBox="0 0 24 24" width="20" height="20" fill="currentColor">
                    <path
                        d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z" />
                </svg>
            </a>
        </div>
    </nav>

    <!-- Hero -->
    <section class="hero">
        <h1 class="animate-in" data-i18n="heroTitle">リポジトリを<span class="accent">一つのテキスト</span>に</h1>
        <p class="animate-in delay-1" data-i18n="heroDesc">GitHubリポジトリのコードをAIが読み取りやすい形式に変換。完全オフライン対応。</p>
    </section>

    <!-- Main Form Card -->
    <div class="main-container">
        <div class="card animate-in delay-2">

            <!-- Tab Switcher -->
            <div class="tab-container">
                <div class="tab-item active" onclick="switchTab('repo')" data-i18n="tabRepo">GitHub Repo</div>
                <div class="tab-item" onclick="switchTab('folder')" data-i18n="tabFolder">Local Folder</div>
                <div class="tab-item" onclick="switchTab('zip')" data-i18n="tabZip">Local ZIP</div>
            </div>

            <!-- Panel: Repo URL -->
            <div id="panel-repo" class="tab-panel active">
                <div class="form-section">
                    <label class="form-label" data-i18n="labelUrl">GitHub URL</label>
                    <input type="text" id="repoUrl" class="form-input"
                        placeholder="https://github.com/username/repository" />
                </div>
                <div class="form-section">
                    <label class="form-label" data-i18n="labelToken">GitHub Token (オプション)</label>
                    <input type="password" id="token" class="form-input" placeholder="ghp_..." />
                    <div class="checkbox-wrapper">
                        <input type="checkbox" id="saveToken" onchange="handleTokenSave()" />
                        <label for="saveToken" data-i18n="labelSaveToken">ブラウザに保存する</label>
                    </div>
                    <span class="token-info" id="tokenStatus"></span>
                </div>
                <button id="fetchApiBtn" class="btn btn-primary" onclick="runApiProcess()"
                    data-i18n="btnApi">URLから取得</button>
            </div>

            <!-- Panel: Folder -->
            <div id="panel-folder" class="tab-panel">
                <div class="upload-area" onclick="document.getElementById('folderInput').click()">
                    <div class="upload-icon">📂</div>
                    <p data-i18n="msgSelectFolder">フォルダを選択してください</p>
                    <span style="font-size:0.8rem; color:var(--text-secondary);"
                        data-i18n="msgFolderInfo">ブラウザがファイルを読み取ります</span>
                </div>
                <!-- webkitdirectory allows folder selection -->
                <input type="file" id="folderInput" webkitdirectory directory multiple style="display:none;"
                    onchange="runFolderProcess()" />
            </div>

            <!-- Panel: ZIP -->
            <div id="panel-zip" class="tab-panel">
                <div class="upload-area" onclick="document.getElementById('zipInput').click()">
                    <div class="upload-icon">📦</div>
                    <p data-i18n="msgSelectZip">ZIPファイルを選択</p>
                    <p style="font-size:0.8rem; color:var(--text-secondary);" data-i18n="msgZipInfo">ドラッグ＆ドロップも可能</p>
                </div>
                <input type="file" id="zipInput" accept=".zip" style="display:none;" onchange="runZipProcess()" />
            </div>

            <hr class="divider" />
            <div id="status" class="status-bar" data-i18n="statusReady">準備完了</div>
            <textarea id="output" class="output-area" data-i18n="placeholderOutput" placeholder="ここに結果が表示されます..."
                readonly></textarea>
            <button id="copyBtn" class="btn btn-primary" onclick="copyToClipboard()" disabled style="margin-top:12px;"
                data-i18n="btnCopy">📋 全テキストをコピー</button>
        </div>
    </div>

    <!-- Feature Grid -->
    <div class="feature-grid">
        <div class="feature-card animate-in delay-1">
            <div class="feature-icon">🔒</div>
            <h3 data-i18n="feat1Title">完全オフライン</h3>
            <p data-i18n="feat1Desc">ローカルZIPファイルを直接解析。サーバー送信なし。</p>
        </div>
        <div class="feature-card animate-in delay-2">
            <div class="feature-icon">🌐</div>
            <h3 data-i18n="feat2Title">GitHub API対応</h3>
            <p data-i18n="feat2Desc">URLとトークンでリモートリポジトリも取得可能。</p>
        </div>
        <div class="feature-card animate-in delay-3">
            <div class="feature-icon">📄</div>
            <h3 data-i18n="feat3Title">ワンクリックコピー</h3>
            <p data-i18n="feat3Desc">生成テキストをクリップボードへ即座にコピー。</p>
        </div>
    </div>

    <!-- Footer -->
    <footer class="footer">
        <p data-i18n="footer">Released under the MIT License.<br>Copyright © 2026 E20C1</p>
    </footer>

    <script>


        const IGNORE_EXTENSIONS = [
            '.png', '.jpg', '.jpeg', '.gif', '.ico', '.svg', '.mp4', '.mp3',
            '.pdf', '.exe', '.dll', '.bin', '.zip', '.tar', '.gz',
            '.pyc', '.class', '.o', '.obj', 'package-lock.json', 'yarn.lock', '.git', '.DS_Store'
        ];
        const IGNORE_DIRS = ['.git', 'node_modules', 'dist', 'build', 'vendor', '__pycache__', '.idea', '.vscode'];

        window.addEventListener('DOMContentLoaded', () => {
            const tokenStatus = document.getElementById('tokenStatus');
            const envToken = (typeof window.ENV_TOKEN !== 'undefined') ? window.ENV_TOKEN : "";
            if (envToken) tokenStatus.textContent = t('msgTokenSourceEnv');

            // Load saved token
            const savedToken = localStorage.getItem('repo-glance-token');
            if (savedToken) {
                document.getElementById('token').value = savedToken;
                document.getElementById('saveToken').checked = true;
            }

            // Add input listener to update storage if checked
            document.getElementById('token').addEventListener('input', (e) => {
                if (document.getElementById('saveToken').checked) {
                    localStorage.setItem('repo-glance-token', e.target.value.trim());
                }
            });
        });

        function handleTokenSave() {
            const checkbox = document.getElementById('saveToken');
            const tokenInput = document.getElementById('token');
            if (checkbox.checked) {
                localStorage.setItem('repo-glance-token', tokenInput.value.trim());
            } else {
                localStorage.removeItem('repo-glance-token');
            }
        }

        // Helper for JS-based translations
        function t(key) {
            return I18N[currentLang][key] || key;
        }

        // ===== Toast Notification Logic =====
        function showToast(message, type = 'info') {
            const container = document.getElementById('toast-container') || createToastContainer();
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.innerHTML = `<span>${message}</span>`;

            // Auto remove
            const remove = () => {
                toast.style.animation = 'toastFadeOut 0.3s forwards';
                toast.addEventListener('animationend', () => toast.remove());
            };
            setTimeout(remove, 3000);
            toast.onclick = remove;

            container.appendChild(toast);
        }

        function createToastContainer() {
            const el = document.createElement('div');
            el.id = 'toast-container';
            el.className = 'toast-container';
            document.body.appendChild(el);
            return el;
        }

        function setUIState(processing, message = "") {
            const statusEl = document.getElementById('status');
            const outputEl = document.getElementById('output');
            const apiBtn = document.getElementById('fetchApiBtn');
            const folderInput = document.getElementById('folderInput');
            const zipInput = document.getElementById('zipInput');
            const copyBtn = document.getElementById('copyBtn');

            if (processing) {
                outputEl.value = '';
                if (apiBtn) apiBtn.disabled = true;
                if (folderInput) folderInput.disabled = true;
                if (zipInput) zipInput.disabled = true;
                copyBtn.disabled = true;
                statusEl.innerHTML = message;
            } else {
                if (apiBtn) apiBtn.disabled = false;
                if (folderInput) folderInput.disabled = false;
                if (zipInput) zipInput.disabled = false;
                if (message) statusEl.textContent = message;
            }
        }

        async function runApiProcess() {
            const urlInput = document.getElementById('repoUrl').value.trim();
            const { token, source } = resolveToken();

            if (!urlInput) { showToast(t('msgInputUrl'), 'error'); return; }

            setUIState(true, `${t('msgProcessingApi')} <span style="font-size:0.8em; color:#888;">[Token: ${source}]</span>`);
            const statusEl = document.getElementById('status');
            const outputEl = document.getElementById('output');

            try {
                const repoInfo = parseGithubUrl(urlInput);
                if (!repoInfo) throw new Error(t('msgInvalidUrl'));

                const headers = { 'Accept': 'application/vnd.github.v3+json' };
                if (token) headers['Authorization'] = `token ${token}`;

                const repoRes = await fetch(`https://api.github.com/repos/${repoInfo.owner}/${repoInfo.repo}`, { headers });
                if (!repoRes.ok) throw new Error(`API Error: ${repoRes.status}`);
                const repoData = await repoRes.json();
                const defaultBranch = repoData.default_branch;

                statusEl.innerHTML = t('msgFetchList');
                const treeRes = await fetch(`https://api.github.com/repos/${repoInfo.owner}/${repoInfo.repo}/git/trees/${defaultBranch}?recursive=1`, { headers });
                if (!treeRes.ok) throw new Error(`Tree Error: ${treeRes.status}`);
                const treeData = await treeRes.json();

                const files = treeData.tree.filter(item => {
                    if (item.type !== 'blob') return false;
                    return !isIgnored(item.path);
                });

                if (files.length === 0) throw new Error(t('msgFileNotFound'));
                if (files.length > 300 && !token) {
                    if (!confirm(t('msgConfirmLarge').replace('{n}', files.length))) throw new Error(t('msgCancel'));
                }

                statusEl.innerHTML = `${t('msgFetchContent')} (0/${files.length})...`;
                const fileContents = [];
                const BATCH_SIZE = 5;

                for (let i = 0; i < files.length; i += BATCH_SIZE) {
                    const batch = files.slice(i, i + BATCH_SIZE);
                    const promises = batch.map(async (file) => {
                        try {
                            const blobRes = await fetch(file.url, { headers });
                            if (!blobRes.ok) return { path: file.path, content: `[Error: ${blobRes.status}]` };
                            const blobData = await blobRes.json();
                            return { path: file.path, content: decodeBase64(blobData.content) };
                        } catch (e) {
                            return { path: file.path, content: `[Error: ${e.message}]` };
                        }
                    });
                    const results = await Promise.all(promises);
                    fileContents.push(...results);
                    statusEl.innerHTML = `${t('msgFetchContent')} (${Math.min(i + BATCH_SIZE, files.length)}/${files.length})...`;
                }

                const metaInfo = { repo: `${repoInfo.owner}/${repoInfo.repo}`, url: urlInput, branch: defaultBranch, method: `API (${source})` };
                outputEl.value = generateFinalOutput(metaInfo, fileContents);
                setUIState(false, t('msgComplete'));
                document.getElementById('copyBtn').disabled = false;

            } catch (err) {
                console.error(err);
                setUIState(false, `${t('msgError')} ${err.message}`);
                outputEl.value = `${t('msgErrorDetail')}\n${err.message}`;
            }
        }

        async function runZipProcess() {
            const fileInput = document.getElementById('zipInput');
            if (!fileInput.files || fileInput.files.length === 0) { showToast(t('msgInputZip'), 'error'); return; }
            const file = fileInput.files[0];
            setUIState(true, t('msgProcessingZip'));
            const outputEl = document.getElementById('output');

            try {
                if (typeof JSZip === 'undefined') throw new Error(t('msgZipLibError'));

                const zip = new JSZip();
                const loadedZip = await zip.loadAsync(file);
                const fileContents = [];

                const zipEntries = [];
                loadedZip.forEach((relativePath, zipEntry) => zipEntries.push({ path: relativePath, entry: zipEntry }));
                zipEntries.sort((a, b) => a.path.localeCompare(b.path));

                for (const item of zipEntries) {
                    if (item.entry.dir || isIgnored(item.path)) continue;
                    try {
                        const content = await item.entry.async("string");
                        fileContents.push({ path: item.path, content: content });
                    } catch (e) {
                        fileContents.push({ path: item.path, content: `[Error reading zip entry: ${e.message}]` });
                    }
                }

                if (fileContents.length === 0) throw new Error(t('msgFileNotFound'));
                const metaInfo = { repo: file.name, url: "Local File", branch: "Unknown", method: "Local ZIP (Offline)" };
                outputEl.value = generateFinalOutput(metaInfo, fileContents);
                setUIState(false, t('msgZipComplete'));
                document.getElementById('copyBtn').disabled = false;

            } catch (err) {
                console.error(err);
                setUIState(false, `${t('msgError')} ${err.message}`);
                outputEl.value = `ZIP Error:\n${err.message}`;
            }
        }

        async function runFolderProcess() {
            const fileInput = document.getElementById('folderInput');
            if (!fileInput.files || fileInput.files.length === 0) { showToast(t('msgInputFolder'), 'error'); return; }

            setUIState(true, t('msgProcessingFolder'));
            const outputEl = document.getElementById('output');
            const files = Array.from(fileInput.files);

            try {
                // Determine root folder name from the first file's path usually "Root/sub/..."
                const rootName = files[0].webkitRelativePath.split('/')[0] || "LocalFolder";

                const fileContents = [];
                // Sort by path
                files.sort((a, b) => a.webkitRelativePath.localeCompare(b.webkitRelativePath));

                const reader = (file) => new Promise((resolve, reject) => {
                    const r = new FileReader();
                    r.onload = () => resolve(r.result);
                    r.onerror = reject;
                    r.readAsText(file);
                });

                let processedCount = 0;
                const BATCH_SIZE = 10;

                for (let i = 0; i < files.length; i += BATCH_SIZE) {
                    const batch = files.slice(i, i + BATCH_SIZE);
                    const results = await Promise.all(batch.map(async f => {
                        if (isIgnored(f.webkitRelativePath)) return null;
                        try {
                            const content = await reader(f);
                            return { path: f.webkitRelativePath, content: content };
                        } catch (e) {
                            return { path: f.webkitRelativePath, content: `[Error: ${e.message}]` };
                        }
                    }));

                    results.forEach(r => { if (r) fileContents.push(r); });
                    processedCount += batch.length;
                    // Optional update status if many files
                }

                if (fileContents.length === 0) throw new Error(t('msgFileNotFound'));
                const metaInfo = { repo: rootName, url: "Local Folder", branch: "Unknown", method: "Local Folder (Offline)" };
                outputEl.value = generateFinalOutput(metaInfo, fileContents);
                setUIState(false, t('msgFolderComplete'));
                document.getElementById('copyBtn').disabled = false;

            } catch (err) {
                console.error(err);
                setUIState(false, `${t('msgError')} ${err.message}`);
                outputEl.value = `Folder Error:\n${err.message}`;
            }
        }

        // ===== Tabs =====
        function switchTab(tabId) {
            // Update Tab UI
            document.querySelectorAll('.tab-item').forEach(el => el.classList.remove('active'));
            const activeTab = document.querySelector(`.tab-item[onclick="switchTab('${tabId}')"]`);
            if (activeTab) activeTab.classList.add('active');

            // Show Panel
            document.querySelectorAll('.tab-panel').forEach(el => el.classList.remove('active'));
            const panel = document.getElementById(`panel-${tabId}`);
            if (panel) panel.classList.add('active');
        }

        function isIgnored(path) {
            const pathParts = path.split('/');
            const fileName = pathParts[pathParts.length - 1];
            if (path.includes('__MACOSX')) return true;
            if (pathParts.some(p => IGNORE_DIRS.includes(p))) return true;
            if (IGNORE_EXTENSIONS.some(ext => fileName.toLowerCase().endsWith(ext))) return true;
            return false;
        }

        function generateFinalOutput(meta, files) {
            let out = '';
            out += `---\n`;
            out += `Repository: ${meta.repo}\n`;
            out += `Url: ${meta.url}\n`;
            out += `Branch: ${meta.branch}\n`;
            out += `Files: ${files.length}\n`;
            out += `Method: ${meta.method}\n`;
            out += `Generated at: ${new Date().toLocaleString()}\n`;
            out += `---\n\n`;

            out += '```\n';
            out += `File Tree:\n`;
            try { out += generateAsciiTree(files.map(f => f.path)); } catch (e) { out += `(Tree Error: ${e.message})`; }
            out += '\n```\n\n';

            files.forEach(f => {
                out += '```' + f.path + '\n';
                out += f.content;
                if (!f.content.endsWith('\n')) out += '\n';
                out += '```\n\n';
            });
            return out;
        }

        function resolveToken() {
            const uiToken = document.getElementById('token').value.trim();
            const envToken = (typeof window.ENV_TOKEN !== 'undefined') ? window.ENV_TOKEN : "";
            let tokenToUse = HTML_CONFIG_TOKEN || envToken || uiToken;
            let source = HTML_CONFIG_TOKEN ? "HTML" : (envToken ? "env.js" : "Manual");
            if (uiToken) { tokenToUse = uiToken; source = "Manual (Override)"; }
            return { token: tokenToUse, source };
        }

        function parseGithubUrl(url) {
            try {
                const urlObj = new URL(url);
                const pathParts = urlObj.pathname.split('/').filter(p => p);
                if (pathParts.length >= 2) return { owner: pathParts[0], repo: pathParts[1] };
            } catch (e) { }
            return null;
        }

        function generateAsciiTree(paths) {
            const result = [];
            const level = { result: [] };
            paths.forEach(path => {
                path.split('/').reduce((r, name, i, a) => {
                    if (!r[name]) { r[name] = { result: [] }; r.result.push({ name: name, children: r[name] }); }
                    return r[name];
                }, level);
            });
            function format(node, prefix) {
                const children = node.result;
                if (!children) return;
                for (let i = 0; i < children.length; i++) {
                    const child = children[i];
                    const isLast = i === children.length - 1;
                    result.push(`${prefix}${isLast ? '└── ' : '├── '}${child.name}`);
                    format(child.children, prefix + (isLast ? '    ' : '│   '));
                }
            }
            format(level, '');
            return result.join('\n');
        }

        function decodeBase64(base64) {
            try {
                const binaryString = atob(base64.replace(/\s/g, ''));
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) bytes[i] = binaryString.charCodeAt(i);
                return new TextDecoder('utf-8').decode(bytes);
            } catch (e) { return "[Binary/Error]"; }
        }

        function copyToClipboard() {
            const copyText = document.getElementById("output");
            copyText.select();
            navigator.clipboard.writeText(copyText.value).then(() => {
                const btn = document.getElementById('copyBtn');
                const orig = btn.textContent;
                btn.textContent = t('msgCopySuccess');
                setTimeout(() => btn.textContent = orig, 2000);
            });
        }

        // ===== i18n =====
        const I18N = {
            ja: {
                brand: "Repo Glance",
                heroTitle: 'リポジトリを<span class="accent">一つのテキスト</span>に',
                heroDesc: "GitHubリポジトリのコードをAIが読み取りやすい形式に変換。完全オフライン対応。",
                // Tabs
                tabRepo: "GitHubリポジトリ",
                tabFolder: "ローカルフォルダ",
                tabZip: "ローカルZIP",

                labelUrl: "GitHub URL",
                labelToken: "GitHub Token (オプション)",
                labelSaveToken: "トークンをブラウザに保存する",
                btnApi: "URLから取得",
                btnZip: "ZIPを選択",
                msgSelectFolder: "フォルダを選択してください",
                msgFolderInfo: "ブラウザがフォルダ内のファイルを読み取ります",
                msgSelectZip: "ZIPファイルを選択",
                msgZipInfo: "ドラッグ＆ドロップも可能",

                statusReady: "準備完了",
                btnCopy: "📋 全テキストをコピー",
                feat1Title: "完全オフライン",
                feat1Desc: "ローカルZIPファイルを直接解析。サーバー送信なし。",
                feat2Title: "GitHub API対応",
                feat2Desc: "URLとトークンでリモートリポジトリも取得可能。",
                feat3Title: "ワンクリックコピー",
                feat3Desc: "生成テキストをクリップボードへ即座にコピー。",
                footer: "Released under the MIT License.<br>Copyright © 2026 E20C1",
                // dynamic JS strings
                msgInputUrl: "URLを入力してください",
                msgInputZip: "ZIPファイルを選択してください",
                msgInputFolder: "フォルダを選択してください",
                msgProcessingApi: "API経由で処理中...",
                msgProcessingZip: "ZIPファイルを処理中...",
                msgProcessingFolder: "フォルダを処理中...",
                msgComplete: "完了しました！",
                msgZipComplete: "ZIP解析完了！",
                msgFolderComplete: "フォルダ解析完了！",
                msgError: "エラー: ",
                msgErrorDetail: "エラー詳細:",
                msgFileNotFound: "ファイルが見つかりません",
                msgInvalidUrl: "無効なGitHub URLです",
                msgCancel: "キャンセル",
                msgConfirmLarge: "{n}件のファイルがあります。続行しますか？",
                msgFetchList: "ファイルリストを取得中...",
                msgFetchContent: "ファイル内容を取得中",
                placeholderOutput: "ここに結果が表示されます...",
                msgCopySuccess: "コピーしました！ ✨",
                msgTokenSourceHtml: "(HTML設定トークン有効)",
                msgTokenSourceEnv: "(env.jsトークン有効)",
                msgZipLibError: "JSZipライブラリが見つかりません。コードが正しく埋め込まれているか確認してください。"
            },
            en: {
                brand: "Repo Glance",
                heroTitle: 'Pack your repo into <span class="accent">a single text</span>',
                heroDesc: "Convert GitHub repository code into an AI-friendly format. Fully offline capable.",
                // Tabs
                tabRepo: "GitHub Repo",
                tabFolder: "Local Folder",
                tabZip: "Local ZIP",

                labelUrl: "GitHub URL",
                labelToken: "GitHub Token (Optional)",
                labelSaveToken: "Save Token to browser",
                btnApi: "Fetch from URL",
                btnZip: "Select ZIP",
                msgSelectFolder: "Select a folder",
                msgFolderInfo: "Browser will read files in the folder",
                msgSelectZip: "Select ZIP file",
                msgZipInfo: "Drag & Drop supported",

                statusReady: "Ready",
                btnCopy: "📋 Copy All Text",
                feat1Title: "Fully Offline",
                feat1Desc: "Parse local ZIP files directly. No data sent to any server.",
                feat2Title: "GitHub API",
                feat2Desc: "Fetch remote repositories with URL and token.",
                feat3Title: "One-Click Copy",
                feat3Desc: "Copy generated text to clipboard instantly.",
                footer: "Released under the MIT License.<br>Copyright © 2026 E20C1",
                // dynamic JS strings
                msgInputUrl: "Please enter a URL",
                msgInputZip: "Please select a ZIP file",
                msgInputFolder: "Please select a folder",
                msgProcessingApi: "Processing via API...",
                msgProcessingZip: "Processing ZIP file...",
                msgProcessingFolder: "Processing folder...",
                msgComplete: "Completed!",
                msgZipComplete: "ZIP analysis completed!",
                msgFolderComplete: "Folder analysis completed!",
                msgError: "Error: ",
                msgErrorDetail: "Error Details:",
                msgFileNotFound: "File not found",
                msgInvalidUrl: "Invalid GitHub URL",
                msgCancel: "Cancelled",
                msgConfirmLarge: "{n} files found. Continue?",
                msgFetchList: "Fetching file list...",
                msgFetchContent: "Fetching file content",
                placeholderOutput: "Results will be shown here...",
                msgCopySuccess: "Copied! ✨",
                msgTokenSourceHtml: "(HTML Config Token Active)",
                msgTokenSourceEnv: "(env.js Token Active)",
                msgZipLibError: "JSZip library not found. Please check code embedding."
            }
        };

        let currentLang = 'ja';

        function switchLang(lang) {
            currentLang = lang;
            const texts = I18N[lang];
            if (!texts) return;
            document.querySelectorAll('[data-i18n]').forEach(el => {
                const key = el.getAttribute('data-i18n');
                if (texts[key]) {
                    if (el.tagName === 'INPUT' || el.tagName === 'TEXTAREA') {
                        el.placeholder = texts[key];
                    } else {
                        el.innerHTML = texts[key];
                    }
                }
            });
            localStorage.setItem('repo-glance-lang', lang);
        }

        // ===== Theme Toggle =====
        function toggleTheme(isChecked) {
            const html = document.documentElement;
            const next = isChecked ? 'dark' : 'light';
            html.setAttribute('data-theme', next);
            localStorage.setItem('repo-glance-theme', next);
        }

        // ===== Init on load =====
        (function initThemeAndLang() {
            const savedTheme = localStorage.getItem('repo-glance-theme') || 'light';
            document.documentElement.setAttribute('data-theme', savedTheme);

            // Set switch state
            const themeSwitch = document.getElementById('themeCheckbox');
            if (themeSwitch) {
                themeSwitch.checked = savedTheme === 'dark';
            }

            const savedLang = localStorage.getItem('repo-glance-lang');
            if (savedLang) {
                currentLang = savedLang;
                const langSelect = document.getElementById('langSelect');
                if (langSelect) {
                    langSelect.value = savedLang;
                    switchLang(savedLang);
                }
            }
        })();
    </script>
</body>

</html>
